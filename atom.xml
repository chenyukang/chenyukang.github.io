<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cyukang.com/"/>
  <updated>2019-01-15T15:23:53.344Z</updated>
  <id>http://cyukang.com/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《见识》阅读笔记</title>
    <link href="http://cyukang.com/2019/01/10/book-review-wujun.html"/>
    <id>http://cyukang.com/2019/01/10/book-review-wujun.html</id>
    <published>2019-01-10T15:22:40.000Z</published>
    <updated>2019-01-15T15:23:53.344Z</updated>
    
    <content type="html"><![CDATA[<p>到年底小组内还有多余的预算，于是大家都在网上选书。看到吴军出了两本新书，出于对作者的信任就直接下单了。上个周末就花了些时间很快地看完了两本。内容稍微有些重合，主要是有的例子会拿来阐述多个道理。所以两本连着看会有些作者凑书的感受。当然两本都还是不错的，读完《态度》对于我这个新手爸爸来说也是收获不少。个人更推荐《见识》这本书。</p>
<p>《见识》更多关注个人成长、看待问题的视角、工作职场中的一些经验。其中几个主题：</p>
<h3 id="人生是一条河"><a href="#人生是一条河" class="headerlink" title="人生是一条河"></a>人生是一条河</h3><p>每个人都希望自己这条河能够更宽一点、更深一点、更长一点。只有给予才能带来幸福感。</p>
<p>认识到生命是有限的，应该挑重要的事做，向死而生。</p>
<h3 id="人生需要做减法"><a href="#人生需要做减法" class="headerlink" title="人生需要做减法"></a>人生需要做减法</h3><p>不做选择的幸福，从另外一个角度去解释为什么印度人在硅谷更容易成功。我觉得是有一定道理的，印度人因为名族的阶级观念，在生活工作中少了一些选择，却能一直在某个领域坚持数十年。第一份工作的过程中，接触了不少印度人。其中一位从印度到硅谷，一直都是在一个公司工作了 14 年左右，我问他为什么不跳槽，他倒觉得无所谓，安家乐业地每天过得很稳。少了选择就不容易思前想后，一门子扎进去了。在工作上，很多人都不能坚持一直耕耘于某个特定的领域，坚持下来的就成了。</p>
<p>做人与作诗：这章讲的道理类似于『出世』与『入世』，让我想起《月亮和六便士》里的画家。</p>
<p>要会做减法，为“做重要的事”服务，同时认清什么是重要的事。</p>
<h3 id="西瓜与芝麻"><a href="#西瓜与芝麻" class="headerlink" title="西瓜与芝麻"></a>西瓜与芝麻</h3><p>想起骚年的时候总是花时间去找些破解软件，舍不得一点钱买些软件或者工具，渐渐地意识到了这就是为了芝麻丢西瓜的事。类似的还有很多，现在则改变了认知，能付费节约时间则付费，能花钱买到更好的则花钱。</p>
<h3 id="生也有涯-知也无涯"><a href="#生也有涯-知也无涯" class="headerlink" title="生也有涯 知也无涯"></a>生也有涯 知也无涯</h3><p>正因为如此，生活、学习、工作中需要聚焦，别分散精力。人能在某一段时间内做好一件事，并且做得比其他人好，好到自己觉得不能更好为止。也正是因为『知也无涯』，不要为了自己的未知而焦虑，因为这是再正常不过的了，自己学起来就好，别丢掉好奇心。</p>
<h3 id="我们一定比-18-世纪的人过得幸福么？"><a href="#我们一定比-18-世纪的人过得幸福么？" class="headerlink" title="我们一定比 18 世纪的人过得幸福么？"></a>我们一定比 18 世纪的人过得幸福么？</h3><p>显然，当代人并不幸福，特别是我们这些年轻的一代。物质上倒谈不上匮乏，而是没有自己的时间，然后则是人到中年必不可免的生活压力和焦虑。EB的说唱里有段歌词『所有人都忙着想要更多的东西 所以得到之后就没有精力去珍惜 情歌越来越多 真情却越来越少 巧克力的保质期越来越长 爱情的保质期却越来越短 生活变得越来越丰富多彩 于是越来越多的人变得分不清黑白』。</p>
<h3 id="我们与天才差多远"><a href="#我们与天才差多远" class="headerlink" title="我们与天才差多远"></a>我们与天才差多远</h3><p>我们绝大部分人成长过程中，迟早会意识到自己不过是芸芸众生中的普通人。硅谷中，我认为有一种气氛特别好，就是对聪明人的崇敬。之前的老板应该已经算是又聪明又勤奋的那种，谈话中总是会说起自己碰见过的聪明人，聪明到如何程度，以及一些小故事。有的生理上的差异是解释不清的，比如有的人就是善于计算，有的人精于细节。不过天才的见识、勇气、或者方法上有的是值得学习的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到年底小组内还有多余的预算，于是大家都在网上选书。看到吴军出了两本新书，出于对作者的信任就直接下单了。上个周末就花了些时间很快地看完了两本。内容稍微有些重合，主要是有的例子会拿来阐述多个道理。所以两本连着看会有些作者凑书的感受。当然两本都还是不错的，读完《态度》对于我这个新
    
    </summary>
    
    
      <category term="Reading" scheme="http://cyukang.com/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>使用 Markown 编辑公众号方法</title>
    <link href="http://cyukang.com/2019/01/06/wechat-tools.html"/>
    <id>http://cyukang.com/2019/01/06/wechat-tools.html</id>
    <published>2019-01-06T15:48:39.000Z</published>
    <updated>2019-01-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>技术人员很多都喜欢使用 Markdown 格式来编辑文档，但是公众号后台默认不支持。</p>
<p>所以关于工具和流程，最近我摸索出来目前最适合自己的一套是：</p>
<p>还是维护之前 Hexo 那套，像代码那样使用 Git 管理，内容会上传到 Github 上。</p>
<p>继续使用 Typora 编辑 Markdown 文件。注意使用图片工具 IPic 来方便地把图片上传到图床上，其实免费的微博图床就足够。然后使用在线的转换工具<a href="http://md.codingpy.com/" target="_blank" rel="external">md.codingpy.com</a>即可很方便地把 Markdown 转成适合公众号的内容，复制粘贴到后台编辑器里。</p>
<p>这样在个人网站和公众号里都会有相同的内容，而且格式之类的都比较统一。</p>
<p>这里再次推荐 Typora: <a href="https://typora.io/" target="_blank" rel="external">https://typora.io/</a> 这个工具，会让人特别有写东西的冲动。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyxb4230duj310u0kmjs7.jpg" alt="image-20190106235957370"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;技术人员很多都喜欢使用 Markdown 格式来编辑文档，但是公众号后台默认不支持。&lt;/p&gt;
&lt;p&gt;所以关于工具和流程，最近我摸索出来目前最适合自己的一套是：&lt;/p&gt;
&lt;p&gt;还是维护之前 Hexo 那套，像代码那样使用 Git 管理，内容会上传到 Github 上。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开始写公众号</title>
    <link href="http://cyukang.com/2019/01/04/try-wechat-blog.html"/>
    <id>http://cyukang.com/2019/01/04/try-wechat-blog.html</id>
    <published>2019-01-04T14:57:24.000Z</published>
    <updated>2019-01-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018 过得很快，对于自己来说有点颓废、也很辛苦。说是颓废因为花了一些时间在游戏上，还有不少焦虑。最近看书，翻到胡适 1932 年一篇《寄语即将毕业的大学生》中写到，人到社会容易丢掉求知的欲望、抛弃学生时代的理想追求，为了防止堕落文中给出三点建议。读来觉得颇有道理，这三点建议放在现在也合适： </p>
<blockquote>
<p>总得时时寻一两个值得研究的问题</p>
<p>总得多发展一点非职业的兴趣</p>
<p>你总得有一点信心</p>
</blockquote>
<p>新的一年想着尝试做些改变，逼着自己再做一些其他尝试，不然生活除了工作和日常，真是过得有些索然无趣了。业余写些东西是很好的积累，从 2006 年左右开始一直都有写博文的习惯，从搜狐、Yo2、WordPress， 一直到后来的  Hexo 托管到 Github 上。个人域名 <a href="http://cyukang.com">http://cyukang.com</a> 用了多年，其中的文章大概也有 140 来篇。在这么多年写博客的过程中收获不少，认识了一些朋友，也锻炼了自己的文字能力。</p>
<p>平台和工具一直在变化，文字只是一种表达的方式，能写出来还是得靠自己平时所想、所做。之前写的技术类的文章偏多，因此一直觉得公众号这种生态圈有些封闭，不利于检索。不过终究是大众的选择，公众号里好的内容也很多。如果要逼着自己写，有些人看、有些互动自然是更好的。不求有多少关注，但愿自己能坚持多写写而已。</p>
<p>关于写什么，我也还不太清楚。在技术方面可能涉猎较多，精通的不算多。总之算得上技术爱好者，还未丢掉这块兴趣。所以这里多是关于工作、技术的一些学习总结、实践等。把技术相关的东西写得通俗易懂绝非易事，希望在这方面能有更多进步。另外我更想拓展自己在其他方面的知识和积累，所以公众号上会写更多读书笔记和思考。『构成我们学习的最大阻碍是已知的东西，而非未知』，局限于技术角度并非好事。</p>
<p>关于公众号名字『递归说』，这是乱想的，刚好在取名的时候想到了而已。听起来比较好念，而且递归真是计算机里一个很简洁、优美的概念，也是解决问题的一种方法，还可以延伸理解为『自我进化』吧。人这一辈子不也像一个递归么，过一年就像过了一个迭代，而且都是有终点的。</p>
<p>先写起来再继续摸索找方向吧，总得对自己有些信心。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fyv11g49sjj30zk0sgter.jpg" alt="134871342111"></p>
<p>扫描关注： </p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fyvm0wf0tmj309k09kjrc.jpg" alt="qrcode_for_gh_5f51bbbd18c0_344"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 过得很快，对于自己来说有点颓废、也很辛苦。说是颓废因为花了一些时间在游戏上，还有不少焦虑。最近看书，翻到胡适 1932 年一篇《寄语即将毕业的大学生》中写到，人到社会容易丢掉求知的欲望、抛弃学生时代的理想追求，为了防止堕落文中给出三点建议。读来觉得颇有道理，这三点
    
    </summary>
    
    
      <category term="WeChat" scheme="http://cyukang.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>使用 peco 飞起 zsh</title>
    <link href="http://cyukang.com/2019/01/04/peco-for-zsh.html"/>
    <id>http://cyukang.com/2019/01/04/peco-for-zsh.html</id>
    <published>2019-01-04T14:55:22.000Z</published>
    <updated>2019-01-10T14:58:10.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="peco"><a href="#peco" class="headerlink" title="peco"></a>peco</h3><p><a href="https://github.com/peco/peco" target="_blank" rel="external">peco</a> 是一个能做交互式 filte 的工具，是 <a href="https://github.com/mooz/percol" target="_blank" rel="external">percol</a> 的 Go 实现。特别适合在 shell 里做一些过滤操作，当然适合做日志方面的过滤。典型的使用方法是：</p>
<p><img src="https://camo.githubusercontent.com/6ed15cca08fd6972d12e67ee1f1fe84caa14744b/687474703a2f2f7065636f2e6769746875622e696f2f696d616765732f7065636f2d64656d6f2d70732e676966" alt="gif"></p>
<h3 id="zsh-配置"><a href="#zsh-配置" class="headerlink" title="zsh 配置"></a>zsh 配置</h3><p>下面这个配置主要增强了 zsh 的 history 补全，以及<code>pwdf</code>可以用来迅速找一个文件，并拷贝其全路径：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><div class="line"><span class="keyword">function</span> exists &#123; which <span class="variable">$1</span> &amp;&gt; /dev/null &#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> exists peco; then</div><div class="line">    <span class="keyword">function</span> peco_select_history() &#123;</div><div class="line">        local tac</div><div class="line">        exists gtac &amp;&amp; tac=<span class="string">"gtac"</span> || &#123; exists tac &amp;&amp; tac=<span class="string">"tac"</span> || &#123; tac=<span class="string">"tail -r"</span> &#125; &#125;</div><div class="line">        BUFFER=$(fc -l -n <span class="number">1</span> | eval <span class="variable">$tac</span> | peco --query <span class="string">"<span class="variable">$LBUFFER</span>"</span> --layout=bottom-up)</div><div class="line">        CURSOR=$<span class="comment">#BUFFER         # move cursor</span></div><div class="line">        zle -R -c               <span class="comment"># refresh</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    zle -N peco_select_history</div><div class="line">    bindkey <span class="string">'^R'</span> peco_select_history</div><div class="line">fi</div><div class="line"></div><div class="line">OS_NAME=`uname`</div><div class="line"><span class="keyword">function</span> pclip() &#123;</div><div class="line">    <span class="keyword">if</span> [ <span class="variable">$OS_NAME</span> = <span class="string">"CYGWIN"</span> ]; then</div><div class="line">	      putclip <span class="string">"$@"</span>;</div><div class="line">    elif [ <span class="variable">$OS_NAME</span> = <span class="string">"Darwin"</span> ]; then</div><div class="line">	      pbcopy <span class="string">"$@"</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">	      <span class="keyword">if</span> [ -x /usr/bin/xsel ]; then</div><div class="line">	          xsel -ib <span class="string">"$@"</span>;</div><div class="line">	      <span class="keyword">else</span></div><div class="line">	          <span class="keyword">if</span> [ -x /usr/bin/xclip ]; then</div><div class="line">		            xclip -selection c <span class="string">"$@"</span>;</div><div class="line">	          <span class="keyword">else</span></div><div class="line">		            echo <span class="string">"Neither xsel or xclip is installed!"</span></div><div class="line">	          fi</div><div class="line">	      fi</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> pwdf() &#123;</div><div class="line">    local current_dir=`pwd`</div><div class="line">    local copied_file=`find <span class="variable">$current_dir</span> -type f -print | peco --layout=bottom-up`</div><div class="line">    echo -n <span class="variable">$copied_file</span> |pclip;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;peco&quot;&gt;&lt;a href=&quot;#peco&quot; class=&quot;headerlink&quot; title=&quot;peco&quot;&gt;&lt;/a&gt;peco&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/peco/peco&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
    
      <category term="Rust" scheme="http://cyukang.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>编译脚本到二进制</title>
    <link href="http://cyukang.com/2019/01/01/compile-script-to-binary-for-obfuscation.html"/>
    <id>http://cyukang.com/2019/01/01/compile-script-to-binary-for-obfuscation.html</id>
    <published>2019-01-01T14:55:22.000Z</published>
    <updated>2018-12-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>因为自己习惯使用 expect 脚本登录各种服务器，有一段时间因为要登录的服务器太多了，所以之前写过一个程序来管理各种 expect 脚本。实现思路是根据配置文件，用一个程序来动态生成脚本，执行完之后再删除。这样临时生成的文件里也是包含密码等信息的。最近突然想是不是可以直接写一个程序，把所有脚本类的程序转换为二进制可执行文件<a href="https://www.slideshare.net/LizBaillie/rustconf-2016-illustrated-adventure-guide-65894363" target="_blank" rel="external">^image</a>。我不想把密码之类的直接写在固定的脚本里面，所以密码也是被编译在可执行的二进制文件里的，这样能达到一些代码混淆的目的。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fyuxr5d6y5j30yg0j6gsy.jpg" alt="image-20190101234053094"></p>
<h3 id="rshc-的开发"><a href="#rshc-的开发" class="headerlink" title="rshc 的开发"></a>rshc 的开发</h3><p>这个程序看起来有些好玩，所以先我先搜了一下是否之前有其他人这样做过。于是找到了 <a href="https://github.com/neurobin/shc" target="_blank" rel="external">shc</a> 这个开源程序，这个最初版本是 96 年用 C 写的，最终执行的时候还是用 execvp 调用解释器执行各种脚本。我使用了一下发现居然不支持 expect 之类的。然后想着自己写个玩玩，顺便再动手用用最近看得又心痒的 Rust，最后用搞出来一个初版: <a href="https://github.com/chenyukang/rshc" target="_blank" rel="external">rhsc</a>。</p>
<p>目前我这个程序只是能把脚本程序，转换为 Rust 代码，然后使用 rustc 来编译为二进制，为了做一些代码混淆，其中也类似 shc 使用了 RC4 算法来做了一个简单的转换，加密用的 key 是随机生成的。然后也做了另外一个增加密码的模式，这样可以为任何脚本增加密码校验功能，最终使用 <a href="https://doc.rust-lang.org/beta/std/process/struct.Command.html" target="_blank" rel="external">Process</a> 来执行解释器。当然也谈不上多安全，如果要破解可以使用一些类似 ptrace 或者<a href="https://github.com/neurobin/shc/issues/63" target="_blank" rel="external">其他方式</a>来试试。以后我会继续完善这方面的防御。另外，为了在生成代码之后尽量减少依赖，所以目前密码输入时还未做到隐藏输入。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>使用方式非常简单，先安装：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">cargo install rshc</div></pre></td></tr></table></figure>
<p>然后使用命令： </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rshc -f demo.sh -o demo.rs</div><div class="line"></div><div class="line">/<span class="regexp">/ add a passowrd when compile it, </span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ then binary will prompt for correct password before execution</span></div><div class="line"><span class="regexp">rshc -f demo.sh -o demo.rs -p</span></div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>时隔两年再用 Rust 写一些小项目，发现整个语言还是成熟很多：</p>
<ul>
<li>工具链很好用，特别是 cargo 之类的，<a href="https://crates.io/crates/rshc" target="_blank" rel="external">从开发到发布都非常方便</a></li>
<li>相关的库和文档也多了起来，相对来说更加容易上手写一些东西了</li>
<li>编译器的错误提示特别好，可以通过错误索引号找到示例</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h3&gt;&lt;p&gt;因为自己习惯使用 expect 脚本登录各种服务器，有一段时间因为要登录的服务器太多了，所以之前写过一个程序来管理各种 expect 脚本。
    
    </summary>
    
    
      <category term="Rust" scheme="http://cyukang.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>SQL Injection attack</title>
    <link href="http://cyukang.com/2018/03/10/sql-injection-attack.html"/>
    <id>http://cyukang.com/2018/03/10/sql-injection-attack.html</id>
    <published>2018-03-10T12:51:40.000Z</published>
    <updated>2018-03-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h3><p>SQL注入一直是 Web 应用的一大安全隐患，注入的基本原理是通过修改输入的参数来操作后台执行的 SQL，注入可能会导致数据库被恶意修改、数据被恶意读取等严重行为。所以如果一个参数有漏洞，通过小心的构造注入点即可利用，这里的<a href="https://paper.seebug.org/15/" target="_blank" rel="external">渗透攻防Web篇-SQL注入攻击初级</a>有一些编写注入点的教程。</p>
<p>最初的时候我在一个用 C 写后台的项目里待过，现在回想起来我们当时根本没注意SQL 注入，C 拼接处 SQL 的字符串很常见。不过现在大多数 Web 框架都已经有 ORM 了，ORM 可以在很大程度上避免注入的产生，因为程序员通常来说不用写纯的 SQL 了， 在最佳实践的前提下 ORM 会生成安全的 SQL。当然什么工具最终还是依赖程序员，比如下面的 Ruby 代码即会有问题: </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">User.where(<span class="string">"email = <span class="subst">#&#123;params[<span class="symbol">:email</span>]&#125;</span>"</span>).first</div></pre></td></tr></table></figure>
<p>更多作死的办法可以参考： <a href="https://rails-sqli.org/" target="_blank" rel="external">https://rails-sqli.org/</a></p>
<h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>通常我们会使用一些 WAF 来阻挡 一些SQL 注入，但是 WAF 也有其局限性。WAF 一般是通用的，不会局限于某个特定的框架。我们可以实现在 Nginx 上，或者使用一些商用的 WAF，通常来说对于应用也不用修改其代码。不过 WAF 的问题在于其实基于规则的，而 SQL 本省是比较复杂的，可以看看<a href="https://github.com/ronsavage/SQL/blob/master/sql-2003-2.bnf" target="_blank" rel="external">2003 SQL BNF</a> 的描述有多么的长。所以 WAF 的规则大多数是一大堆较难维护的正则表达式，比如： <a href="https://github.com/unixhot/waf/blob/master/waf/rule-config/args.rule" target="_blank" rel="external">Nginx Waf示例</a>，注意这个项目用不太成熟，初步看会有比较严重的<a href="https://github.com/unixhot/waf/issues/12" target="_blank" rel="external">性能问题</a>。正因为规则是固定的，会导致存在很多误拦截的情况，所以我在 Kong 上实现的 WAF 就还不敢用起来。例如现实情况中出现过<a href="https://store.dji.com/select" target="_blank" rel="external">包含select的 uri</a>被拦的情况，一脸忧伤。</p>
<h3 id="静态代码扫描"><a href="#静态代码扫描" class="headerlink" title="静态代码扫描"></a>静态代码扫描</h3><p>静态代码扫描会发现一些 SQL 注入，比如  Brakeman 之类的。不过通常静态代码扫描的问题也是分析得不够精准，会漏报、也会出现误报比较多，扫描的结果需要进行人工审计。当然这些工具也在逐步改进。</p>
<h3 id="RASP-工具"><a href="#RASP-工具" class="headerlink" title="RASP 工具"></a>RASP 工具</h3><p>RASP 的意思是<a href="https://www.veracode.com/security/runtime-application-self-protection-rasp" target="_blank" rel="external">Runtime Application Self Protection</a>，这个概念近些年才提出，目前已经有一些安全公司做出了对应的产品，比如<a href="http://www.sqreen.io" target="_blank" rel="external">Sqreen</a>, 百度最近也新开一个开源项目叫做<a href="https://github.com/baidu/openrasp" target="_blank" rel="external">OpenRASP</a>，目前来说只支持 Java，开发者可以自己使用 Javascript 编写自己的插件。RASP 除了自己的规则还会依据请求时候的上下文来进行分析，这篇文章里有<a href="https://blog.sqreen.io/block-sql-injections-not-customers/" target="_blank" rel="external">一些描述</a>，这样误报的问题会大大减少。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;注入原理&quot;&gt;&lt;a href=&quot;#注入原理&quot; class=&quot;headerlink&quot; title=&quot;注入原理&quot;&gt;&lt;/a&gt;注入原理&lt;/h3&gt;&lt;p&gt;SQL注入一直是 Web 应用的一大安全隐患，注入的基本原理是通过修改输入的参数来操作后台执行的 SQL，注入可能会导致数据
    
    </summary>
    
    
      <category term="security" scheme="http://cyukang.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Kong集群Left Cluster Node问题</title>
    <link href="http://cyukang.com/2018/03/04/kong-cluster-left-node.html"/>
    <id>http://cyukang.com/2018/03/04/kong-cluster-left-node.html</id>
    <published>2018-03-04T03:02:32.000Z</published>
    <updated>2018-03-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Kong在实践中会有一些疑惑的地方，这里记录一下。注意这里记录的Kong集群部署的问题是0.10.3版本的，最新Kong版本已经不是通过serf来管理不同节点之间的配置同步问题。</p>
<p>在Kong多节点部署的时候，有时候某个节点停掉后，我们在后台可以看到left的信息，而且这个left信息会保留一段不短的时间。类似于如下： </p>
<p><img src="/images/kong-left-0133521.png" alt="kong-left"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>管理后台Konga是通过api获取的节点信息，在<code>kong/kong/api/routes/cluster.lua</code>文件里可以看到如下路由处理逻辑： </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">GET = <span class="function"><span class="keyword">function</span><span class="params">(self, dao_factory, helpers)</span></span></div><div class="line">  <span class="keyword">local</span> members, err = singletons.serf:members()</div><div class="line">  <span class="keyword">if</span> err <span class="keyword">then</span></div><div class="line">    <span class="keyword">return</span> responses.send_HTTP_INTERNAL_SERVER_ERROR(err)</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="keyword">local</span> result = &#123;data = &#123;&#125;&#125;</div><div class="line">  <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(members) <span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.params.<span class="built_in">status</span> <span class="keyword">or</span> (self.params.<span class="built_in">status</span> <span class="keyword">and</span> v.<span class="built_in">status</span> == self.params.<span class="built_in">status</span>) <span class="keyword">then</span></div><div class="line">      table_insert(result.data, &#123;</div><div class="line">        name = v.name,</div><div class="line">        address = v.addr,</div><div class="line">        <span class="built_in">status</span> = v.<span class="built_in">status</span></div><div class="line">      &#125;)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  result.total = #result.data</div><div class="line">  <span class="keyword">return</span> responses.send_HTTP_OK(result)</div><div class="line"><span class="keyword">end</span>,</div></pre></td></tr></table></figure>
<p>具体<code>serf:members()</code>的实现在serf.lua里面可以看到，就是执行了<code>serf cluster members</code>命令获取结果然后返回JSON。所以我们在服务器上执行这个命令其实也可以看到类似的结果： </p>
<p><img src="/images/kong-left-cmd.png" alt="kong-left-cmd"></p>
<p>那么问题的根源当然是在Serf本身里面，通过看文档发现原来确实是有一定延迟的。</p>
<blockquote>
<p>Serf keeps the state of dead nodes around for a set amount of time, so that when full syncs are requested, the requester also receives information about dead nodes. Because SWIM doesn’t do full syncs, SWIM deletes dead node state immediately upon learning that the node is dead. This change again helps the cluster converge more quickly.</p>
<p><a href="https://www.serf.io/docs/internals/gossip.html#lifeguard-enhancements" target="_blank" rel="external">参考serf文档»</a></p>
</blockquote>
<h4 id="serf的具体实现"><a href="#serf的具体实现" class="headerlink" title="serf的具体实现"></a>serf的具体实现</h4><p>接着稍微看了一下Serf的代码，果然Go的项目代码直观好读。在Serf这个结构体里面保存了一个leftMembers的状态列表，每次收到left事件的时候处理逻辑是： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// handleNodeLeaveIntent is called when an intent to leave is received.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Serf)</span> <span class="title">handleNodeLeaveIntent</span><span class="params">(leaveMsg *messageLeave)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	..................</div><div class="line">    </div><div class="line">	<span class="comment">// State transition depends on current state</span></div><div class="line">	<span class="keyword">switch</span> member.Status &#123;</div><div class="line">	<span class="keyword">case</span> StatusAlive:</div><div class="line">		member.Status = StatusLeaving</div><div class="line">		member.statusLTime = leaveMsg.LTime</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	<span class="keyword">case</span> StatusFailed:</div><div class="line">		member.Status = StatusLeft</div><div class="line">		member.statusLTime = leaveMsg.LTime</div><div class="line"></div><div class="line">		<span class="comment">// Remove from the failed list and add to the left list. We add</span></div><div class="line">		<span class="comment">// to the left list so that when we do a sync, other nodes will</span></div><div class="line">		<span class="comment">// remove it from their failed list.</span></div><div class="line">		s.failedMembers = removeOldMember(s.failedMembers, member.Name)</div><div class="line">		s.leftMembers = <span class="built_in">append</span>(s.leftMembers, member)</div><div class="line">        </div><div class="line">        ................</div><div class="line">        </div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过索引变量发现这个列表会定时通过<code>handleReap</code>函数更新，逻辑如下： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// handleReap periodically reaps the list of failed and left members, as well</span></div><div class="line"><span class="comment">// as old buffered intents.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Serf)</span> <span class="title">handleReap</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-time.After(s.config.ReapInterval):</div><div class="line">			s.memberLock.Lock()</div><div class="line">			now := time.Now()</div><div class="line">			s.failedMembers = s.reap(s.failedMembers, now, s.config.ReconnectTimeout)</div><div class="line">			s.leftMembers = s.reap(s.leftMembers, now, s.config.TombstoneTimeout)</div><div class="line">			reapIntents(s.recentIntents, now, s.config.RecentIntentTimeout)</div><div class="line">			s.memberLock.Unlock()</div><div class="line">		<span class="keyword">case</span> &lt;-s.shutdownCh:</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以看起来这里相关的Timeout是<code>s.config.TombstoneTimeout</code>, 接着需要看看<code>reap</code>到底做了什么，这里果然是把到了一定时间间隔的节点删掉了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// reap is called with a list of old members and a timeout, and removes</span></div><div class="line"><span class="comment">// members that have exceeded the timeout. The members are removed from</span></div><div class="line"><span class="comment">// both the old list and the members itself. Locking is left to the caller.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Serf)</span> <span class="title">reap</span><span class="params">(old []*memberState, now time.Time, timeout time.Duration)</span> []*<span class="title">memberState</span></span> &#123;</div><div class="line">	n := <span class="built_in">len</span>(old)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</div><div class="line">		m := old[i]</div><div class="line"></div><div class="line">		<span class="comment">// Skip if the timeout is not yet reached</span></div><div class="line">		<span class="keyword">if</span> now.Sub(m.leaveTime) &lt;= timeout &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Delete from the list</span></div><div class="line">		old[i], old[n<span class="number">-1</span>] = old[n<span class="number">-1</span>], <span class="literal">nil</span></div><div class="line">		old = old[:n<span class="number">-1</span>]</div><div class="line">		n--</div><div class="line">		i--</div><div class="line"></div><div class="line">		..........</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> old</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这个时间间隔是多久呢，在<code>serf/config.go</code>有一个默认配置： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">TombstoneTimeout:             <span class="number">24</span> * time.Hour,</div></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>serf这个软件值得好好分析一下，节点的状态同步和事件处理都是分布式软件的基础，后续继续看看这个<code>gossip protocol based on SWIM</code>的具体实现。另外<a href="https://www.hashicorp.com/" target="_blank" rel="external">hashicorp</a>这个公司的开源代码和文档都非常好，值得学习一番。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;Kong在实践中会有一些疑惑的地方，这里记录一下。注意这里记录的Kong集群部署的问题是0.10.3版本的，最新Kong版本已经不是通过se
    
    </summary>
    
    
      <category term="Tools" scheme="http://cyukang.com/tags/Tools/"/>
    
      <category term="Kong" scheme="http://cyukang.com/tags/Kong/"/>
    
      <category term="Golang" scheme="http://cyukang.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Docker compose初始化失败问题</title>
    <link href="http://cyukang.com/2018/03/02/docker-postgres-password.html"/>
    <id>http://cyukang.com/2018/03/02/docker-postgres-password.html</id>
    <published>2018-03-02T15:17:35.000Z</published>
    <updated>2018-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>今天在Docker Postgresql用户名和密码授权的问题上花了一些时间，问题是： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">psql: FATAL:  password authentication failed for user "postgres"</div></pre></td></tr></table></figure>
<p>admin的用户名和密码是可以在docker-compose.yml里设置的，通常我们可以配置为： </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">postgresql:</span></div><div class="line"><span class="attr">  image:</span> <span class="attr">postgres:latest</span></div><div class="line"><span class="attr">  ports:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">"5434:5432"</span></div><div class="line"><span class="attr">  volumes:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">./data/pgsql:/var/lib/postgresql/data</span></div><div class="line"><span class="bullet">    -</span> <span class="string">./initialize/pgsql:/docker-entrypoint-initdb.d</span></div><div class="line"><span class="attr">  environment:</span></div><div class="line"><span class="attr">    POSTGRES_USER:</span> <span class="string">postgres</span></div><div class="line"><span class="attr">    POSTGRES_DB:</span> <span class="string">postgres</span></div><div class="line"><span class="attr">  secrets:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">pg_superuser_password</span></div></pre></td></tr></table></figure>
<p>某个用户的密码可以在<code>./initialize/pgsql</code>目录的脚本里设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">set -e</div><div class="line"></div><div class="line">psql -v ON_ERROR_STOP=1 --username "postgres" &lt;&lt;-EOSQL</div><div class="line">	CREATE USER user WITH PASSWORD 'the-password';</div><div class="line">	ALTER USER user CREATEDB;</div><div class="line">EOSQL</div></pre></td></tr></table></figure>
<p>只是今天碰巧想修改一下这个密码，所以就把这个脚本里的密码修改了，然后执行命令： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">docker-compose up --build -d --force-recreate</div></pre></td></tr></table></figure>
<p>而后就一直出现上面的用户授权失败。</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>刚开始一直认为是可能dockerfile配置得不对，结果花费了些时间。后来突然想到了，PG里数据初始化应该只是第一次做了，后续如果发现<code>/var/lib/postgresql/data</code>里已经有数据了就再也不会重新设置密码，这里是配置volume的，如果还未有重要数据把<code>./data/pgsql</code>删除了即可，或者应该是可以通过attach进入容器通过pg命令修改。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最近在自己工作的项目都完全Docker化，感觉是配置来折腾用起来飞。最近也在做一个重度依赖Docker的项目，所以Docker的文档需要看完，特别是网络和数据存储那块，否则会花费不少时间折腾。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;今天在Docker Postgresql用户名和密码授权的问题上花了一些时间，问题是： &lt;/p&gt;
&lt;figure class=&quot;highli
    
    </summary>
    
    
      <category term="Tools" scheme="http://cyukang.com/tags/Tools/"/>
    
      <category term="Docker" scheme="http://cyukang.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用overcommit生成git hooks</title>
    <link href="http://cyukang.com/2018/02/26/overcommit.html"/>
    <id>http://cyukang.com/2018/02/26/overcommit.html</id>
    <published>2018-02-26T11:02:14.000Z</published>
    <updated>2018-02-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>git hooks</code>很方便地可以在git操作流程的各个阶段加入hooks，比如执行一些脚本来检查代码风格、跑单元测试、做代码静态检查等。git hooks的试用方法是在.git/hooks目录下写各种脚本，但是.git目录的这些脚本是不会checkin到repo里的，所以如果一个代码如果被多个开发人员共享就会显得不太方便同步hooks。</p>
<p><a href="https://stackoverflow.com/questions/427207/can-git-hook-scripts-be-managed-along-with-the-repository" target="_blank" rel="external">当然也有一些其他方法来解决这个问题</a>，比如配置links或者对于<code>git 2.9</code>以后也可以使用来定制hooks的目录:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">git config core.hooksPath hooks</div></pre></td></tr></table></figure>
<p>对于熟悉Ruby的同学可以使用<a href="https://github.com/brigade/overcommit" target="_blank" rel="external">overcommit</a>这个gem来解决。使用方法就是通过配置<code>.overcommit.yml</code>，比如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">PreCommit:</span></div><div class="line"><span class="attr">  RuboCop:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    command:</span> <span class="string">['bundle',</span> <span class="string">'exec'</span><span class="string">,</span> <span class="string">'rubocop'</span><span class="string">]</span> <span class="comment">#  The shell command should run</span></div><div class="line"></div><div class="line"><span class="attr">  AuthorName:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>然后执行命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">overcommit install</div></pre></td></tr></table></figure>
<p>来自动生成各种hooks，通常后面的修改都是修改这个yaml文件即可，不过记得修改后需要<code>overcommit --signed</code>来重新生成hooks。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git hooks&lt;/code&gt;很方便地可以在git操作流程的各个阶段加入hooks，比如执行一些脚本来检查代码风格、跑单元测试、做代码静态检查等。git hooks的试用方法是在.git/hooks目录下写各种脚本，但是.git目录的这些脚本是不会checki
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx https too many redirect</title>
    <link href="http://cyukang.com/2018/02/23/nginx-https-too-many-redirect.html"/>
    <id>http://cyukang.com/2018/02/23/nginx-https-too-many-redirect.html</id>
    <published>2018-02-23T09:38:44.000Z</published>
    <updated>2018-02-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Http请求在经过多层Nginx的时候，通常强制http跳转到https的时候会这样配置: </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">return</span> <span class="number">302</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>; </div><div class="line"><span class="comment">## 需要注意这里是request_uri而不是uri，否则会引起安全问题</span></div></pre></td></tr></table></figure>
<p>但是如果是多层Nginx，前面的Nginx需要把用户原始请求的scheme传递到后端，可以加上头部设置： </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</div></pre></td></tr></table></figure>
<p>后面的Nginx再判断一次:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">if</span> ( <span class="variable">$http_x_forwarded_proto</span> != <span class="string">'https'</span> ) &#123;</div><div class="line">  <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>否则强制https经常会出现类似<code>ERR_TOO_MANY_REDIRECTS 将您重定向的次数过多</code>这样的问题。</p>
<p>可是在实践过程中偶尔也碰到过一些ELB会丢掉scheme的问题，比如在这样的请求链路情况下<code>elb =&gt; nginx =&gt; nginx =&gt; application</code>第二层Nginx获取的scheme就有问题了，这也可能会导致<code>too many redirects</code>问题。</p>
<p>可以尝试在第二层Nginx上这样解决： </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">proxy_set_header</span>   X-Forwarded-Proto <span class="variable">$http_x_forwarded_proto</span>;</div></pre></td></tr></table></figure>
<p>当然强制https这样的跳转逻辑尽量放在请求链路的最外层，这样问题会少一些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Http请求在经过多层Nginx的时候，通常强制http跳转到https的时候会这样配置: &lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;sp
    
    </summary>
    
    
      <category term="Nginx" scheme="http://cyukang.com/tags/Nginx/"/>
    
  </entry>
  
</feed>
