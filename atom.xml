<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyukang.github.io/"/>
  <updated>2021-12-23T15:36:06.694Z</updated>
  <id>http://chenyukang.github.io/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编译 WebAssembly 模块</title>
    <link href="http://chenyukang.github.io/2021/12/16/compiling-to-wasm.html"/>
    <id>http://chenyukang.github.io/2021/12/16/compiling-to-wasm.html</id>
    <published>2021-12-16T07:02:23.000Z</published>
    <updated>2021-12-23T15:36:06.694Z</updated>
    
    <content type="html"><![CDATA[<p>最近一年经常接触了 WebAssembly , 我把一些老的 C/C++ 代码通过 <a href="https://emscripten.org/docs/getting_started/downloads.html" target="_blank" rel="noopener">emcc</a> 编译为 wasm 模块，也可以把 Rust 代码编译为 wasm。</p><p>这里做一个简单的总结，以及我在编译过程中碰到的问题。</p><h2 id="WebAssembly-的优势"><a href="#WebAssembly-的优势" class="headerlink" title="WebAssembly 的优势"></a>WebAssembly 的优势</h2><p><img src="/images/ob_pasted-image-20211215191320.png" alt="/images/ob_pasted-image-20211215191320.png"></p><p>WebAsembly 定义了一个<a href="https://www.wasm.com.cn/docs/portability/" target="_blank" rel="noopener">可移植</a>、体积小、加载快的<a href="https://www.wasm.com.cn/docs/mvp/#binary-format" target="_blank" rel="noopener">二进制格式</a>作为编译结果。通过充分发挥通用硬件的能力（包括<a href="https://en.wikipedia.org/wiki/Mobile_device" target="_blank" rel="noopener">移动设备</a>以及<a href="https://en.wikipedia.org/wiki/Internet_of_Things" target="_blank" rel="noopener">物联网</a>），使其在大多数平台上能达到原生的执行效率。借助 wasi，WebAssembly 还可能运行在服务端。WebAssembly 的目标包括：</p><ol><li>现有的 <a href="https://www.wasm.com.cn/docs/web/" target="_blank" rel="noopener">Web 平台</a>完美结合并在其中运行：<ul><li>维护无版本、<a href="https://www.wasm.com.cn/docs/feature-test/" target="_blank" rel="noopener">特性可测试</a>、向后兼容的 Web 演变过程；</li><li>和 JavaScript 执行在相同的语意环境中；</li><li>允许和 JavaScript 相互的同步调用；</li><li>严格遵守同源策略以及浏览器安全策略；</li><li>和 JavaScript 一样，可以访问相同的 Web API 去调用浏览器的功能；以及</li><li>定义一个可与二进制格式相互转化的人类可编辑的文本格式，并且支持查看源码的功能。</li></ul></li><li>被设计为也可以支持<a href="https://www.wasm.com.cn/docs/non-web/" target="_blank" rel="noopener">非浏览器嵌入</a>的运行形式，这样就可能在某些场景下替代 Docker。</li></ol><h2 id="C-C-gt-wasm"><a href="#C-C-gt-wasm" class="headerlink" title="C/C++ =&gt; wasm"></a>C/C++ =&gt; wasm</h2><p>首先需要安装 Emscripten  SDK:<br><a href="https://emscripten.org/docs/getting_started/downloads.html" target="_blank" rel="noopener">https://emscripten.org/docs/getting_started/downloads.html</a></p><p>移植一个 C/C++ 项目到 WebAssembly , 最简单的办法是把类似 gcc 命令换成 emcc，难点在于动态链接的第三方库，我们需要改成静态链接。一些常用的库已经被移植了，例如<em>libc</em>, <em>libc++</em> and <em>SDL</em>，这些我们不需要手动处理。不在 emcc 预装里的库，我们只需要在编译的过程中加一些额外的参数，例如我下面这个项目就用到了 PNG，JPEG 这些库：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">emcc -c dbgutil.c -o dbgutil.o</span><br><span class="line">emcc -c qrtest.c -o qrtest.o</span><br><span class="line">emcc -c decode.c -o decode.o</span><br><span class="line">emcc -c identify.c -o identify.o</span><br><span class="line">emcc -c quirc.c -o quirc.o</span><br><span class="line">emcc -c version_db.c -o version_db.o</span><br><span class="line">emcc -g -Oz --llvm-lto 1  -s STANDALONE_WASM *.o -o qrtest.wasm  -lm  -s USE_LIBJPEG -s USE_LIBPNG</span><br></pre></td></tr></table></figure><p>另外 emcc 编译出来的 wasm 模块默认只能做纯计算，没有网络、系统文件等。如果有系统调用则需要运行在浏览器中，用浏览器的接口来模拟某些 C 函数调用，例如 C 语言中的系统调用 <code>time</code> 在 emcc 中被替成为了 JavaScript  代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">clock: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_clock.start === <span class="literal">undefined</span>) _clock.start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">Date</span>.now() - _clock.start) * (&#123;&#123;&#123; cDefine(<span class="string">'CLOCKS_PER_SEC'</span>) &#125;&#125;&#125; / <span class="number">1000</span>))|<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Rust-gt-wasm"><a href="#Rust-gt-wasm" class="headerlink" title="Rust =&gt; wasm"></a>Rust =&gt; wasm</h2><p>Rust 是对 WebAssembly  支持得特别好的编程语言。我们可以使用 wasm-pack，或者安装 target:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustup target add wasm32-wasi</span><br></pre></td></tr></table></figure><p>然后在编译命令后面加参数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo build --target wasm32-wasi</span><br></pre></td></tr></table></figure></p><p>系统函数同样是个问题，有的第三方库可能会支持 wasm 格式，例如<a href="https://docs.rs/getrandom/latest/getrandom/#webassembly-support" target="_blank" rel="noopener">getrandom - Rust (docs.rs)</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://emscripten.org/" target="_blank" rel="noopener">Main — Emscripten 3.0.1-git (dev) documentation</a><br><a href="https://marcoselvatici.github.io/WASM_tutorial/" target="_blank" rel="noopener">WASM Tutorial (marcoselvatici.github.io)</a><br><a href="https://rustwasm.github.io/docs/book/" target="_blank" rel="noopener">Introduction - Rust and WebAssembly (rustwasm.github.io)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一年经常接触了 WebAssembly , 我把一些老的 C/C++ 代码通过 &lt;a href=&quot;https://emscripten.org/docs/getting_started/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="WebAssembly" scheme="http://chenyukang.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>为什么要开源</title>
    <link href="http://chenyukang.github.io/2021/12/14/why-open-source.html"/>
    <id>http://chenyukang.github.io/2021/12/14/why-open-source.html</id>
    <published>2021-12-14T07:02:45.000Z</published>
    <updated>2021-12-23T15:36:06.698Z</updated>
    
    <content type="html"><![CDATA[<p>我 2010 年开始在 Github 上开源自己的代码。在 push 代码之前我根本没想过为什么。只是因我当时学了 git，而且我又觉得 Github 很方便，可以用来备份自己的代码。</p><p>而后我就参加工作了，在工作之余我还会写一些感兴趣的代码分享到 Github，没事也经常在上面瞎逛，找一些自己感兴趣的代码来学习。我自己写的博客后来现在都托管在 Github 上了。</p><p>没想到这么多年下来，在 Github 上玩开源已经成为自己的一种习惯、爱好和生活方式。近一年工作轻松些了，有更多时间投入在这上面 (忽略最近两个月的大量提交数据，因为有个自动脚本在同步笔记等等 😁)<br><img src="/images/ob_pasted-image-20211213171045.png" alt="/images/ob_pasted-image-20211213171045.png"><br>最近越发觉得，和这个世界交互、分享越多，就会有更多的可能性。这里分享一下开源的收获和感受。这里仅从开发者角度考虑这个问题，因为公司是否考虑是另外一个更复杂的事。</p><h2 id="自我提高"><a href="#自我提高" class="headerlink" title="自我提高"></a>自我提高</h2><p>分享是为了自我提高。</p><p>我建议任何在学编程的人参与到开源活动中来。现在的软件开发已经过了刀耕火种、徒手编码的年代，软件开发需要复用大量已有的库和工具，大型软件开发是一种社会化的、集体性的智慧活动。在 Github 上分享代码，给其他开源项目做贡献，是最好的一种方式来练习这种编程能力、协作能力和复用已有代码的能力。在 Github 上混久了，就形成一种自然而然的<a href="https://github.com/chenyukang" target="_blank" rel="noopener">做贡献的习惯</a>，在这里我们不只是使用者，也可以是创作者。</p><ul><li>我想学学 WebAssembly，所以找来一个 runtime 实现看看，顺便修复一些自己发现的<a href="https://github.com/wasmerio/wasmer/pulls?q=is%3Apr+is%3Aclosed+author%3Achenyukang" target="_blank" rel="noopener">问题</a>。</li><li>看到这个 Obsdian 插件有些缺陷，自己修一把然后和作者讨论一下<a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/issues/30" target="_blank" rel="noopener">怎么完善</a>。</li><li>在使用 Rust 的时候，看到了一个重复的警告，在 Github 上一搜索发现别人也碰到过，提一个 <a href="https://github.com/rust-lang/rust/pull/88493" target="_blank" rel="noopener">PR 修复一把</a>。</li><li>我想看看 container 是怎么实现的，所以找来开源代码 <a href="https://github.com/containers/youki" target="_blank" rel="noopener">containers/youki</a> 看看，然后顺便修复自己<a href="https://github.com/containers/youki/pulls?q=is%3Apr+author%3Achenyukang+is%3Aclosed" target="_blank" rel="noopener">发现的问题</a>，后来还成了 maintainer。</li></ul><p>在这个过程中我自己学到了很多，为开源做贡献属于<a href="https://wsvincent.com/working-in-public-book-review/" target="_blank" rel="noopener">Working in Public</a>，也是<a href="https://www.swyx.io/learn-in-public/" target="_blank" rel="noopener">Learn in Public</a>。强烈推荐这篇 Learn in  Public 的文章，这是一个改变了我的观念。Working in Public 的好处在于我们做的贡献可以算作能力的证明，参考刘未鹏十年前的<a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/" target="_blank" rel="noopener">怎样花两年时间去面试一个人 – 刘未鹏 | Mind Hacks</a>。这些年我换工作就碰到过认可我的代码，面试就是聊聊的公司。</p><h2 id="创造价值"><a href="#创造价值" class="headerlink" title="创造价值"></a>创造价值</h2><p>绝大多数代码不值钱。写代码的时候内心戏不要太多，自己几斤几两要有个数。纯代码不值钱，业务才能赚钱，所以代码得运行起来。如果分享出来的代码对别人有用，就能产生价值，产生价值就附带可以赚钱。</p><p>举个例子，我在自己看书《Enssential of Programming Language》的时候，一边学习一边把课后习题用代码实现了，<a href="https://github.com/chenyukang/eopl" target="_blank" rel="noopener">chenyukang/eopl: my solutions to EOPL3 </a>。</p><p>这个代码如果一直留在我硬盘的某个角落，估计就是分文不值。我总不能把它当作传家宝留给我的后代。但是开源之后居然每年都会收到一些邮件咨询这方面的问题。因为这本书是国外一些大学的教材，他们学编程语言相关的课程就需要做这些编程题，还有一些课后项目。</p><p>所以，有的同学就付费让我咨询。对于我来说，我当然愿意，一个小时能赚 2000 左右这不比上班划算么。嗯，大学能出国的人有的还挺有钱。</p><p>当自己的成果帮助了其他人时，也能收获一些满足：<br><img src="/images/ob_pasted-image-20211213144005.png" alt="/images/ob_pasted-image-20211213144005.png"></p><p>另外一个例子，我分享了自己在学习数据结构和算法时实现的一个生成迷宫程序，然后还写了一些 A* 算法相关的文章。后来上海大学有个教授看到我的文章，问我能不能帮他们看个程序，他们需要在 1w 多个节点里面计算 k-th shortest 路径。我花了一些业余时间帮他们把核心算法用 C 实现了，他们后来把文章发表了出来，还把我的名字署上了。<a href="https://pubs.rsc.org/en/content/articlelanding/2013/mb/c3mb70089e#!divRelatedContent&amp;articles" target="_blank" rel="noopener">Identification of hepatocellular carcinoma related genes with k-th shortest paths in a protein–protein interaction network - Molecular BioSystems (RSC Publishing)</a>。我可从来没想过自己会发表一篇分子生物类的文章。</p><p>这就是分享的奇妙之处，你不知道自己的分享什么时候就帮助了别人，创造了价值。</p><p>这些如今牛逼的开源项目都是从最开始一个小的分享举动开始的，Linus 在分享自己的小 Kernel 时估计并未曾想过整个操作系统行业被自己改变了，尤大在分享自己的前端成功时也未料到过 Vue 发展成这样。</p><p>最后，很推荐这两期播客 : <a href="https://avocadotoast.typlog.io/episodes/opensource" target="_blank" rel="noopener">和Vue.js的创造者尤雨溪聊开源软件 - 牛油果烤面包</a>。另外可以听听这期<a href="https://bytetalk.fm/posts/episode-6/" target="_blank" rel="noopener">跟 Anthony Fu 聊聊全职开源和他的故事</a>，有些开发者已经实现了全职做开源这种工作形态。</p><p>而且现在国内开始出现了一波用开源软件赚钱的公司，比如 Pingcap，TDengnine 等。这是个很好的趋势，让我们这些本身喜欢写代码的除了 996 有了更多选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我 2010 年开始在 Github 上开源自己的代码。在 push 代码之前我根本没想过为什么。只是因我当时学了 git，而且我又觉得 Github 很方便，可以用来备份自己的代码。&lt;/p&gt;
&lt;p&gt;而后我就参加工作了，在工作之余我还会写一些感兴趣的代码分享到 Github
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="OpenSource" scheme="http://chenyukang.github.io/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>为什么印度人占领了硅谷</title>
    <link href="http://chenyukang.github.io/2021/12/12/why-indian-lead-silicon-valley.html"/>
    <id>http://chenyukang.github.io/2021/12/12/why-indian-lead-silicon-valley.html</id>
    <published>2021-12-12T07:02:34.000Z</published>
    <updated>2021-12-23T15:36:06.698Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间 Twitter 也换了 CEO，还是一个印度裔。目前，硅谷的很多大的 IT 公司的 CEO 位置都被印度裔占了，包括 Google，Microsoft，IBM，Adobe, Palo Alto Network , VMWare 等老牌 IT 巨头。这种现象逐渐成为人们讨论的 <a href="https://www.bbc.com/news/world-asia-india-59457015" target="_blank" rel="noopener">The Indian CEO Phenomenon</a>。</p><p>从我个人的经历来说，我毕业后工作的第一家公司当时是被一个硅谷的印度人公司收购，目前工作的微软也是印度裔 CEO。</p><p>对于这个现象，个人认为原因有这些：</p><h3 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h3><p>很多印度裔技术人员早年都在印度上完大学。因为印度有种姓制度，社会阶层明显。能在印度上大学的大多家庭条件和阶层还不算太差，我 2015 年在硅谷出差，有段时间经常蹭印度同事的车，他说自己跑到美国后更累了，因为在印度家里有好几个佣人😃。</p><p>印度的 STEM 氛围比较重，工程师算得上是一个受人尊重的职位。看过《三傻大闹宝莱坞》的可能对此有些印象。从目前印度的高考情况来看，最热门的科目也是理工科，入学门槛是最高的学科。像印度理工学院这种，录取率不到 2%，入学难度堪比麻省理工。在一个好的理工学校毕业，然后去美国赚钱，这对于很多印度人来说是非常理想的出路。并且因为本土发展机会不如中国多，印度回流的更少，在美国扎根对他们来说是更理想的选择。</p><p>因此，我们看到的去美国的印度工程师，其实也和中国类似，经过了好几轮教育体制的筛选，智力、学习能力都是不输中国人的。</p><p>并且印度人喜欢上商业类的双学位课程，很多人除了技术方面的学历证书，还有 MBA 之类的商业方面的学位。当大部分都是技术上出众的时候，那么同时具备商业嗅觉和宏观判断力的人就容易突出。Google CEO 的 Sundar Pichai ，当年作为 PM 领导了 Google Chrome ，Google Drive 等明星产品。微软的 Satya 上台后让微软这个已经落寞多年的昔日巨头重新回到世界前列。</p><h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><p>在一个公司能做事固然很重要，但如果要走向管理岗，不太表达可是个大问题。</p><p>在 IT 行业工作的印度程序员，基本都能很流利地用英语表达。日常搜索中我们经常碰到的 geekforgeeks 这种网站很多都是印度人做的。</p><p>很多印度人说出来的口语口音很重（部分阶层更高的印度人从小接受英语教育，所以口音更纯正一些）。典型的印度口音就像是这个 <a href="https://www.youtube.com/watch?v=_IOZ8_cPgu8" target="_blank" rel="noopener">视频</a> 里一样。但是这不是一个大问题，欧洲的、俄罗斯的、世界各地的非英语母语国家的人说英语都是由口音的。对于母语是英语的听众来说，有口音大多不影响理解。而中国的技术人员，很多是应试教育的受害者，高考后荒废几年，很多人英语阅读都成问题，更不用说开口说话。这种现象在我这个年龄段 (80 后）中还比较突出，90、00 后相对来说口语会好一些。 </p><p>东方文化中推崇“凡事不做出头鸟”，中国人工程师大多比含蓄和谦虚，自己做了 120 分可能才敢说出 100 分，而且在很多公司公共事务上成为”沉默的大多数“。这对于美国人是比较陌生的，美国人沟通倾向于直接明了和强势。</p><h3 id="团结"><a href="#团结" class="headerlink" title="团结"></a>团结</h3><p>传说“公司来了一个印度人，接下来会有另外一个，过段时间就是一群”。硅谷的印度人对自己族裔的相互提携，这是事实。</p><p>中国这边过去的大多是千军万马独木桥走过的做题家，文人相轻自古以来都有。攀比、嫉妒等造成了很大内耗。这种来自传统的内心观念、精神糟粕很难克服，需要自己从一种第三方视角反思、不断实践才行。</p><hr><p>以上纯是个人感受。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间 Twitter 也换了 CEO，还是一个印度裔。目前，硅谷的很多大的 IT 公司的 CEO 位置都被印度裔占了，包括 Google，Microsoft，IBM，Adobe, Palo Alto Network , VMWare 等老牌 IT 巨头。这种现象逐渐成为
      
    
    </summary>
    
    
      <category term="瞎写" scheme="http://chenyukang.github.io/tags/%E7%9E%8E%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>什么是好的技术面试</title>
    <link href="http://chenyukang.github.io/2021/12/08/the-good-tech-interview.html"/>
    <id>http://chenyukang.github.io/2021/12/08/the-good-tech-interview.html</id>
    <published>2021-12-08T09:11:49.000Z</published>
    <updated>2021-12-23T15:36:06.698Z</updated>
    
    <content type="html"><![CDATA[<p>今天正好看到两个技术面试相关的分享。结合自己这十年来的面试或者被面试经历，谈谈自己的想法。</p><h2 id="难得的面试分享"><a href="#难得的面试分享" class="headerlink" title="难得的面试分享"></a>难得的面试分享</h2><p>首先我们来看看 ReactJs 核心开发 Dan Abramov 的面试视频。这不算是正式的面试，是一个 Youtube 主播和 Dan 进行的模拟面试。<a href="https://www.youtube.com/watch?v=XEt09iK8IXs" target="_blank" rel="noopener">Coding Interview with Dan Abramov - YouTube</a></p><p><img src="/images/ob_pasted-image-20211206220156.png" alt="/images/ob_pasted-image-20211206220156.png"><br>这个面试将近持续了一个小时，但是主要是后面的那个算法题耗费时间，前面几个问题都是很八股的前端面试题：</p><ol><li>let 和 const 区别</li><li>什么时候使用 redux</li><li>dangerouslySetInnerHTML 是什么，该怎么用</li><li>把一个 div 居中</li><li>把一个 binaryTree 镜像翻转</li><li>Bonus Q: 一个找兔子的算法题，兔子出现在数组的某个位置，但是每次可以跳向相邻的位置，用最快的办法找到兔子的位置。</li></ol><p>这里面有意思的点是：</p><blockquote><p>Ben: There is a library called ‘redux’<br>   Dan: “Hmmmm heard about it”</p></blockquote><p><code>Redux</code> 最初版本是 dan 2015 年发布的……..  面试官小哥羞涩地笑了 🤣</p><p>然后，把 div 居中算是前端中的经典梗了，Dan 花了好一会时间在面试官的提示下才把一个 div 居中。如果对方不是 React 核心开发，手熟的前端可能就会开始鄙视这位“初级前端”了。这让我这种一直觉得 css 很难的前端学习者觉得信心大增。</p><p><img src="/images/ob_pasted-image-20211206221155.png" alt="/images/ob_pasted-image-20211206221155.png"></p><p>反转二叉树问题 dan 很快就答出来了，但是从面试过程中可以看到他对怎么尽量少代码 swap 两个变量还想了一会儿。我后来看他的十年总结的博文中，职业生涯初期的一次面试也提到了这个点:</p><blockquote><p> At one point I freaked out and panicked because I couldn’t write three lines of code that swap two items in an array. I asked Jing to look away for a few seconds. She said “I know you can swap two items”, and that gave me the confidence to finish the answer and make it through the interview. I probably didn’t pass with flying colors, but I got the offer.</p></blockquote><p>最后一个算法题比较新颖，这不算红黑树式的八股算法题，倒像是一个 IQ 测试题目。可以看出 dan 也很少碰这类算法题。他花费了近半个小时在面试官的提示下，按照自己的直觉一步一步推出了答案。但是他最后写的代码是有点小问题的(没有用 2 来递增 index)，面试者看他思路是对的也没有指出来了。这里可以看到，其实结果可能并不重要，而是在解决这问题中所展现出来的思维方式方法很重要。</p><p>除去 Bonus Question，可以说这轮面试的题目大多比较常规，难度小于很多国内外大厂的面试。dan 作为前端大咖，愿意参加这样的直播分享很难得。我感觉看到的是一个真实的工程师，在未做过八股训练情况下的真诚表现。</p><p>这是今晚看到的另外一个面试分享， <a href="https://github.com/yihong0618/gitblog/issues/228" target="_blank" rel="noopener">经历了人生体验最棒的一次面试 · Issue #228 · yihong0618/gitblog (github.com)</a>：</p><p><img src="/images/ob_pasted-image-20211206232729.png" alt="/images/ob_pasted-image-20211206232729.png"></p><p>我觉得比较难得的是第一面面试官的面试方式，选择一个面试者的开源项目，然后提一个小需求让他实现。这得很花面试官的心思和时间，也确实能很好地考察应聘者的编程能力和工程能力。国内这种认真面试的公司太少太少，而且一线大厂几乎不可能出现这种面试方式。</p><h2 id="我的一些经历"><a href="#我的一些经历" class="headerlink" title="我的一些经历"></a>我的一些经历</h2><p>在我十年的职业生涯中，经历过多次技术面试，作为应聘者被面试或者面试他人。</p><p>我经历过的最差的面试体验是在 2014 年。面试官没怎么看我的简历，首先让我挑两个主题，然后我能看到他在屏幕前点了点鼠标，从题库中挑选了几个题甩给我。这种感觉就是高中时候的考试体验，我需要在纸上写程序和公式。面试官全程严肃无表情，即使我主动需求交流也无果。这次面试可以说是深深地伤害了我，并给了我很大的心理阴影，导致我后来面试就会忍不住祈祷千万别再碰到这类面试官。</p><p>一些小而美的技术公司倒是更尊重应聘者。</p><p>前两年我参加过一个新加坡小外企的招聘。首先第一轮面试是双方自我介绍，对方会和我聊他们公司的主要业务和技术栈，以及目前这个岗位的工作内容和职责，确定我感兴趣之后才会约第一轮技术面试。第一轮面试就是一个小的项目，需求都写清楚，但其中也留了一下自由发挥的空间。我一周的时间来完成，然后把代码发过去。第二轮技术面试首先是从那个小项目聊，为什么这么写等等，然后会引出一些技术问题，但是会从深度和广度不断地追问下去。</p><p>面试的难点在于，很难在短时间内了解这个人的全部技能和特点。这些包括编程能力，工程能力，技术视野，沟通能力，应对挑战的能力等。</p><p>刘未鹏曾经在<a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/" target="_blank" rel="noopener">怎样花两年时间去面试一个人</a>中提到，用 Github 和书单的方法来面试。这当然是一个不错的面试方法。而大公司采用比较标准的面试，主要是为了节省时间。因为应聘者多，面试的场次多，不可能让面试官在工作之余花大时间主动了解应聘者。通常情况是面试官在面试之前匆匆扫上一眼简历。而且八股文式的面试很容易让面试官得出结论，即使这个结论充包含了不少偶然性因素。</p><h2 id="算法有什么用"><a href="#算法有什么用" class="headerlink" title="算法有什么用"></a>算法有什么用</h2><p>面试造火箭，入职后拧螺丝是行业常态。这也说明，我们工作中极少极少去碰这些基础算法类的东西。工作久了，我能看到很多面试官拿出一个公司的面试题，在不看答案的情况下自己也做不出来。</p><p>算法又是很多程序员所惧怕和不擅长的部分。Programming Pearls(《编程珠玑》)一书的作者 Jon Bentley 曾经说过：“90%的程序员无法正确实现二分查找算法…”。2014 年我在广州参加一个技术聚会上，因为一个一时兴起的赌局验证过这点。当时我们那个会议室 20 多个程序员，其中有工作多年的，也有刚毕业没多久的，能在规定时间写出一个无 bug 的二分查找的寥寥无几。</p><p>那面试出这种题目有何意义？</p><p>算法当然对程序员很重要，特别是在学校阶段，大量地实现数据结构和算法就是一种很好的提高编程能力的方法。我在学校最后一年刷了 POJ 500 道算法题，自我感觉编程能力大幅提高。</p><p>但我认为面试中的算法题可以当作一个下限标准，使用相对基础的、简单的编程题，会有助于筛选出编程能力不适合的应聘者。另外来自实际工作中的一些算法问题也是很好的面试题，比如上次我碰到的<a href="http://chenyukang.github.io/2021/11/29/input-complement-algorithm.html">输入自动补全算法</a>。这种问题没有唯一解，而且也很容易理解实现，通常有一定编程经验的程序员都可以实现出自己的版本。</p><p>较难的、八股式的算法题对于初步筛选不太有用。一个应聘者如果能很快答这种题，可能是他刷 LeetCode 比较多，或者是刚好之前碰到过这个题。</p><p>对于绝大部分岗位来说，算法题测试不适合当作上限标准，因为专门训练过的应聘者和没训练过的差别太大。对于资深的应聘者，往往只能通过以往的项目来考察深度和广度。我认为深度比广度重要，因为如果一个人能把某个领域做得很深，如果他花时间换个领域很可能会做得好，反之则不然。很多时候，面试官在某个领域没有应聘者熟悉。能让应聘者像老师一样把某个东西讲明白就很能考察对方的沟通能力。</p><h2 id="好的技术面试"><a href="#好的技术面试" class="headerlink" title="好的技术面试"></a>好的技术面试</h2><p>最后，我觉得好的技术面试有如下特点：</p><ol><li>对应聘者尊重，在面试过程中是一种平等的沟通和交流</li><li>不要浪费应聘者的时间和精力</li><li>拒绝八股，更多考察实际解决问题的能力</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天正好看到两个技术面试相关的分享。结合自己这十年来的面试或者被面试经历，谈谈自己的想法。&lt;/p&gt;
&lt;h2 id=&quot;难得的面试分享&quot;&gt;&lt;a href=&quot;#难得的面试分享&quot; class=&quot;headerlink&quot; title=&quot;难得的面试分享&quot;&gt;&lt;/a&gt;难得的面试分享&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="面试" scheme="http://chenyukang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian 插件开发</title>
    <link href="http://chenyukang.github.io/2021/12/02/obsidian-plugin-dev.html"/>
    <id>http://chenyukang.github.io/2021/12/02/obsidian-plugin-dev.html</id>
    <published>2021-12-02T07:17:37.000Z</published>
    <updated>2021-12-23T15:36:06.698Z</updated>
    
    <content type="html"><![CDATA[<p>昨天花了点时间下学习 Obsidian 的插件开发。我想了一下目前自己有点不爽的是图片插入的时候，图片的名称中间有空格，这虽然也不是什么大问题，只是在 Linux 环境下显示的时候看起来特别别扭。而且这看起来也是一个很好的入门小插件，可以接触 Obsidian 里面的文件管理和编辑操作，我需要把图片在文件系统里的名称改掉，也要修改 markdown 里的路径。</p><p>所有代码都在这里了： <a href="https://github.com/chenyukang/obsidian-rename-image" target="_blank" rel="noopener">chenyukang/obsidian-rename-image (github.com)</a>。</p><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li>从 plugin sample repo 克隆一个仓库</li><li>修改其中的 manifest.json 文件，其中 plugin id 是最重要的。</li><li>修改主文件 main.ts，使用 <code>npm install</code> 安装依赖库</li><li>使用命令 <code>npm run dev</code>  编译出 main.js </li><li>在 Obsidian  的 vault 目录 .obsidian/plugins/ 创建一个插件名称的文件夹，拷贝 manifest.json  和 main.js 到该目录，有的插件可能还有 style.css 等文件。</li><li>在 settings 页面加载插件</li></ol><p>在开发过程中，可以通过 <code>Ctrl-Shift-i</code> 来打开调试页面，在代码中加入调试信息。</p><h3 id="API-相关"><a href="#API-相关" class="headerlink" title="API 相关"></a>API 相关</h3><p>在插件项目里执行了 <code>npm install</code> 之后，文件 <code>node_modules/obsidian/obsidian.d.ts</code> 就是 Obsidian 的 API ，里面有很详细的注释。</p><p>作为补充可以看看 <a href="https://liamca.in/Obsidian+API" target="_blank" rel="noopener">Obsidian API - Liam Cain</a>。API 分为这几个主要部分。</p><p><img src="/images/ob_pasted-image-20211201194355.png" alt="/images/ob_pasted-image-20211201194355.png"></p><p>其中文件编辑部分使用了这个<a href="https://codemirror.net/" target="_blank" rel="noopener">CodeMirror</a>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之前有那么一会我会想，Obsidian 这样一个软件为什么不开源？如果开源我们是不是可以做更多的自由探索。通过折腾插件这么一段体验，我认为不开源问题也不大，其实通过插件我们其实可以在插件里面跑任何自己的代码。这里面的可扩展性对于绝大部分用户来说绰绰有余。</p><p>一个技巧是多看看已有的插件是如何实现的。打开 Settings 页面的 community plugins，选择某个感兴趣的插件看看里面的代码：<br><img src="/images/ob_pasted-image-20211203110506.png" alt="/images/ob_pasted-image-20211203110506.png"></p><p>Obsidian 模块化做得很好，而且 API 的粒度很细。在 VsCode 中写 TypeScript 插件体验比在 Emacs 中写 elisp 开发插件好很多，并且 JavaScript 的相关文档可太丰富了。</p><p>所以，真没必要抱着上古时代的软件不放 😁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天花了点时间下学习 Obsidian 的插件开发。我想了一下目前自己有点不爽的是图片插入的时候，图片的名称中间有空格，这虽然也不是什么大问题，只是在 Linux 环境下显示的时候看起来特别别扭。而且这看起来也是一个很好的入门小插件，可以接触 Obsidian 里面的文件管
      
    
    </summary>
    
    
      <category term="工具" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="obsidian" scheme="http://chenyukang.github.io/tags/obsidian/"/>
    
      <category term="TypeScript" scheme="http://chenyukang.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Sidecar 架构模式</title>
    <link href="http://chenyukang.github.io/2021/12/01/sidecar-design-pattern.html"/>
    <id>http://chenyukang.github.io/2021/12/01/sidecar-design-pattern.html</id>
    <published>2021-12-01T07:17:38.000Z</published>
    <updated>2021-12-23T15:36:06.698Z</updated>
    
    <content type="html"><![CDATA[<p>如果你最近经常看一些技术型的文章，可能会看到这个技术名词：Sidecar 模式。中文译名为：挎斗模式。这个名字为直译，挎斗就是这样的一种摩托车：</p><p><img src="/images/ob_2021-11-30-12-57-48.png" alt="/images/ob_2021-11-30-12-57-48.png"></p><p>如果理解了这种模式，就会明白这个名字其实取得特别好。Sidecar 模式就是指在原来的业务逻辑上再新加一个抽象层。这种模式很好的印证了那个计算机的名言：</p><blockquote><p> “计算机科学领域的任何问题都可以通过增加一个简介的中间层来解决。”</p><p>“Any problem in computer science can be solved by another layer of indirection.”</p></blockquote><p>如果一个抽象层不够，那来两个。这种模式也不是近些年新发明的，我们可以理解 Nginx 的反向代理其实也算一种 sidecar 模式。只是近些年，随着微服务和容器化在实践中越来越多，这种模式的使用范围也更广了。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在微服务架构中，如果应用多了就会形成一些共有的需求。特别是流量控制方面，包括限流、流量分发和监控、灰度等等。通常我们对一类需求可以实现一个抽象层，然后在这个抽象层上实现具体的业务逻辑。比如很多公司都有服务网关，然后使用各种语言的 SDK 来集成到应用中。</p><p><img src="/images/ob_pasted-image-20211130163700.png" alt="/images/ob_pasted-image-20211130163700.png"><br>这是通常我们会选择的一种方式，这过程中会有这样的一些问题需要考虑：</p><ol><li>SDK 的维护成本是很高</li><li>SDK 集成到代码中，其中一个组件发生故障就可能会影响到其他组件，SDK 和应用程序之间是保持着相互依赖的关系的。</li></ol><p>在应用层和基础服务没有解耦的情况下，我们对基础服务做改动会增加很多风险和复杂度。例如，我之前所在的部门整个电商的应用做灰度改造，所有应用都需要做对应的改动。</p><h2 id="sidecar-架构"><a href="#sidecar-架构" class="headerlink" title="sidecar 架构"></a>sidecar 架构</h2><p>那我们是否可以提供一个统一的抽象层来做这些基础的重复工作？将基础服务抽象、解耦到应用层都感知不到的程度？</p><p>这是现在的趋势，特别是现在很多架构都跑在容器这样的环境了，统一的抽象层能大大减少架构上的复杂度。 sidecar 模式在不改变主应用的情况下，会起来一个辅助应用，来辅助主应用做一些基础性的甚至是额外的工作。这个 sidecar 通常是和主应用部署在一起，所以在同样的运行环境下。这其中还有一些性能上的考虑，sidecar 如果和主程序网络通信上有延迟就会造成性能问题。例如在 K8s 下一个 pod 里的所有子应用共享一个 sidecar 服务。</p><p>这个辅助应用不一定属于应用程序的一部分，而只是与应用相连接。这就像是挎斗摩托车，每个摩托车都有自己独立的辅助部分，它随着主应用启动或停止。因为 sidecar 其实是一个独立的服务，我们可以在上面做很多东西，例如 sidecar 之间相互通信、或者通过统一的节点控制 sidecar ，从而达到 Service Mesh。</p><p><img src="/images/ob_sidecar-mode-20211130170923.png" alt="/images/ob_sidecar-mode-20211130170923.png"></p><p>这样的好处在于：</p><ol><li>应用层和基础服务层解耦</li><li>基础服务统一维护，SDK 统一集成，减少复杂度，减少应用服务中的重复部分</li><li>可以在不改变原有应用的情况下，为应用扩展新的功能</li></ol><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>我们可以来看看业界典型的使用 sidecar 模式的框架。</p><h3 id="DAPR"><a href="#DAPR" class="headerlink" title="DAPR"></a>DAPR</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/architecture/dapr-for-net-developers/dapr-at-20000-feet" target="_blank" rel="noopener">Dapr: Distributed Application Runtime</a> 是微软开源的一套分布式程序开发框架，其目标是：“Build distributed applications with any language, any framework, run anywhere”。既然任何编程语言，任何框架都要支持，sidercar 是一个必然的选择。DAPR 把很多常见的分布式程序的公共组件抽象出来成为’building blocks’，然后通过 gRPC 或者 HTTP 统一出接口。应用程序通过 sidecar 来访问。</p><p><img src="/images/ob_pasted-image-20211130172044.png" alt="/images/ob_pasted-image-20211130172044.png"><br>这样多了一层抽象之后，即使是某个 Component 做了一些改变，应用层也是无感知的。除了在容器化的环境下运行，用户也可以在非容器化环境以 sidecar 模式启动任何应用，例如我们启动一个图片接口服务 <code>image-api-service</code>，该服务会监听端口 8080，而 sidecar 会通过 3500 端口来代理该服务接受请求：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dapr run --app-id image-api \</span><br><span class="line">         --app-protocol http \</span><br><span class="line">         --app-port 8080 \</span><br><span class="line">         --dapr-http-port 3500 \</span><br><span class="line">         --components-path ../config \</span><br><span class="line">         --<span class="built_in">log</span>-level debug \</span><br><span class="line">         ./image-api-service</span><br></pre></td></tr></table></figure><p>其他服务组件可以通过 sidecar 去请求该服务：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dapr api format: http://localhost:&lt;daprPort&gt;/v1.0/invoke/&lt;appId&gt;/method/&lt;method-</span></span><br><span class="line">uri = <span class="string">"http://localhost:3500/v1.0/invoke/image-api/method/api/image"</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">"POST"</span>, uri, bytes.NewBuffer(image))</span><br></pre></td></tr></table></figure><h3 id="lstio"><a href="#lstio" class="headerlink" title="lstio"></a>lstio</h3><p><a href="https://istio.io/latest/zh/about/service-mesh/" target="_blank" rel="noopener">Istio 服务网格</a> 是一个开源的服务网格，提供了统一的方式来实现连接、监控、负载均衡等公共服务和流量管理。单个服务的所有传入和传出网络流量均通过 Sidecar 代理，完成微服务之间的流量管理、遥测数据收集以及策略的执行等。</p><p><img src="/images/ob_pasted-image-20211130173530.png" alt="/images/ob_pasted-image-20211130173530.png"></p><p>在 lstio 中，我们需要了解 Data Plane 和 Control Plane 两个概念——  </p><ul><li>Data Plane 的作用是处理网格内服务间的通信，并完成服务发现、负载均衡、流量管理、健康检查等功能；数据平面的作用是处理网格内服务之间的通信，并负责实现服务发现、负载平衡、流量管理、健康检查等功能；</li><li>Control Plane 的作用是管理和配置 Sidecar 来执行策略并收集遥测</li></ul><p>lstio 中使用了 Lyft 开源的 Envoy 来做流量代理，Envoy 和应用程序一起在一个独立的进程中运行，应用与 localhost 收发信息，对网络的拓扑结构无感知。</p><h2 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h2><ul><li>更适合在容器化的环境使用</li><li>简单系统就没有必要使用这种重型武器了</li><li>哪些部分可以放到 sidercar 里面需要慎重考虑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你最近经常看一些技术型的文章，可能会看到这个技术名词：Sidecar 模式。中文译名为：挎斗模式。这个名字为直译，挎斗就是这样的一种摩托车：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ob_2021-11-30-12-57-48.png&quot; alt=&quot;/image
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="架构" scheme="http://chenyukang.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>在 Github Action 使用 Git</title>
    <link href="http://chenyukang.github.io/2021/11/30/using-git-in-github-action.html"/>
    <id>http://chenyukang.github.io/2021/11/30/using-git-in-github-action.html</id>
    <published>2021-11-30T07:17:46.000Z</published>
    <updated>2021-12-23T15:36:06.698Z</updated>
    
    <content type="html"><![CDATA[<p>最近我把自己的一些自动化脚本移到了 Github Action。因为考虑到 Github Action 有下面几个优势：</p><ol><li><p>自动化脚本是代码的一部分 (Infrastructure as Code)，而不是限定在某个服务器上。这样长久来说更为通用，如果我迁移到其他服务器根本不用做什么修改，因为我们在写 Github Action 的脚本的时候就不假定在哪台服务器上运行。</p></li><li><p>配置更为方便，想要修改一下只需要提交配置文件就可以了，不用登录到服务器上。</p></li></ol><p>基于以上几点考虑，我花了一些时间来把之前的一些 Ruby、Shell 脚本变成 Github Action 配置。有的脚本做的事情是定时拉去某个 repo，如果有改动则会根据规则生成新的内容，然后自动提交到远程仓库。所以我需要在 Github Action 中使用 Git 提交数据。要达到这个目的得在 Github 中配置 Git 的权限和账户信息。有以下两种方式：</p><h2 id="使用-Github-Access-token"><a href="#使用-Github-Access-token" class="headerlink" title="使用 Github Access token"></a>使用 Github Access token</h2><p>首先需要在 Settings 页面生成一个 Access Token. 然后添加到要配置 Github Action 的仓库的 Settings 页面中，假设我的 token 取名为<code>PAT</code>，在 Action 中我们可以通过 <code>secrets.PAT</code> 获取和使用该 Token。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  sync-to-sites:</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Git</span> <span class="string">Clone</span> <span class="string">and</span> <span class="string">Global</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # Git setup</span></span><br><span class="line"><span class="string">          export GITHUB_USER=yukang</span></span><br><span class="line"><span class="string">          echo "GITHUB_USER=$GITHUB_USER" &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string">          echo "GITHUB_TOKEN=$<span class="template-variable">&#123;&#123; secrets.PAT &#125;&#125;</span>" &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string">          git config --global user.email "moorekang@gmail.com"</span></span><br><span class="line"><span class="string">          git config --global user.name $GITHUB_USER</span></span><br></pre></td></tr></table></figure><p>然后通过如下方式 clone 要修改的 repo 到跑 action 的服务器目录上。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">checkout</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">  uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line"><span class="attr">  with:</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="string">chenyukang/blog-source</span></span><br><span class="line"><span class="attr">    token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PAT</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">blog-source</span></span><br></pre></td></tr></table></figure><p>这种通过 Access Token 的方式 clone repo，用的是 HTTPS 的方式。通过 <code>git remote -v</code> 查看可以看到 remote 的地址。</p><h2 id="使用-SSH"><a href="#使用-SSH" class="headerlink" title="使用 SSH"></a>使用 SSH</h2><p>另外一种方式是通过 ssh key。我们首先在任何一个服务器生成一个 ssh key，把这个 ssh 的 public key 加入到 Github settings 里。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>然后把私钥拷贝到要配置 Action 的 repo 的 secrets 里。</p><p>通过如下方式在 action 中配置 ssh：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Install</span> <span class="string">SSH</span> <span class="string">Key</span></span><br><span class="line"><span class="attr">  uses:</span> <span class="string">shimataro/ssh-key-action@v2</span></span><br><span class="line"><span class="attr">  with:</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_KEY</span> <span class="string">&#125;&#125;</span> </span><br><span class="line"><span class="attr">    known_hosts:</span> <span class="string">'just-a-placeholder'</span></span><br></pre></td></tr></table></figure><p>这样之后就可以在 Action 的后续步骤中像在本地一样使用 SSH 的方式来 clone repo 和提交代码了。<br>通过 ssh key 的方式我们也可以在 Github Action 中通过远程的方式来在其他服务器上执行命令，这对于要部署到服务器上的脚本来说是非常有用。</p><p>具体可以参考这篇文章： <a href="https://zellwk.com/blog/github-actions-deploy/" target="_blank" rel="noopener">Deploying to a server via SSH and Rsync in a Github Action | Zell Liew (zellwk.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近我把自己的一些自动化脚本移到了 Github Action。因为考虑到 Github Action 有下面几个优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自动化脚本是代码的一部分 (Infrastructure as Code)，而不是限定在某个服务器上。这样长久来说更为通
      
    
    </summary>
    
    
      <category term="工具，Github" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CGithub/"/>
    
  </entry>
  
  <entry>
    <title>自动补全算法</title>
    <link href="http://chenyukang.github.io/2021/11/29/input-complement-algorithm.html"/>
    <id>http://chenyukang.github.io/2021/11/29/input-complement-algorithm.html</id>
    <published>2021-11-29T08:34:43.000Z</published>
    <updated>2021-12-23T15:36:06.694Z</updated>
    
    <content type="html"><![CDATA[<p>周末在和一个日本小伙一直讨论一个 Obsidian 的 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin" target="_blank" rel="noopener">补全插件</a>，经过一个周末的努力，最终这个插件完善了不少。</p><p>我主要想用这个插件来补全英文输入，这个插件目前没有自带的词典。我在互联网上搜索了一圈，最终在 Github 上找了这个 <a href="https://github.com/first20hours/google-10000-english" target="_blank" rel="noopener">Google 10000 English</a>，也就是最长使用的搜索单词。</p><p>实际上，前 7000 个英语单词覆盖了日常的 90% 使用场景。</p><h3 id="中文输入"><a href="#中文输入" class="headerlink" title="中文输入"></a>中文输入</h3><p>首先我碰到的问题是，输入中文的时候插件也在补全英文。然后我提了第一个 issue。作者很快就回复了，给了我一个开发版本尝试，很完美的修复了这个问题。<br><img src="/images/ob_pasted-image-20211128185804.png" alt="/images/ob_pasted-image-20211128185804.png"><br>然后在使用过程中发现另一个小问题，比如我的字典里面有 <code>apple</code>，但是如果我是在句子头部输入 <code>Ap</code> ，这个单词并没有出现在补全列表。我们当然可以把字典的单词都进行首字母大写的处理，但是这就会让字典翻倍。</p><p>我看了看源码，果然如自己猜想的那样，匹配的时候没有考虑首字母大写的问题。我花了一些时间做了一个 PR：<a href="https://github.com/chenyukang/obsidian-various-complements-plugin/commit/935d7de1633b9a7685349a97302a0e908e10b215" target="_blank" rel="noopener">fix issue #30, take care of uppercase </a>。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>在我做上个修复的时候，也顺便修复了一个性能上的问题，看这个补全插件的核心算法如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">function suggestWords(words: Word[], query: string, max: number): Word[] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(words)</span><br><span class="line">    .filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x.value !== query)</span><br><span class="line">    .map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (caseIncludesWithoutSpace(x.value, query)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">word</span>: x, <span class="attr">value</span>: x.value, <span class="attr">alias</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> matchedAlias = x.aliases?.find(<span class="function">(<span class="params">a</span>) =&gt;</span></span><br><span class="line">        caseIncludesWithoutSpace(a, query)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (matchedAlias) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">word</span>: x, <span class="attr">value</span>: matchedAlias, <span class="attr">alias</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">word</span>: x, <span class="attr">alias</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x.value !== <span class="literal">undefined</span>)</span><br><span class="line">    .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> aliasP = (<span class="built_in">Number</span>(a.alias) - <span class="built_in">Number</span>(b.alias)) * <span class="number">10000</span>;</span><br><span class="line">      <span class="keyword">const</span> startP =</span><br><span class="line">        (<span class="built_in">Number</span>(lowerStartsWith(b.value!, query)) -</span><br><span class="line">          <span class="built_in">Number</span>(lowerStartsWith(a.value!, query))) *</span><br><span class="line">        <span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">const</span> lengthP = a.value!.length - b.value!.length;</span><br><span class="line">      <span class="keyword">return</span> aliasP + startP + lengthP;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.word)</span><br><span class="line">    .slice(<span class="number">0</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中如果词典列表很长，这里的 <code>filter</code>, <code>map</code>, <code>filter</code> 会遍历列表三次，是很耗时的操作。我把第一个 filter 干掉了。然后在匹配逻辑里面增加了首字母大写的相关的 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/commit/2b3990af4b4e19198833e1deb0a8783fcd45a60e#diff-25a6634263c1b1f6fc4697a04e2b9904ea4b042a89af59dc93ec1f5d44848a26" target="_blank" rel="noopener">处理</a>。除了自定义的单词词典，这里补全的候选词来源包括当前文件内容、Obsidian 的内部链接。而链接需要进行部分匹配进行补全。</p><p>后续在使用过程中我又觉得补全有些慢，甚至会影响输入的体验，在 Obsidian 里面通过 <code>Ctrl+Shift+I</code> 可以打开调试面板，我们可以看到补全的耗时：</p><p><img src="/images/ob_pasted-image-20211128193253.png" alt="/images/ob_pasted-image-20211128193253.png"></p><p>这里的主要问题还是因为每次输入一个字母，算法都在遍历单词列表两边。优化思路有两条：</p><ol><li>使用类似桶排序的思路，把单词按照首字母进行分割，分成 26 个子列表，这样查找的时候就先根据首字母找到子列表，然后进行遍历搜索。</li><li>使用类似 Trie Tree 的数据结构进行前缀匹配。</li></ol><p>后来那个作者按照第一种思路进行了 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/commit/f6e047d479b57f3dd2171ce5eaa1c1f7692c91ad" target="_blank" rel="noopener">优化</a>，很快将补全时间优化到了 0~5 ms。果然粗暴的算法其实很多时候就够了。</p><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><p>在日常使用过程中，我又发现了还存在这个 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/issues/34" target="_blank" rel="noopener">问题</a>。如果我尝试去修改中文句子的某个部分，这个插件会补全当前句子，就像这样：</p><p><img src="/images/ob_pasted-image-20211128194301.png" alt="/images/ob_pasted-image-20211128194301.png"><br>这当然是完全没有意义的。我看了一下代码发现是没有进行中文分词，所以现在的补全把这个中文句子当作一个连续的字符串在补全。</p><p>我自己尝试这想做一个 PR，但是没找到合适的中文分割 JavaScript 库。Obsidian 不能使用 Node 的库（移动端方面的考虑），所以也就不能使用这个 <a href="https://github.com/yanyiwu/nodejieba/blob/master/README_EN.md" target="_blank" rel="noopener">NodeJieba</a>。虽然还没完成这个分词功能，不过我也在这个过程中学着写了点 TypeScript。</p><h3 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h3><p>这个看似简单的功能，如果要做到日常可用其实有很多细节需要完善。这个算法问题看起来不难，很适合用来进行面试。这是日常中很常见的一个需求场景，而且优化这个算法思路也可以很开放。</p><p>TypeScript 真强，虽然我只是简单用了一下，一些常见的 JavaScript 错误比如 enum 忘记补全之类的问题都能找出来。<a href="https://www.electronjs.org/" target="_blank" rel="noopener">Electron</a> 真猛，VSCode、Obsidian、Slack 这类工具都是 Electron 开发的。</p><p>开源软件的好处在于很多代码的作者对自己的成果有一种成就感，所以会想办法来完善，而用户也可以帮着来想办法。在这个过程中，不仅可以让其他人受益，自己也得到了一些学习和提高😘。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周末在和一个日本小伙一直讨论一个 Obsidian 的 &lt;a href=&quot;https://github.com/tadashi-aikawa/obsidian-various-complements-plugin&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://chenyukang.github.io/tags/Tools/"/>
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="Obsidian" scheme="http://chenyukang.github.io/tags/Obsidian/"/>
    
  </entry>
  
  <entry>
    <title>打造自己的工具 - Obweb</title>
    <link href="http://chenyukang.github.io/2021/11/28/intro-to-obweb.html"/>
    <id>http://chenyukang.github.io/2021/11/28/intro-to-obweb.html</id>
    <published>2021-11-28T07:00:04.000Z</published>
    <updated>2021-12-23T15:36:06.694Z</updated>
    
    <content type="html"><![CDATA[<p>在文章<a href="http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html">我的知识管理工具和经验</a>中我介绍了自己开发的 Obsidian 配合 Web 应用 <a href="https://github.com/chenyukang/obweb" target="_blank" rel="noopener">obweb</a>。</p><p>下面详细介绍一下自己对每个功能的使用场景，以及其中的一点技术细节。后端使用 <code>Rust</code> 开发的，因为后端逻辑并不复杂，所以使用什么语言区别不大。我最近在练手 <code>Rust</code>，所以就用了 <a href="https://github.com/seanmonstar/warp" target="_blank" rel="noopener">Warp</a> 这个框架来实现。</p><p>我是一个前端新手，顺便借这个项目在学习一些 JavaScript 和 Svelte 相关的技能。第一次实现的时候是纯 HTML 加 JQuery，后来又加上了 Svelte 。Svelte 这个前端框架对新手来说也不难，我是边看教程边照着做的。</p><p><img src="/images/ob_pasted-image-20211127144951.png" alt="/images/ob_pasted-image-20211127144951.png"></p><p>Obweb 是一个典型的前后端分离的 Web 应用，没什么技术上的难度。可忽略我直男的 UI 设计(貌似根本无设计😂)，我们着重看看我日常用的这些功能。</p><h2 id="记录想法"><a href="#记录想法" class="headerlink" title="记录想法"></a>记录想法</h2><p>这是我做 Obweb 的初衷，我想在手机端把一些想法和灵感记录下来。之前一直使用 [[flomo]] 这款应用，这个应用功能很少，就是让你打开迅速记录自己所想，使用标签来把这些想法串联起立。随着我使用 Obsidian 的时间越来越多，我就想把这些数据同步到自己的 Obsidian 中。</p><p>于是就开始用自己蹩脚的前端能力搞了这么一个界面。</p><p><img src="/images/ob_pasted-image-20211127133255.png" alt="/images/ob_pasted-image-20211127133255.png"></p><p>这个界面很简单，就是一个输入框，可以加入标签或者 Link。但是这里面隐藏了一些逻辑：</p><ul><li>如果 Link 为空，这个记录则为一个每日的想法，会追加在每天的 Daily 文件后</li><li>如果 Link 是 Todo，则会在我的 Todo.md 在文件头部增加一个记录。 </li><li>如果 Link 是一个其他的文件名，如果数据中没有这个文件则会创建，否则就会在现有的文件后追加这条记录。这种使用场景是我在手机上看 Kindle，有的摘抄就会记录下来，最终每一本书阅读后摘抄就会在一个文件里面。这也是为什么这个 Link 除非手动清除，否则会一直记录在 localStorage 里面。因为一段时间内我看的都是一本书。如果要清除缓存则可以使用 <code>Reset</code> 按钮。</li></ul><p>可以在想法中加上图片，但是限制只能加一张。因为我习惯了使用这个记录页面之后，我也想在 PC 端使用。因此增加了从剪切板中存储图片的功能，以方便我在 PC 端想同步一些内容到手机上以备后续查看。</p><h2 id="每日回顾"><a href="#每日回顾" class="headerlink" title="每日回顾"></a>每日回顾</h2><p>想法中记录的内容，可以使用 <code>Day</code> 来回顾，目前只有按照日期每日来回地切换。如果要大量地查阅内容我肯定使用 PC 端。这里也可以进行一些轻度编辑。</p><p><img src="/images/ob_pasted-image-20211127134715.png" alt="/images/ob_pasted-image-20211127134715.png"></p><h2 id="搜索和编辑"><a href="#搜索和编辑" class="headerlink" title="搜索和编辑"></a>搜索和编辑</h2><p>我在手机端使用场景主要记录想法，但也有一定的查阅需求。比如我在外面办事可能需要看公司的保险需要哪些材料，这些我都会截图或者记录下来。所以，搜索是刚需。</p><p>目前搜索使用的就是粗暴的关键词匹配，我感觉已经够用了。后续可能可以增加分词等复杂一些的逻辑。作为程序员，文件中的代码高亮肯定是需要支持的，使用 <code>highlight.js</code> 就好了。</p><p><img src="/images/ob_pasted-image-20211122123826.png" alt="/images/ob_pasted-image-20211122123826.png"></p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><p>Todo 也是一个 Markdown 格式的文件，而且这个文件只有记录了创建这个 todo 项的时间。我养成习惯每天早上都会看一看然后选择一些 todo 干掉。虽然目前很简陋，看起来就像是一个备忘录而已。对我来说也是足够了，我没有很多细小的事情需要赶 deadline。</p><p><img src="/images/ob_pasted-image-20211127135356.png" alt="/images/ob_pasted-image-20211127135356.png"></p><h2 id="RSS-阅读"><a href="#RSS-阅读" class="headerlink" title="RSS 阅读"></a>RSS 阅读</h2><p>我已经有一段时间没有使用 RSS 阅读器了，其中一个原因是我没找到合适的安卓客户端。可能 IOS 上能找到一些精美的 RSS 阅读器。越来越多的人对 RSS 阅读不感兴趣了，国内的很多人使用公众号或，知乎，或者很多空闲时间用来看抖音。国外很多人继续使用 Newsletter 的形式来订阅，内容创作者也喜欢让你通过邮件订阅，因为邮件订阅是一种双向的关系，他也可以通过邮件联系你，这样后续就可以推广产品之类的。所以说 RSS 是反商业的模式，通过 Feed 订阅似乎成为怀旧行为。</p><p>互联网上还是有很多独立博客，他们不是为了商业利益，纯粹是为了自己的爱好和分享精神，坚持写一些高质量的内容。在没找到合适的工具的情况下，我自己实现了一个简单的 RSS 爬虫和这个 RSS 阅读界面。爬虫部署在我的服务器上，每隔几十分钟就会遍历我的订阅列表，抓取内容推送到 Github 私人仓库。服务端的爬虫使用的数据库是 <code>SQLite</code> 来存储文章的其他一些元数据。</p><p>有的作者 RSS feed 里面只提供摘要。为了营造沉入式的阅读感受，我尝试把文章的内容都抓取过来，包括图片也会拷贝一份到我自己的服务器上。这样每一篇文章打开都是全文，而不是摘要。</p><p><img src="/images/ob_pasted-image-20211122123722.png" alt="/images/ob_pasted-image-20211122123722.png"></p><p>我最近发现一个新的使用场景，这种里面带有  Podcast 的语音内容，在开车时候打开听很方便。</p><p><img src="/images/ob_pasted-image-20211123171216.png" alt="/images/ob_pasted-image-20211123171216.png"></p><h2 id="后续改进"><a href="#后续改进" class="headerlink" title="后续改进"></a>后续改进</h2><p>因为现在使用 RSS 阅读的时间越来越多了，后面可能会继续优化 RSS 阅读的一些细节。另外前端代码现在比较乱，后面会继续学习一些前端技能，把代码优化得更优雅简洁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在文章&lt;a href=&quot;http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html&quot;&gt;我的知识管理工具和经验&lt;/a&gt;中我介绍了自己开发的 Obsidian 配合 Web 应
      
    
    </summary>
    
    
      <category term="工具，Obweb" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CObweb/"/>
    
  </entry>
  
  <entry>
    <title>我的知识管理工具和经验</title>
    <link href="http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html"/>
    <id>http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html</id>
    <published>2021-11-23T00:21:58.000Z</published>
    <updated>2021-12-23T15:36:06.694Z</updated>
    
    <content type="html"><![CDATA[<p>知识管理是近些年出来的逼格称呼，通俗点说就是写笔记或者写作，讲究一点可以说成“打造第二大脑”，英文中可以诗意地称之为 “Digital Garden”。看看，同样一个事怎么说出来格局完全不同了。</p><p>近两年笔记软件这个领域出现了两个很重要的创新：</p><p>一个是双向链接，开山鼻祖是 <a href="https://roamresearch.com/" target="_blank" rel="noopener">Roam Research</a> ，一个是一切皆对象和可无限嵌套的设计，也就是 <a href="https://www.notion.so/" target="_blank" rel="noopener">Notion</a>。</p><p>因为这两个大方向上的微创新，现在笔记类软件和系统百发齐放，这是真是最好的时代了。</p><p>作为程序员我分享一下自己在这类工具上的使用经验、感受以及建议。</p><p>大概十多年前，还在学校的时候，博客文化刚兴起，所以很多记录类的东西我都写在博客里了。那些常见的博客系统我基本都用过，后来很多都倒闭了。当然 Wordpress 现在在非程序员中都非常流行。</p><p>后来很长一段时间我都是用 Evernote ，国内版本叫做印象笔记。用的人多了各种周边的工具也非常多，比如浏览器插件之类的。这类笔记软件也非常多。</p><p>三四年后我又渐渐不使用印象笔记了，因为我用了很多年 Emacs，所以偶然尝试了 org-mode。这东西结合 GTD 可玩的方式可太多了。 org-mode 日程管理，日志，文档都在本地，一切都是纯文本的 org 格式，我通过 Github 来做数据存储。一切都是文本并且本地化就可以自动化，我可以自己写一些脚本，自己定义各种模板等等。虽然是纯文本的格式，我也可以很方便地到导出成 PDF , 甚至是做演示。很多人是为了使用 org-mode 才一直用 Emacs，我也曾经认为自己找到了以后一直用的记录工具和方式。</p><p>在这段时间，我养成的一个很好的习惯是使用  Github 来存储自己的数据。Github 已经成为最基础的互联网设施，我信任这个平台胜过其他服务。Joe Armstrong 在去世前一年，把自己的文章迁移到 Github，感兴趣的可以看看这篇不错的文章 <a href="https://laike9m.com/blog/people-die-but-long-live-github,122/" target="_blank" rel="noopener">People Die, but Long Live GitHub</a>。</p><p>后来，我因为换工作的原因不怎么使用 Emacs了。最近一年工作内容变了，自己日常开发和业务时间使用 Windows 更多。业余时间基本是用的 WSL ，配合 VsCode 日常开发体验很棒。 而 Emacs 在 Windows 上使用体验很不好，我也没找到合适的移动端解决方案。虽然最近 WSL 也支持 Linux Gui 了，但我已经懒得折腾，因为我已经离不开 VS Code 。</p><p>我需要重新找一个笔记类工具，我的需求是：</p><ol><li>本地存储文件</li><li>足够的自定义</li><li>支持 Markdown</li><li>支持双向链接</li></ol><p>这个需求其实满足了绝大部分程序员用户，一个文件夹加 Typora 估计都差不多了，但是我觉得双链这个设计确实有一些价值，所以也变成刚需了。</p><p>在摸索的过程中我试过 Notion，Wolai，Logseq，Obsidian。</p><p>Notion 确实有耳目一新的感觉，而且 UI 的审美很好，用户做出来的笔记可以很美观整洁。而内嵌 Database 可以打造出来很多好玩的东西，甚至可以用来做站点。缺点是服务器在国外，不太稳定。</p><p>Wolai 提供 Notion 类似的块编辑以及大部分功能，而且很早就有双链接，服务器在国内所以速度上也很快。版本更新很快，有很多针对中文用户的细节优化。如果不想折腾用 Wolai 也挺好的。Wolai 和 Notion 是比较重的工具，已经超过了通常我们理解的笔记管理软件的范畴。</p><p>Logseq 是 Roam Research 的模仿品，但是提供本地存储的方式，也有桌面版软件。很多人赞赏 Roam Research ，不过我没有觉得这种方式完全适合我。 Roam Research 的正常方式是每天都在日志页面记录，然后写的过程中加上适合的链接，这样你的文档渐渐构成一个网络。如果你日常中经常用到的概念，自然就会经常被链接，那么就会是网络中的一个密集点。所以即使你不建文件目录，这种文档之间的关系也会自然而然形成，并且比目录这种单线的关系更符合直觉。</p><p><img src="/images/ob_pasted-image-20211120225233.png" alt="/images/ob_pasted-image-20211120225233.png"></p><p>最终我一直保持使用的是 Obsidian。Obsidian 支持本地存储数据的方式（也可选择付费远程同步）。我使用一个 Git 的插件自动同步到 Github。Obsidian 的客户端做得如此出色，而且扩张性极好，已经形成很成熟的插件生态。这是我的记录汇成的网状。</p><p><img src="/images/ob_pasted-image-20211120225329.png" alt="/images/ob_pasted-image-20211120225329.png"></p><p>在使用 Obsidian 一段时间后我又体验了 Flomo，这是一个不错的软件让我们迅速把日常的想法记录下来。我想如果 Flomo 的数据能够同步到 Obsidian 就好了。</p><p>看了一下 Flomo 的接口，我觉得干脆还不如自己动手重新实现来练练手。我就动手自己实现了一个 Web 单页应用 <a href="https://github.com/chenyukang/obweb" target="_blank" rel="noopener">obweb</a>，然后部署在自己的服务器上。这个应用提供一个简单的页面来记录日常的想法，文字或者图片都能迅速提交。数据提交后同步到 GitHub。这个 SPA 页面可以内嵌在微信浏览器，所以使用体验和一个小程序差不多。</p><p>而后我又增加了搜索的接口，这样我所有 Obsidian 的数据都可以在手机端检索和查看，而且我也能做一些简单的编辑。实际使用下来这真的比一个独立的手机应用更方便。</p><p>最近我又新增了一个 Rss 阅读的功能，后台会自动根据我的订阅列表抓取 Feed，甚至会尝试把网页和图片都下载下来，这样即使是一些”内网”不能直接访问的文章也可以在手机端无障碍阅读。</p><p>在这个过程中我学会了 svelte 这个前端框架和 Rust 写服务端接口这些东西。虽然我的 UI 设计和前端技能简直就是渣渣，但是这就是完全贴合我的使用习惯的软件，我可以做到所有细节的定制化。</p><p><img src="/images/ob_pasted-image-20211123190603.png" alt="/images/ob_pasted-image-20211123190603.png"></p><p>这是一种渐进式的开发体验，每隔一段时间我会在使用过程中摸索一个需求，然后我会稍微等一等，如果这个需求还是存在并且我考虑好了如何实现，我就会加上去。</p><p>折腾这么多年这类软件后，我的感受是工具的使用都是非常私人化的选择，作为程序员我们有能力使用自己的技术来定制化工具来提高效率。最近看到这篇文章 <a href="https://www.swyx.io/make-your-own-tools/" target="_blank" rel="noopener">You’re Allowed To Make Your Own Tools</a> 很好的阐述了这个观念。这就像是住房子一样，如果你自己是设计师，估计不会满足房地产商提供的统一装修，而是根据自己的喜好和习惯来重新设计。房子也不是越富丽堂皇就越好，简单但实用即可。</p><p>所以在文档和写作这块，数据本地纯文本的方式是对程序员更好的方式，你可以自己写程序来处理这些数据，而不是完全依靠软件或者第三方的功能。比如这篇文章就是我在陪小孩上课的过程中，用手机在 obweb 上敲出来，服务器上的脚本会自动转成 Hexo 文件，提交发布到我的博客。</p><p>最后，我们现在有很多华丽的工具来用，也要避免让自己变成一个纯粹信息的收藏者。’数字花园’不是一股脑地往后院搬东西就行，需要花时间精心打理和修剪。工具并不能本质地解决问题，难的是日复一日坚持记录自己的想法和理解，整理知识。柳比歇夫使用纸和笔记录了自己奇特的一生，并且完成大量研究工作。</p><p>记录的过程并不是学习本身，而是思考。通过记录这种形式，把自己的理解写下来促进思考，才能产生最大的价值。</p><hr><p>题外画:</p><p>一个有趣的事是，除了 Roam Research 和大厂的传统产品，目前兴起的这些笔记类软件和服务大多是中国人开发的，包括 Notion、Obsidian、Logseq 等。我们可能真的比较喜欢这类东西，“好记性不如烂笔头” 乃民族真传。</p><p>另一个事实，Roam Research，Logseq，以及另外一个开源的类似产品 <a href="https://www.athensresearch.org/" target="_blank" rel="noopener">Athens Research</a> 都使用了 Clojure 这门编程语言来实现。Clojure 作为一门 JVM 上的 Lisp，其热度还没进过前 30 吧。这门语言对于数据处理这样的项目是比较合适的，只是不太适合大团队使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识管理是近些年出来的逼格称呼，通俗点说就是写笔记或者写作，讲究一点可以说成“打造第二大脑”，英文中可以诗意地称之为 “Digital Garden”。看看，同样一个事怎么说出来格局完全不同了。&lt;/p&gt;
&lt;p&gt;近两年笔记软件这个领域出现了两个很重要的创新：&lt;/p&gt;
&lt;p&gt;一
      
    
    </summary>
    
    
      <category term="工具" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发" scheme="http://chenyukang.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
