<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyukang.github.io/"/>
  <updated>2021-12-29T01:01:47.908Z</updated>
  <id>http://chenyukang.github.io/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我欣赏的英文技术站</title>
    <link href="http://chenyukang.github.io/2021/12/28/best-english-tech-sites.html"/>
    <id>http://chenyukang.github.io/2021/12/28/best-english-tech-sites.html</id>
    <published>2021-12-28T10:32:58.000Z</published>
    <updated>2021-12-29T01:01:47.908Z</updated>
    
    <content type="html"><![CDATA[<p>做技术这么多年，我订阅了很多英文技术站点。这里介绍一些我认为非常值得关注、学习的技术站点。我推荐的标准是：</p><ol><li>持续多年更新</li><li>质量非常高，或者某些文章深刻地启发了我</li></ol><p>后面我会长期更新这个列表：</p><hr><ul><li><a href="https://www.joelonsoftware.com/">Joel on Software</a> </li><li><p><a href="http://www.paulgraham.com/articles.html">Essays (paulgraham.com)</a></p><p>有太多经典的技术文章。分别有中文的《Joel谈软件》和 《黑客与画家》。</p></li></ul><hr><ul><li><a href="https://eli.thegreenplace.net/">Eli Bendersky’s website (thegreenplace.net)</a></li></ul><p>这个博客已经有十多年了。我记得最初搜索到这个站点是自己在 2008 年做SICP的习题时，我发现这里有几乎 SICP 所有的习题答案，附带自己详细的解释。</p><p>难能可贵的是，作者 Eli Bendersky 一直坚持记录自己技术上的心得，这个博客持续在更新。而且他写的内容质量都非常高，既有理论又有实践和代码。例如他写的 Raft 系列： <a href="https://eli.thegreenplace.net/2020/implementing-raft-part-0-introduction/">Implementing Raft: Part 0 - Introduction</a>，简直就是技术写作的典范。</p><hr><ul><li><a href="https://flaviocopes.com/">Flavio Copes</a></li></ul><p>这个博客是一个意大利开发者维护的，内容偏向于前端和 Web 开发之类的。我欣赏这个站点是因为他几乎做到了每天都持续不间断写博客。有时候我想写有懒癌发作的时候，就会想到这位作者。他写的东西也许并不高深，但对很多人来说有用。我之前用 SEO 工具看过这个网站的数据，Google 带来的自然流量非常高。</p><p><a href="https://flaviocopes.com/developer-blog/">Every developer should have a blog. Here’s why, and how to stick with it</a><br><a href="https://flaviocopes.com/blog-seo/">I wrote 1 blog post every day for 2 years. Here’s 5 things I learned about SEO</a></p><hr><ul><li><a href="https://jvns.ca/">Julia Evans (jvns.ca)</a></li></ul><p>这个博客也是持续更新了近 10 年，涉及的领域及其广泛。这个作者深刻启发了我的观点是，通过搞懂内部原理来学习编程：<a href="https://jvns.ca/blog/learn-how-things-work/">Get better at programming by learning how things work</a>。当然还有很多其他类的技术类文章如：<a href="https://jvns.ca/blog/2014/12/14/fun-with-threads/">Diving into concurrency: trying out mutexes and atomics</a></p><p>而且作者做了很多技术相关的电子书，图文并茂：<br><a href="https://wizardzines.com/">wizard zines</a></p><hr><ul><li><a href="http://journal.stuffwithstuff.com/">journal.stuffwithstuff.com</a></li></ul><p>花 6 年时间，用工匠精神写一本编程语言实现的书是怎样一种体验？<br><a href="http://journal.stuffwithstuff.com/2020/04/05/crafting-crafting-interpreters/">Crafting “Crafting Interpreters”</a></p><p>在这里所有的图片都是用手画出来的，字体、颜色、对齐等，所有这些细节几乎都做到完美，最终成书可以称之为艺术品。一个技术书籍竟然能做到如此优美！</p><hr><ul><li><a href="https://www.swyx.io/">swyx’s site</a></li></ul><p>主要内容涉及开发、个人成长等。<br>其中 <a href="https://www.swyx.io/learn-in-public/">Learn In Public (swyx.io)</a> 这个概念对我有很大触动，这个博客还有很多 podcast 。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做技术这么多年，我订阅了很多英文技术站点。这里介绍一些我认为非常值得关注、学习的技术站点。我推荐的标准是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;持续多年更新&lt;/li&gt;
&lt;li&gt;质量非常高，或者某些文章深刻地启发了我&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后面我会长期更新这个列表：&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="编程" scheme="http://chenyukang.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>百度是如何死掉的</title>
    <link href="http://chenyukang.github.io/2021/12/27/baidu-die-for-reason.html"/>
    <id>http://chenyukang.github.io/2021/12/27/baidu-die-for-reason.html</id>
    <published>2021-12-27T07:02:34.000Z</published>
    <updated>2021-12-29T01:01:47.908Z</updated>
    
    <content type="html"><![CDATA[<p>让我重新思考这个问题的是一件小事。</p><p>我有一个英文小站点，写了一些技术类的文章。这一年来已经有一些稳定的流量，大部分都是从Google来的。我曾经学了点 Amazon 推广的东西，把几篇文章的链接换成了亚马逊的推广链接，然后每个月都能从亚马逊收到一笔小钱，数额大概 10 来块美金吧。</p><p>这个数额很小，但是这种模式确实就是很多中小网站的盈利模式。有的站点能做到几万美金一个月。 对于他们来说，有高质量的内容就能从 Google 得到流量，流量就能通过各种方式兑换成钱。所以这些内容创作者就会不断创造高质量的内容，争取能做到 Google 的搜索排名靠前。</p><p>Google 和百度类似，都是属于互联网上的信息中间商。作为中间商最重要的是<strong>信任</strong>，用户相信在 Google 上能找到<em>可靠的、高质量的内容</em>。内容创作者相信高质量的内容可可以通过 Google 吸引到用户。这样就形成了一个正向闭环。</p><p>百度这些年来渐渐的沦为互联网公司的度量单位，一个原因是没有拿到移动互联网的门票，另一个更根本的原因就是丢掉了自己根本的盈利模式。因为过于短视，竭泽而渔做竞价排名，最终破坏了这种用户、内容创作者对百度的信任。魏则西事件后大众对百度口诛笔伐，而一些高质量的中文内容站点，比如 <a href="https://coolshell.cn/articles/9308.html">CoolShell</a> 从来不期望百度能带流量，而且做了anti-baidu 插件来提醒读者不要使用百度。你要是想在百度上查个什么病，看几页搜索结果就会觉得自己命不久矣。</p><p>结果就是中文的高质量内容越来越少，用户搜索分割到了各个垂直领域的 App。这些 App 可没那么好心，直接对搜索引擎是封闭的，比如微信公众号，整个就是一个大的封闭生态。</p><p>除了百度的一些核心高管，外界估计无法知晓为什么百度会坚持做竞价排名。也许这东西就像是毒品一般，用上了之后就在资本的压力下再也无法回头。百度这些年来转头做 AI，作为普通用户我也是不看好的。这些年所有百度的产品能绕开就坚决不用，少给自己添麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让我重新思考这个问题的是一件小事。&lt;/p&gt;
&lt;p&gt;我有一个英文小站点，写了一些技术类的文章。这一年来已经有一些稳定的流量，大部分都是从Google来的。我曾经学了点 Amazon 推广的东西，把几篇文章的链接换成了亚马逊的推广链接，然后每个月都能从亚马逊收到一笔小钱，数额大
      
    
    </summary>
    
    
      <category term="胡写" scheme="http://chenyukang.github.io/tags/%E8%83%A1%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>编译 WebAssembly 模块</title>
    <link href="http://chenyukang.github.io/2021/12/16/compiling-to-wasm.html"/>
    <id>http://chenyukang.github.io/2021/12/16/compiling-to-wasm.html</id>
    <published>2021-12-16T07:02:23.000Z</published>
    <updated>2021-12-29T01:01:47.908Z</updated>
    
    <content type="html"><![CDATA[<p>最近一年经常接触了 WebAssembly , 我把一些老的 C/C++ 代码通过 <a href="https://emscripten.org/docs/getting_started/downloads.html">emcc</a> 编译为 wasm 模块，也可以把 Rust 代码编译为 wasm。</p><p>这里做一个简单的总结，以及我在编译过程中碰到的问题。</p><h2 id="WebAssembly-的优势"><a href="#WebAssembly-的优势" class="headerlink" title="WebAssembly 的优势"></a>WebAssembly 的优势</h2><p><img src="/images/ob_pasted-image-20211215191320.png" alt="/images/ob_pasted-image-20211215191320.png"></p><p>WebAsembly 定义了一个<a href="https://www.wasm.com.cn/docs/portability/">可移植</a>、体积小、加载快的<a href="https://www.wasm.com.cn/docs/mvp/#binary-format">二进制格式</a>作为编译结果。通过充分发挥通用硬件的能力（包括<a href="https://en.wikipedia.org/wiki/Mobile_device">移动设备</a>以及<a href="https://en.wikipedia.org/wiki/Internet_of_Things">物联网</a>），使其在大多数平台上能达到原生的执行效率。借助 wasi，WebAssembly 还可能运行在服务端。WebAssembly 的目标包括：</p><ol><li>现有的 <a href="https://www.wasm.com.cn/docs/web/">Web 平台</a>完美结合并在其中运行：<ul><li>维护无版本、<a href="https://www.wasm.com.cn/docs/feature-test/">特性可测试</a>、向后兼容的 Web 演变过程；</li><li>和 JavaScript 执行在相同的语意环境中；</li><li>允许和 JavaScript 相互的同步调用；</li><li>严格遵守同源策略以及浏览器安全策略；</li><li>和 JavaScript 一样，可以访问相同的 Web API 去调用浏览器的功能；以及</li><li>定义一个可与二进制格式相互转化的人类可编辑的文本格式，并且支持查看源码的功能。</li></ul></li><li>被设计为也可以支持<a href="https://www.wasm.com.cn/docs/non-web/">非浏览器嵌入</a>的运行形式，这样就可能在某些场景下替代 Docker。</li></ol><h2 id="C-C-gt-wasm"><a href="#C-C-gt-wasm" class="headerlink" title="C/C++ =&gt; wasm"></a>C/C++ =&gt; wasm</h2><p>首先需要安装 Emscripten  SDK:<br><a href="https://emscripten.org/docs/getting_started/downloads.html">https://emscripten.org/docs/getting_started/downloads.html</a></p><p>移植一个 C/C++ 项目到 WebAssembly , 最简单的办法是把类似 gcc 命令换成 emcc，难点在于动态链接的第三方库，我们需要改成静态链接。一些常用的库已经被移植了，例如<em>libc</em>, <em>libc++</em> and <em>SDL</em>，这些我们不需要手动处理。不在 emcc 预装里的库，我们只需要在编译的过程中加一些额外的参数，例如我下面这个项目就用到了 PNG，JPEG 这些库：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">emcc -c dbgutil.c -o dbgutil.o<br>emcc -c qrtest.c -o qrtest.o<br>emcc -c decode.c -o decode.o<br>emcc -c identify.c -o identify.o<br>emcc -c quirc.c -o quirc.o<br>emcc -c version_db.c -o version_db.o<br>emcc -g -Oz --llvm-lto 1  -s STANDALONE_WASM *.o -o qrtest.wasm  -lm  -s USE_LIBJPEG -s USE_LIBPNG <br></code></pre></td></tr></table></figure><p>另外 emcc 编译出来的 wasm 模块默认只能做纯计算，没有网络、系统文件等。如果有系统调用则需要运行在浏览器中，用浏览器的接口来模拟某些 C 函数调用，例如 C 语言中的系统调用 <code>time</code> 在 emcc 中被替成为了 JavaScript  代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">clock: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (_clock.start === <span class="hljs-literal">undefined</span>) _clock.start = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">Date</span>.now() - _clock.start) * (&#123;&#123;&#123; cDefine(<span class="hljs-string">&#x27;CLOCKS_PER_SEC&#x27;</span>) &#125;&#125;&#125; / <span class="hljs-number">1000</span>))|<span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="Rust-gt-wasm"><a href="#Rust-gt-wasm" class="headerlink" title="Rust =&gt; wasm"></a>Rust =&gt; wasm</h2><p>Rust 是对 WebAssembly  支持得特别好的编程语言。我们可以使用 wasm-pack，或者安装 target:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">rustup target add wasm32-wasi<br></code></pre></td></tr></table></figure><p>然后在编译命令后面加参数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cargo build --target wasm32-wasi<br></code></pre></td></tr></table></figure></p><p>系统函数同样是个问题，有的第三方库可能会支持 wasm 格式，例如 <a href="https://docs.rs/getrandom/latest/getrandom/#webassembly-support">getrandom - Rust (docs.rs)</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://emscripten.org/">Main — Emscripten 3.0.1-git (dev) documentation</a><br><a href="https://marcoselvatici.github.io/WASM_tutorial/">WASM Tutorial (marcoselvatici.github.io)</a><br><a href="https://rustwasm.github.io/docs/book/">Introduction - Rust and WebAssembly (rustwasm.github.io)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一年经常接触了 WebAssembly , 我把一些老的 C/C++ 代码通过 &lt;a href=&quot;https://emscripten.org/docs/getting_started/downloads.html&quot;&gt;emcc&lt;/a&gt; 编译为 wasm 模块，也可以把 
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="WebAssembly" scheme="http://chenyukang.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>为什么要开源</title>
    <link href="http://chenyukang.github.io/2021/12/14/why-open-source.html"/>
    <id>http://chenyukang.github.io/2021/12/14/why-open-source.html</id>
    <published>2021-12-14T07:02:45.000Z</published>
    <updated>2021-12-29T01:01:47.916Z</updated>
    
    <content type="html"><![CDATA[<p>我 2010 年开始在 Github 上开源自己的代码。在 push 代码之前我根本没想过为什么。只是因我当时学了 git，而且我又觉得 Github 很方便，可以用来备份自己的代码。</p><p>而后我就参加工作了，在工作之余我还会写一些感兴趣的代码分享到 Github，没事也经常在上面瞎逛，找一些自己感兴趣的代码来学习。我自己写的博客后来现在都托管在 Github 上了。</p><p>没想到这么多年下来，在 Github 上玩开源已经成为自己的一种习惯、爱好和生活方式。近一年工作轻松些了，有更多时间投入在这上面 (忽略最近两个月的大量提交数据，因为有个自动脚本每天在同步笔记 😁)<br><img src="/images/ob_pasted-image-20211213171045.png" alt="/images/ob_pasted-image-20211213171045.png"><br>最近越发觉得，和这个世界交互、分享越多，就会有更多的可能性。这里分享一下开源的收获和感受。这里仅从开发者角度考虑这个问题，因为公司是否考虑是另外一个更复杂的事。</p><h2 id="自我提高"><a href="#自我提高" class="headerlink" title="自我提高"></a>自我提高</h2><p>我建议任何在学编程、想提高开发技能的人参与到开源活动中来。现在的软件开发已经过了刀耕火种，徒手编码的年代。现在软件开发需要复用大量已有的库和工具，大型软件开发是一种社会化的、集体性的智慧活动。在 Github 上分享代码，给其他开源项目做贡献，是最好的一种方式来练习这种编程能力、协作能力和复用已有代码的能力。在 Github 上混久了，就形成一种自然而然的<a href="https://github.com/chenyukang">做贡献的习惯</a>，在这里我们不只是使用者和消费者，也可以是创作者和贡献者，例如：</p><ul><li>我想学学 WebAssembly，所以找来一个 runtime 实现看看，顺便修复一些自己发现的<a href="https://github.com/wasmerio/wasmer/pulls?q=is%3Apr+is%3Aclosed+author%3Achenyukang">问题</a>。</li><li>我看到这个 Obsidian 插件有些缺陷，自己修一下然后和作者讨论一下<a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/issues/30">怎么完善</a>。</li><li>在使用 Rust 开发的时候，我看到了一些重复的警告。我在 Github 上一搜索发现别人也碰到过，然后花时间提 <a href="https://github.com/rust-lang/rust/pull/88493">PR 修复一把</a>。</li><li>我想看看 container 是怎么实现的，所以找来开源代码 <a href="https://github.com/containers/youki">containers/youki</a> 来学习，然后顺便修复自己<a href="https://github.com/containers/youki/pulls?q=is%3Apr+author%3Achenyukang+is%3Aclosed">发现的问题</a>，后来还成了 maintainer。</li></ul><p>在这个过程中我自己学到了很多，为开源做贡献属于<a href="https://wsvincent.com/working-in-public-book-review/">Working in Public</a>，也是<a href="https://www.swyx.io/learn-in-public/">Learn in Public</a>。强烈推荐这篇 Learn in  Public 的文章，这是一个改变了我的观念。Working in Public 的好处在于我们做的贡献可以算作能力的证明，参考刘未鹏十年前的<a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人 – 刘未鹏 | Mind Hacks</a>。这些年我换工作就碰到过认可我的代码，面试就是聊聊的公司。</p><h2 id="创造价值"><a href="#创造价值" class="headerlink" title="创造价值"></a>创造价值</h2><p>绝大多数代码不值钱。写代码的时候内心戏不要太多，自己几斤几两要有个数。纯代码不值钱，业务才能赚钱，所以代码得运行起来。如果分享出来的代码对别人有用，就能产生价值，产生价值就附带可以赚钱。</p><p>举个例子，我在自己看书《Enssential of Programming Language》的时候，一边学习一边把课后习题用代码实现了：<a href="https://github.com/chenyukang/eopl">my solutions to EOPL3 </a>。</p><p>这个代码如果一直留在我硬盘的某个角落，估计就是分文不值。我总不能把它当作传家宝留给我的后代。但是开源之后居然每年都会收到一些邮件咨询这方面的问题。因为这本书是国外一些大学的教材，他们学编程语言相关的课程就需要做这些编程题，还有一些课后项目。所以有的同学就付费让我咨询。对于我来说，我当然愿意一个小时能赚 2000 左右，这不比上班划算么。嗯，大学能出国的人有的还挺有钱。</p><p>当自己的成果帮助了其他人时，也能收获一些满足。</p><h2 id="更多可能"><a href="#更多可能" class="headerlink" title="更多可能"></a>更多可能</h2><p>一个例子，我分享了自己在学习数据结构和算法时实现的一个生成迷宫程序，然后还写了一些 A* 路径规划算法相关的文章。后来上海大学有个教授看到我的文章，问我能不能帮他们看个程序，他们需要在 1w 多个节点里面计算 k-th shortest 路径。我花了一些业余时间帮他们把核心算法用 C 实现了，他们后来把文章发表了出来，还把我的名字署上了：<a href="https://pubs.rsc.org/en/content/articlelanding/2013/mb/c3mb70089e#!divRelatedContent&amp;articles">Identification of hepatocellular carcinoma related genes with k-th shortest paths in a protein–protein interaction network</a>。</p><p>我可从来没想过自己会发表一篇分子生物类的文章。最近我也开始另一种副业，在 Github 上收费公司做开源。这就是分享的奇妙之处，我不知道自己的分享什么时候就帮助了别人，同时创造了更多的可能性。</p><p>这些如今牛逼的开源项目都是从最开始一个小的分享举动开始的，Linus 在分享自己的小 Kernel 时估计未曾想过整个操作系统行业被自己改变了，尤大在分享自己的前端成果时也未料到 Vue 会被这么多企业使用。</p><hr><p>最后，特别推荐这两期播客 : <a href="https://avocadotoast.typlog.io/episodes/opensource">和 Vue.js 的创造者尤雨溪聊开源软件</a>。另外可以听听这期<a href="https://bytetalk.fm/posts/episode-6/">跟 Anthony Fu 聊聊全职开源和他的故事</a>，有些开发者已经实现了全职做开源这种工作形态。</p><p>而且现在国内开始出现了一波用开源软件赚钱的公司，比如 Pingcap，TDengnine 等。这是个很好的趋势，让我们这些本身喜欢写代码的除了 996 之外有了更多选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我 2010 年开始在 Github 上开源自己的代码。在 push 代码之前我根本没想过为什么。只是因我当时学了 git，而且我又觉得 Github 很方便，可以用来备份自己的代码。&lt;/p&gt;
&lt;p&gt;而后我就参加工作了，在工作之余我还会写一些感兴趣的代码分享到 Github
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="OpenSource" scheme="http://chenyukang.github.io/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>为什么印度人占领了硅谷</title>
    <link href="http://chenyukang.github.io/2021/12/12/why-indian-lead-silicon-valley.html"/>
    <id>http://chenyukang.github.io/2021/12/12/why-indian-lead-silicon-valley.html</id>
    <published>2021-12-12T07:02:34.000Z</published>
    <updated>2021-12-29T01:01:47.916Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间 Twitter 也换了 CEO，还是一个印度裔。目前，硅谷的很多大的 IT 公司的 CEO 位置都被印度裔占了，包括 Google，Microsoft，IBM，Adobe, Palo Alto Network , VMWare 等老牌 IT 巨头。这种现象逐渐成为西方媒体也在讨论的 <a href="https://www.bbc.com/news/world-asia-india-59457015">The Indian CEO Phenomenon</a>。</p><p>从我个人的经历来说，我毕业后所工作的第一家公司，在创业六年后被硅谷的印度人公司收购了，而后我继续在里面做了一年。目前工作的微软也是印度裔 CEO，工作中也接触不少印度同事。</p><p>对于这个现象，个人认为主要原因有这些：</p><h3 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h3><p>很多印度裔技术人员早年都在印度上完大学。因为印度有种姓制度，社会阶层明显。能在印度上大学的大多家庭条件和阶层都不错。我 2015 年在硅谷出差时，有段时间经常蹭印度同事的车，所以会聊得比较多日常。他吐槽说跑到美国后更累了，因为在印度家里有好几个佣人，过得是饭来张口的生活😃。</p><p>印度的 STEM 氛围比较重，工程师算得上是一个受人尊重的职位。看过《三傻大闹宝莱坞》的可能对此有些印象。从目前印度的高考情况来看，最热门的科目也是理工科，入学门槛是最高的学科。像印度理工学院这种顶尖学校，入学难度堪比麻省理工。印度好的理工学校，很多学生毕业后就去美国继续上学、工作。</p><p>因此，我们看到的去美国的印度工程师，其实也和中国类似，经过了好几轮教育体制的筛选，智力、学习能力大多都是不输中国人的。</p><p>另外技术能力对于做 Leader 岗位来说，只是其中一个维度。在人数众多的 IT 公司中，领导岗位犹如部队的率领，也许枪法不是最好的，更重要的是能带队伍，做正确决策的综合能力。很多印度人出于职业发展上的考虑，喜欢上商业类的双学位课程，像 MBA 这类第二学位。当大部分都是技术上出众的时候，那么同时具备商业嗅觉、宏观判断力的人就容易突出。Google CEO 的 Sundar Pichai ，当年作为 PM 领导了 Google Chrome ，Google Drive 等明星产品。微软的 Satya 上台后让微软这个已经落寞多年的昔日巨头重新焕发新生。</p><h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><p>在公司能踏实做事固然很重要，但如果要走向管理岗，不太会表达就是个大问题。</p><p>在 IT 行业工作的印度程序员，基本都能很流利地用英语表达。日常搜索中我们经常碰到的 geekforgeeks 这种网站很多都是印度人做的。</p><p>很多印度人说出来的口语口音很重（部分阶层更高的印度人从小接受英语教育，所以口音更纯正一些）。典型的印度口音就像是这个 <a href="https://www.youtube.com/watch?v=_IOZ8_cPgu8">视频</a> 里一样。但是这不是一个大问题，欧洲的、俄罗斯的、世界各地的非英语母语国家的人说英语都是由口音的。对于母语是英语的听众来说，有口音大多不影响理解。就像是国内北京人来听带山东、湖南口音的普通话，这完全是没有什么障碍的。而中国的技术人员很多是应试教育的受害者，高考后荒废几年，很多人英语阅读撰写都成问题，更不用说开口说话。这种现象在我这个年龄段 (80 后）中还比较突出，总体感觉 90、00 后相对来说口语会好一些。</p><p>英语表达的流畅是个问题，更重要的是沟通的意愿。很多中国人相对害羞，表达方式内敛、含蓄，东西方这种表达方式上的偏差会在职场上造成巨大影响。所以实际上，韩国、日本能在欧美企业中做到顶尖的也少。</p><h3 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h3><p>东方文化中推崇“凡事不做出头鸟”，中国人工程师大多比含蓄和谦虚，自己做了 120 分可能才敢说出 100 分。中国传统文化中，我们推崇那种扫地僧，默默地做技术大牛，在技艺上做到顶尖，而在很多公司决策上、公共事务上成为”沉默的大多数“。这对于美国人是比较陌生的，美国人沟通倾向于直接明、强势自信的。</p><p>另一方面，传说“公司来了一个印度人，接下来会有另一个，过段时间就是一群”。硅谷的印度人对自己族裔相互提携，非常抱团。在美国工作了三十年的前老板跟我提到过，华人里面其实暗地里相互的较劲很多，特别是同级别之间。文人相轻自古以来都有，中国过去的很多是千军万马独木桥走过的做题家，在这狭窄的技术路线上容易引起竞争。攀比、嫉妒等会造成很大内耗，这种精神糟粕很难克服，需要自己从一种第三方视角反思、不断实践才行。</p><h3 id="国情"><a href="#国情" class="headerlink" title="国情"></a>国情</h3><p>近二十年来，因为中国人口基数红利，中国基础设施的完善，互联网对中国各个行业的渗透，国内 IT 行业迅速崛起。机会和资本都不缺，这些年来对于顶尖人才的待遇不输美国。在美的很多技术人员都犹豫过是否回国。现实也是，很多优秀的、有更大抱负的中国人放弃了在美国职场爬的路径，选择回国创业或加入国内大公司，导致留在美国的倒是很大比例是想安稳住大豪斯过个小日子的。</p><p>对于印度人而言，在一个好的理工学校毕业，然后去美国赚钱、发展，这是非常理想的，几乎是唯一好的出路。因为印度本土发展落后太多，生活形态和质量也差很多。留下来扎根的人，自然有些渐渐就爬上去了。</p><hr><p>以上纯是些个人感受和理解，或许和实际情况存在一些偏差。</p><p>其实我们也没必要过于纠结在这点上。总体而言，这些年来中国在 IT 领域取得了美国之外的最大成就。我们有自己的 IT 巨头，有很华人创办了成功的创业公司，例如 Zoom、Notion 等等。</p><p>反思才能让人成长，共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间 Twitter 也换了 CEO，还是一个印度裔。目前，硅谷的很多大的 IT 公司的 CEO 位置都被印度裔占了，包括 Google，Microsoft，IBM，Adobe, Palo Alto Network , VMWare 等老牌 IT 巨头。这种现象逐渐成为
      
    
    </summary>
    
    
      <category term="瞎写" scheme="http://chenyukang.github.io/tags/%E7%9E%8E%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>什么是好的技术面试</title>
    <link href="http://chenyukang.github.io/2021/12/08/the-good-tech-interview.html"/>
    <id>http://chenyukang.github.io/2021/12/08/the-good-tech-interview.html</id>
    <published>2021-12-08T09:11:49.000Z</published>
    <updated>2021-12-29T01:01:47.912Z</updated>
    
    <content type="html"><![CDATA[<p>今天正好看到两个技术面试相关的分享。结合自己这十年来的面试或者被面试经历，谈谈自己的想法。</p><h2 id="难得的面试分享"><a href="#难得的面试分享" class="headerlink" title="难得的面试分享"></a>难得的面试分享</h2><p>首先我们来看看 ReactJs 核心开发 Dan Abramov 的面试视频。这不算是正式的面试，是一个 Youtube 主播和 Dan 进行的模拟面试。<a href="https://www.youtube.com/watch?v=XEt09iK8IXs">Coding Interview with Dan Abramov - YouTube</a></p><p><img src="/images/ob_pasted-image-20211206220156.png" alt="/images/ob_pasted-image-20211206220156.png"><br>这个面试将近持续了一个小时，但是主要是后面的那个算法题耗费时间，前面几个问题都是很八股的前端面试题：</p><ol><li>let 和 const 区别</li><li>什么时候使用 redux</li><li>dangerouslySetInnerHTML 是什么，该怎么用</li><li>把一个 div 居中</li><li>把一个 binaryTree 镜像翻转</li><li>Bonus Q: 一个找兔子的算法题，兔子出现在数组的某个位置，但是每次可以跳向相邻的位置，用最快的办法找到兔子的位置。</li></ol><p>这里面有意思的点是：</p><blockquote><p>Ben: There is a library called ‘redux’<br>   Dan: “Hmmmm heard about it”</p></blockquote><p><code>Redux</code> 最初版本是 dan 2015 年发布的……..  面试官小哥羞涩地笑了 🤣</p><p>然后，把 div 居中算是前端中的经典梗了，Dan 花了好一会时间在面试官的提示下才把一个 div 居中。如果对方不是 React 核心开发，手熟的前端可能就会开始鄙视这位“初级前端”了。这让我这种一直觉得 css 很难的前端学习者觉得信心大增。</p><p><img src="/images/ob_pasted-image-20211206221155.png" alt="/images/ob_pasted-image-20211206221155.png"></p><p>反转二叉树问题 dan 很快就答出来了，但是从面试过程中可以看到他对怎么尽量少代码 swap 两个变量还想了一会儿。我后来看他的十年总结的博文中，职业生涯初期的一次面试也提到了这个点:</p><blockquote><p> At one point I freaked out and panicked because I couldn’t write three lines of code that swap two items in an array. I asked Jing to look away for a few seconds. She said “I know you can swap two items”, and that gave me the confidence to finish the answer and make it through the interview. I probably didn’t pass with flying colors, but I got the offer.</p></blockquote><p>最后一个算法题比较新颖，这不算红黑树式的八股算法题，倒像是一个 IQ 测试题目。可以看出 dan 也很少碰这类算法题。他花费了近半个小时在面试官的提示下，按照自己的直觉一步一步推出了答案。但是他最后写的代码是有点小问题的(没有用 2 来递增 index)，面试者看他思路是对的也没有指出来了。这里可以看到，其实结果可能并不重要，而是在解决这问题中所展现出来的思维方式方法很重要。</p><p>除去 Bonus Question，可以说这轮面试的题目大多比较常规，难度小于很多国内外大厂的面试。dan 作为前端大咖，愿意参加这样的直播分享很难得。我感觉看到的是一个真实的工程师，在未做过八股训练情况下的真诚表现。</p><p>这是今晚看到的另外一个面试分享， <a href="https://github.com/yihong0618/gitblog/issues/228">经历了人生体验最棒的一次面试 · Issue #228 · yihong0618/gitblog (github.com)</a>：</p><p><img src="/images/ob_pasted-image-20211206232729.png" alt="/images/ob_pasted-image-20211206232729.png"></p><p>我觉得比较难得的是第一面面试官的面试方式，选择一个面试者的开源项目，然后提一个小需求让他实现。这得很花面试官的心思和时间，也确实能很好地考察应聘者的编程能力和工程能力。国内这种认真面试的公司太少太少，而且一线大厂几乎不可能出现这种面试方式。</p><h2 id="我的一些经历"><a href="#我的一些经历" class="headerlink" title="我的一些经历"></a>我的一些经历</h2><p>在我十年的职业生涯中，经历过多次技术面试，作为应聘者被面试或者面试他人。</p><p>我经历过的最差的面试体验是在 2014 年。面试官没怎么看我的简历，首先让我挑两个主题，然后我能看到他在屏幕前点了点鼠标，从题库中挑选了几个题甩给我。这种感觉就是高中时候的考试体验，我需要在纸上写程序和公式。面试官全程严肃无表情，即使我主动需求交流也无果。这次面试可以说是深深地伤害了我，并给了我很大的心理阴影，导致我后来面试就会忍不住祈祷千万别再碰到这类面试官。</p><p>一些小而美的技术公司倒是更尊重应聘者。</p><p>前两年我参加过一个新加坡小外企的招聘。首先第一轮面试是双方自我介绍，对方会和我聊他们公司的主要业务和技术栈，以及目前这个岗位的工作内容和职责，确定我感兴趣之后才会约第一轮技术面试。第一轮面试就是一个小的项目，需求都写清楚，但其中也留了一下自由发挥的空间。我一周的时间来完成，然后把代码发过去。第二轮技术面试首先是从那个小项目聊，为什么这么写等等，然后会引出一些技术问题，但是会从深度和广度不断地追问下去。</p><p>面试的难点在于，很难在短时间内了解这个人的全部技能和特点。这些包括编程能力，工程能力，技术视野，沟通能力，应对挑战的能力等。</p><p>刘未鹏曾经在<a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人</a>中提到，用 Github 和书单的方法来面试。这当然是一个不错的面试方法。而大公司采用比较标准的面试，主要是为了节省时间。因为应聘者多，面试的场次多，不可能让面试官在工作之余花大时间主动了解应聘者。通常情况是面试官在面试之前匆匆扫上一眼简历。而且八股文式的面试很容易让面试官得出结论，即使这个结论充包含了不少偶然性因素。</p><h2 id="算法有什么用"><a href="#算法有什么用" class="headerlink" title="算法有什么用"></a>算法有什么用</h2><p>面试造火箭，入职后拧螺丝是行业常态。这也说明，我们工作中极少极少去碰这些基础算法类的东西。工作久了，我能看到很多面试官拿出一个公司的面试题，在不看答案的情况下自己也做不出来。</p><p>算法又是很多程序员所惧怕和不擅长的部分。Programming Pearls(《编程珠玑》)一书的作者 Jon Bentley 曾经说过：“90%的程序员无法正确实现二分查找算法…”。2014 年我在广州参加一个技术聚会上，因为一个一时兴起的赌局验证过这点。当时我们那个会议室 20 多个程序员，其中有工作多年的，也有刚毕业没多久的，能在规定时间写出一个无 bug 的二分查找的寥寥无几。</p><p>那面试出这种题目有何意义？</p><p>算法当然对程序员很重要，特别是在学校阶段，大量地实现数据结构和算法就是一种很好的提高编程能力的方法。我在学校最后一年刷了 POJ 500 道算法题，自我感觉编程能力大幅提高。</p><p>但我认为面试中的算法题可以当作一个下限标准，使用相对基础的、简单的编程题，会有助于筛选出编程能力不适合的应聘者。另外来自实际工作中的一些算法问题也是很好的面试题，比如上次我碰到的<a href="http://chenyukang.github.io/2021/11/29/input-complement-algorithm.html">输入自动补全算法</a>。这种问题没有唯一解，而且也很容易理解实现，通常有一定编程经验的程序员都可以实现出自己的版本。</p><p>较难的、八股式的算法题对于初步筛选不太有用。一个应聘者如果能很快答这种题，可能是他刷 LeetCode 比较多，或者是刚好之前碰到过这个题。</p><p>对于绝大部分岗位来说，算法题测试不适合当作上限标准，因为专门训练过的应聘者和没训练过的差别太大。对于资深的应聘者，往往只能通过以往的项目来考察深度和广度。我认为深度比广度重要，因为如果一个人能把某个领域做得很深，如果他花时间换个领域很可能会做得好，反之则不然。很多时候，面试官在某个领域没有应聘者熟悉。能让应聘者像老师一样把某个东西讲明白就很能考察对方的沟通能力。</p><h2 id="好的技术面试"><a href="#好的技术面试" class="headerlink" title="好的技术面试"></a>好的技术面试</h2><p>最后，我认为好的技术面试有如下特点：</p><ol><li>对应聘者尊重，在面试过程中是一种平等的沟通和交流</li><li>不要浪费应聘者的时间和精力</li><li>拒绝八股，更多考察实际解决问题的能力</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天正好看到两个技术面试相关的分享。结合自己这十年来的面试或者被面试经历，谈谈自己的想法。&lt;/p&gt;
&lt;h2 id=&quot;难得的面试分享&quot;&gt;&lt;a href=&quot;#难得的面试分享&quot; class=&quot;headerlink&quot; title=&quot;难得的面试分享&quot;&gt;&lt;/a&gt;难得的面试分享&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="面试" scheme="http://chenyukang.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian 插件开发</title>
    <link href="http://chenyukang.github.io/2021/12/02/obsidian-plugin-dev.html"/>
    <id>http://chenyukang.github.io/2021/12/02/obsidian-plugin-dev.html</id>
    <published>2021-12-02T07:17:37.000Z</published>
    <updated>2021-12-29T01:01:47.912Z</updated>
    
    <content type="html"><![CDATA[<p>昨天花了点时间下学习 Obsidian 的插件开发。我想了一下目前自己有点不爽的是图片插入的时候，图片的名称中间有空格，这虽然也不是什么大问题，只是在 Linux 环境下显示的时候看起来特别别扭。而且这看起来也是一个很好的入门小插件，可以接触 Obsidian 里面的文件管理和编辑操作，我需要把图片在文件系统里的名称改掉，也要修改 markdown 里的路径。</p><p>所有代码都在这里了： <a href="https://github.com/chenyukang/obsidian-rename-image">chenyukang/obsidian-rename-image (github.com)</a>。</p><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li>从 plugin sample repo 克隆一个仓库</li><li>修改其中的 manifest.json 文件，其中 plugin id 是最重要的。</li><li>修改主文件 main.ts，使用 <code>npm install</code> 安装依赖库</li><li>使用命令 <code>npm run dev</code>  编译出 main.js </li><li>在 Obsidian  的 vault 目录 .obsidian/plugins/ 创建一个插件名称的文件夹，拷贝 manifest.json  和 main.js 到该目录，有的插件可能还有 style.css 等文件。</li><li>在 settings 页面加载插件</li></ol><p>在开发过程中，可以通过 <code>Ctrl-Shift-i</code> 来打开调试页面，在代码中加入调试信息。</p><h3 id="API-相关"><a href="#API-相关" class="headerlink" title="API 相关"></a>API 相关</h3><p>在插件项目里执行了 <code>npm install</code> 之后，文件 <code>node_modules/obsidian/obsidian.d.ts</code> 就是 Obsidian 的 API ，里面有很详细的注释。</p><p>作为补充可以看看 <a href="https://liamca.in/Obsidian+API">Obsidian API - Liam Cain</a>。API 分为这几个主要部分。</p><p><img src="/images/ob_pasted-image-20211201194355.png" alt="/images/ob_pasted-image-20211201194355.png"></p><p>其中文件编辑部分使用了这个<a href="https://codemirror.net/">CodeMirror</a>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之前有那么一会我会想，Obsidian 这样一个软件为什么不开源？如果开源我们是不是可以做更多的自由探索。通过折腾插件这么一段体验，我认为不开源问题也不大，其实通过插件我们其实可以在插件里面跑任何自己的代码。这里面的可扩展性对于绝大部分用户来说绰绰有余。</p><p>一个技巧是多看看已有的插件是如何实现的。打开 Settings 页面的 community plugins，选择某个感兴趣的插件看看里面的代码：<br><img src="/images/ob_pasted-image-20211203110506.png" alt="/images/ob_pasted-image-20211203110506.png"></p><p>Obsidian 模块化做得很好，而且 API 的粒度很细。在 VsCode 中写 TypeScript 插件体验比在 Emacs 中写 elisp 开发插件好很多，并且 JavaScript 的相关文档可太丰富了。</p><p>所以，真没必要抱着上古时代的软件不放 😁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天花了点时间下学习 Obsidian 的插件开发。我想了一下目前自己有点不爽的是图片插入的时候，图片的名称中间有空格，这虽然也不是什么大问题，只是在 Linux 环境下显示的时候看起来特别别扭。而且这看起来也是一个很好的入门小插件，可以接触 Obsidian 里面的文件管
      
    
    </summary>
    
    
      <category term="工具" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="obsidian" scheme="http://chenyukang.github.io/tags/obsidian/"/>
    
      <category term="TypeScript" scheme="http://chenyukang.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Sidecar 架构模式</title>
    <link href="http://chenyukang.github.io/2021/12/01/sidecar-design-pattern.html"/>
    <id>http://chenyukang.github.io/2021/12/01/sidecar-design-pattern.html</id>
    <published>2021-12-01T07:17:38.000Z</published>
    <updated>2021-12-29T01:01:47.912Z</updated>
    
    <content type="html"><![CDATA[<p>如果你最近经常看一些技术型的文章，可能会看到这个技术名词：Sidecar 模式。中文译名为：挎斗模式。这个名字为直译，挎斗就是这样的一种摩托车：</p><p><img src="/images/ob_2021-11-30-12-57-48.png" alt="/images/ob_2021-11-30-12-57-48.png"></p><p>如果理解了这种模式，就会明白这个名字其实取得特别好。Sidecar 模式就是指在原来的业务逻辑上再新加一个抽象层。这种模式很好的印证了那个计算机的名言：</p><blockquote><p> “计算机科学领域的任何问题都可以通过增加一个简介的中间层来解决。”</p><p>“Any problem in computer science can be solved by another layer of indirection.”</p></blockquote><p>如果一个抽象层不够，那来两个。这种模式也不是近些年新发明的，我们可以理解 Nginx 的反向代理其实也算一种 sidecar 模式。只是近些年，随着微服务和容器化在实践中越来越多，这种模式的使用范围也更广了。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在微服务架构中，如果应用多了就会形成一些共有的需求。特别是流量控制方面，包括限流、流量分发和监控、灰度等等。通常我们对一类需求可以实现一个抽象层，然后在这个抽象层上实现具体的业务逻辑。比如很多公司都有服务网关，然后使用各种语言的 SDK 来集成到应用中。</p><p><img src="/images/ob_pasted-image-20211130163700.png" alt="/images/ob_pasted-image-20211130163700.png"><br>这是通常我们会选择的一种方式，这过程中会有这样的一些问题需要考虑：</p><ol><li>SDK 的维护成本是很高</li><li>SDK 集成到代码中，其中一个组件发生故障就可能会影响到其他组件，SDK 和应用程序之间是保持着相互依赖的关系的。</li></ol><p>在应用层和基础服务没有解耦的情况下，我们对基础服务做改动会增加很多风险和复杂度。例如，我之前所在的部门整个电商的应用做灰度改造，所有应用都需要做对应的改动。</p><h2 id="sidecar-架构"><a href="#sidecar-架构" class="headerlink" title="sidecar 架构"></a>sidecar 架构</h2><p>那我们是否可以提供一个统一的抽象层来做这些基础的重复工作？将基础服务抽象、解耦到应用层都感知不到的程度？</p><p>这是现在的趋势，特别是现在很多架构都跑在容器这样的环境了，统一的抽象层能大大减少架构上的复杂度。 sidecar 模式在不改变主应用的情况下，会起来一个辅助应用，来辅助主应用做一些基础性的甚至是额外的工作。这个 sidecar 通常是和主应用部署在一起，所以在同样的运行环境下。这其中还有一些性能上的考虑，sidecar 如果和主程序网络通信上有延迟就会造成性能问题。例如在 K8s 下一个 pod 里的所有子应用共享一个 sidecar 服务。</p><p>这个辅助应用不一定属于应用程序的一部分，而只是与应用相连接。这就像是挎斗摩托车，每个摩托车都有自己独立的辅助部分，它随着主应用启动或停止。因为 sidecar 其实是一个独立的服务，我们可以在上面做很多东西，例如 sidecar 之间相互通信、或者通过统一的节点控制 sidecar ，从而达到 Service Mesh。</p><p><img src="/images/ob_sidecar-mode-20211130170923.png" alt="/images/ob_sidecar-mode-20211130170923.png"></p><p>这样的好处在于：</p><ol><li>应用层和基础服务层解耦</li><li>基础服务统一维护，SDK 统一集成，减少复杂度，减少应用服务中的重复部分</li><li>可以在不改变原有应用的情况下，为应用扩展新的功能</li></ol><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>我们可以来看看业界典型的使用 sidecar 模式的框架。</p><h3 id="DAPR"><a href="#DAPR" class="headerlink" title="DAPR"></a>DAPR</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/architecture/dapr-for-net-developers/dapr-at-20000-feet">Dapr: Distributed Application Runtime</a> 是微软开源的一套分布式程序开发框架，其目标是：“Build distributed applications with any language, any framework, run anywhere”。既然任何编程语言，任何框架都要支持，sidercar 是一个必然的选择。DAPR 把很多常见的分布式程序的公共组件抽象出来成为’building blocks’，然后通过 gRPC 或者 HTTP 统一出接口。应用程序通过 sidecar 来访问。</p><p><img src="/images/ob_pasted-image-20211130172044.png" alt="/images/ob_pasted-image-20211130172044.png"><br>这样多了一层抽象之后，即使是某个 Component 做了一些改变，应用层也是无感知的。除了在容器化的环境下运行，用户也可以在非容器化环境以 sidecar 模式启动任何应用，例如我们启动一个图片接口服务 <code>image-api-service</code>，该服务会监听端口 8080，而 sidecar 会通过 3500 端口来代理该服务接受请求：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">dapr run --app-id image-api \<br>         --app-protocol http \<br>         --app-port 8080 \<br>         --dapr-http-port 3500 \<br>         --components-path ../config \<br>         --log-level debug \<br>         ./image-api-service<br></code></pre></td></tr></table></figure><p>其他服务组件可以通过 sidecar 去请求该服务：</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Dapr api format: http://localhost:&lt;daprPort&gt;/v1.0/invoke/&lt;appId&gt;/method/&lt;method-</span><br>uri = <span class="hljs-string">&quot;http://localhost:3500/v1.0/invoke/image-api/method/api/image&quot;</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>, uri, bytes.NewBuffer(image))<br></code></pre></td></tr></table></figure><h3 id="lstio"><a href="#lstio" class="headerlink" title="lstio"></a>lstio</h3><p><a href="https://istio.io/latest/zh/about/service-mesh/">Istio 服务网格</a> 是一个开源的服务网格，提供了统一的方式来实现连接、监控、负载均衡等公共服务和流量管理。单个服务的所有传入和传出网络流量均通过 Sidecar 代理，完成微服务之间的流量管理、遥测数据收集以及策略的执行等。</p><p><img src="/images/ob_pasted-image-20211130173530.png" alt="/images/ob_pasted-image-20211130173530.png"></p><p>在 lstio 中，我们需要了解 Data Plane 和 Control Plane 两个概念——  </p><ul><li>Data Plane 的作用是处理网格内服务间的通信，并完成服务发现、负载均衡、流量管理、健康检查等功能；数据平面的作用是处理网格内服务之间的通信，并负责实现服务发现、负载平衡、流量管理、健康检查等功能；</li><li>Control Plane 的作用是管理和配置 Sidecar 来执行策略并收集遥测</li></ul><p>lstio 中使用了 Lyft 开源的 Envoy 来做流量代理，Envoy 和应用程序一起在一个独立的进程中运行，应用与 localhost 收发信息，对网络的拓扑结构无感知。</p><h2 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h2><ul><li>更适合在容器化的环境使用</li><li>简单系统就没有必要使用这种重型武器了</li><li>哪些部分可以放到 sidercar 里面需要慎重考虑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你最近经常看一些技术型的文章，可能会看到这个技术名词：Sidecar 模式。中文译名为：挎斗模式。这个名字为直译，挎斗就是这样的一种摩托车：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ob_2021-11-30-12-57-48.png&quot; alt=&quot;/image
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="架构" scheme="http://chenyukang.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>在 Github Action 使用 Git</title>
    <link href="http://chenyukang.github.io/2021/11/30/using-git-in-github-action.html"/>
    <id>http://chenyukang.github.io/2021/11/30/using-git-in-github-action.html</id>
    <published>2021-11-30T07:17:46.000Z</published>
    <updated>2021-12-29T01:01:47.916Z</updated>
    
    <content type="html"><![CDATA[<p>最近我把自己的一些自动化脚本移到了 Github Action。因为考虑到 Github Action 有下面几个优势：</p><ol><li><p>自动化脚本是代码的一部分 (Infrastructure as Code)，而不是限定在某个服务器上。这样长久来说更为通用，如果我迁移到其他服务器根本不用做什么修改，因为我们在写 Github Action 的脚本的时候就不假定在哪台服务器上运行。</p></li><li><p>配置更为方便，想要修改一下只需要提交配置文件就可以了，不用登录到服务器上。</p></li></ol><p>基于以上几点考虑，我花了一些时间来把之前的一些 Ruby、Shell 脚本变成 Github Action 配置。有的脚本做的事情是定时拉去某个 repo，如果有改动则会根据规则生成新的内容，然后自动提交到远程仓库。所以我需要在 Github Action 中使用 Git 提交数据。要达到这个目的得在 Github 中配置 Git 的权限和账户信息。有以下两种方式：</p><h2 id="使用-Github-Access-token"><a href="#使用-Github-Access-token" class="headerlink" title="使用 Github Access token"></a>使用 Github Access token</h2><p>首先需要在 Settings 页面生成一个 Access Token. 然后添加到要配置 Github Action 的仓库的 Settings 页面中，假设我的 token 取名为<code>PAT</code>，在 Action 中我们可以通过 <code>secrets.PAT</code> 获取和使用该 Token。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">sync-to-sites:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Git</span> <span class="hljs-string">Clone</span> <span class="hljs-string">and</span> <span class="hljs-string">Global</span> <span class="hljs-string">Config</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # Git setup</span><br><span class="hljs-string">          export GITHUB_USER=yukang</span><br><span class="hljs-string">          echo &quot;GITHUB_USER=$GITHUB_USER&quot; &gt;&gt; $GITHUB_ENV</span><br><span class="hljs-string">          echo &quot;GITHUB_TOKEN=$&#123;&#123; secrets.PAT &#125;&#125;&quot; &gt;&gt; $GITHUB_ENV</span><br><span class="hljs-string">          git config --global user.email &quot;moorekang@gmail.com&quot;</span><br><span class="hljs-string">          git config --global user.name $GITHUB_USER</span><br></code></pre></td></tr></table></figure><p>然后通过如下方式 clone 要修改的 repo 到跑 action 的服务器目录上。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">checkout</span> <span class="hljs-string">blog</span><br>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span><br>  <span class="hljs-attr">with:</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">chenyukang/blog-source</span><br>    <span class="hljs-attr">token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.PAT</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">blog-source</span><br></code></pre></td></tr></table></figure><p>这种通过 Access Token 的方式 clone repo，用的是 HTTPS 的方式。通过 <code>git remote -v</code> 查看可以看到 remote 的地址。</p><h2 id="使用-SSH"><a href="#使用-SSH" class="headerlink" title="使用 SSH"></a>使用 SSH</h2><p>另外一种方式是通过 ssh key。我们首先在任何一个服务器生成一个 ssh key，把这个 ssh 的 public key 加入到 Github settings 里。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>然后把私钥拷贝到要配置 Action 的 repo 的 secrets 里。</p><p>通过如下方式在 action 中配置 ssh：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">SSH</span> <span class="hljs-string">Key</span><br>  <span class="hljs-attr">uses:</span> <span class="hljs-string">shimataro/ssh-key-action@v2</span><br>  <span class="hljs-attr">with:</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SSH_KEY</span> <span class="hljs-string">&#125;&#125;</span> <br>    <span class="hljs-attr">known_hosts:</span> <span class="hljs-string">&#x27;just-a-placeholder&#x27;</span><br></code></pre></td></tr></table></figure><p>这样之后就可以在 Action 的后续步骤中像在本地一样使用 SSH 的方式来 clone repo 和提交代码了。<br>通过 ssh key 的方式我们也可以在 Github Action 中通过远程的方式来在其他服务器上执行命令，这对于要部署到服务器上的脚本来说是非常有用。</p><p>具体可以参考这篇文章： <a href="https://zellwk.com/blog/github-actions-deploy/">Deploying to a server via SSH and Rsync in a Github Action | Zell Liew (zellwk.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近我把自己的一些自动化脚本移到了 Github Action。因为考虑到 Github Action 有下面几个优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自动化脚本是代码的一部分 (Infrastructure as Code)，而不是限定在某个服务器上。这样长久来说更为通
      
    
    </summary>
    
    
      <category term="工具，Github" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CGithub/"/>
    
  </entry>
  
  <entry>
    <title>自动补全算法</title>
    <link href="http://chenyukang.github.io/2021/11/29/input-complement-algorithm.html"/>
    <id>http://chenyukang.github.io/2021/11/29/input-complement-algorithm.html</id>
    <published>2021-11-29T08:34:43.000Z</published>
    <updated>2021-12-29T01:01:47.912Z</updated>
    
    <content type="html"><![CDATA[<p>周末在和一个日本小伙一直讨论一个 Obsidian 的 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin">补全插件</a>，经过一个周末的努力，最终这个插件完善了不少。</p><p>我主要想用这个插件来补全英文输入，这个插件目前没有自带的词典。我在互联网上搜索了一圈，最终在 Github 上找了这个 <a href="https://github.com/first20hours/google-10000-english">Google 10000 English</a>，也就是最长使用的搜索单词。</p><p>实际上，前 7000 个英语单词覆盖了日常的 90% 使用场景。</p><h3 id="中文输入"><a href="#中文输入" class="headerlink" title="中文输入"></a>中文输入</h3><p>首先我碰到的问题是，输入中文的时候插件也在补全英文。然后我提了第一个 issue。作者很快就回复了，给了我一个开发版本尝试，很完美的修复了这个问题。<br><img src="/images/ob_pasted-image-20211128185804.png" alt="/images/ob_pasted-image-20211128185804.png"><br>然后在使用过程中发现另一个小问题，比如我的字典里面有 <code>apple</code>，但是如果我是在句子头部输入 <code>Ap</code> ，这个单词并没有出现在补全列表。我们当然可以把字典的单词都进行首字母大写的处理，但是这就会让字典翻倍。</p><p>我看了看源码，果然如自己猜想的那样，匹配的时候没有考虑首字母大写的问题。我花了一些时间做了一个 PR：<a href="https://github.com/chenyukang/obsidian-various-complements-plugin/commit/935d7de1633b9a7685349a97302a0e908e10b215">fix issue #30, take care of uppercase </a>。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>在我做上个修复的时候，也顺便修复了一个性能上的问题，看这个补全插件的核心算法如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">suggestWords</span>(<span class="hljs-params">words: Word[], query: string, max: number</span>): <span class="hljs-title">Word</span>[] </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(words)<br>    .filter(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.value !== query)<br>    .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (caseIncludesWithoutSpace(x.value, query)) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">word</span>: x, <span class="hljs-attr">value</span>: x.value, <span class="hljs-attr">alias</span>: <span class="hljs-literal">false</span> &#125;;<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> matchedAlias = x.aliases?.find(<span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span><br>        caseIncludesWithoutSpace(a, query)<br>      );<br>      <span class="hljs-keyword">if</span> (matchedAlias) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">word</span>: x, <span class="hljs-attr">value</span>: matchedAlias, <span class="hljs-attr">alias</span>: <span class="hljs-literal">true</span> &#125;;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">word</span>: x, <span class="hljs-attr">alias</span>: <span class="hljs-literal">false</span> &#125;;<br>    &#125;)<br>    .filter(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.value !== <span class="hljs-literal">undefined</span>)<br>    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> aliasP = (<span class="hljs-built_in">Number</span>(a.alias) - <span class="hljs-built_in">Number</span>(b.alias)) * <span class="hljs-number">10000</span>;<br>      <span class="hljs-keyword">const</span> startP =<br>        (<span class="hljs-built_in">Number</span>(lowerStartsWith(b.value!, query)) -<br>          <span class="hljs-built_in">Number</span>(lowerStartsWith(a.value!, query))) *<br>        <span class="hljs-number">1000</span>;<br>      <span class="hljs-keyword">const</span> lengthP = a.value!.length - b.value!.length;<br>      <span class="hljs-keyword">return</span> aliasP + startP + lengthP;<br>    &#125;)<br>    .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.word)<br>    .slice(<span class="hljs-number">0</span>, max);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数中如果词典列表很长，这里的 <code>filter</code>, <code>map</code>, <code>filter</code> 会遍历列表三次，是很耗时的操作。我把第一个 filter 干掉了。然后在匹配逻辑里面增加了首字母大写的相关的 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/commit/2b3990af4b4e19198833e1deb0a8783fcd45a60e#diff-25a6634263c1b1f6fc4697a04e2b9904ea4b042a89af59dc93ec1f5d44848a26">处理</a>。除了自定义的单词词典，这里补全的候选词来源包括当前文件内容、Obsidian 的内部链接。而链接需要进行部分匹配进行补全。</p><p>后续在使用过程中我又觉得补全有些慢，甚至会影响输入的体验，在 Obsidian 里面通过 <code>Ctrl+Shift+I</code> 可以打开调试面板，我们可以看到补全的耗时：</p><p><img src="/images/ob_pasted-image-20211128193253.png" alt="/images/ob_pasted-image-20211128193253.png"></p><p>这里的主要问题还是因为每次输入一个字母，算法都在遍历单词列表两边。优化思路有两条：</p><ol><li>使用类似桶排序的思路，把单词按照首字母进行分割，分成 26 个子列表，这样查找的时候就先根据首字母找到子列表，然后进行遍历搜索。</li><li>使用类似 Trie Tree 的数据结构进行前缀匹配。</li></ol><p>后来那个作者按照第一种思路进行了 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/commit/f6e047d479b57f3dd2171ce5eaa1c1f7692c91ad">优化</a>，很快将补全时间优化到了 0~5 ms。果然粗暴的算法其实很多时候就够了。</p><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><p>在日常使用过程中，我又发现了还存在这个 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/issues/34">问题</a>。如果我尝试去修改中文句子的某个部分，这个插件会补全当前句子，就像这样：</p><p><img src="/images/ob_pasted-image-20211128194301.png" alt="/images/ob_pasted-image-20211128194301.png"><br>这当然是完全没有意义的。我看了一下代码发现是没有进行中文分词，所以现在的补全把这个中文句子当作一个连续的字符串在补全。</p><p>我自己尝试这想做一个 PR，但是没找到合适的中文分割 JavaScript 库。Obsidian 不能使用 Node 的库（移动端方面的考虑），所以也就不能使用这个 <a href="https://github.com/yanyiwu/nodejieba/blob/master/README_EN.md">NodeJieba</a>。虽然还没完成这个分词功能，不过我也在这个过程中学着写了点 TypeScript。</p><h3 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h3><p>这个看似简单的功能，如果要做到日常可用其实有很多细节需要完善。这个算法问题看起来不难，很适合用来进行面试。这是日常中很常见的一个需求场景，而且优化这个算法思路也可以很开放。</p><p>TypeScript 真强，虽然我只是简单用了一下，一些常见的 JavaScript 错误比如 enum 忘记补全之类的问题都能找出来。<a href="https://www.electronjs.org/">Electron</a> 真猛，VSCode、Obsidian、Slack 这类工具都是 Electron 开发的。</p><p>开源软件的好处在于很多代码的作者对自己的成果有一种成就感，所以会想办法来完善，而用户也可以帮着来想办法。在这个过程中，不仅可以让其他人受益，自己也得到了一些学习和提高😘。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周末在和一个日本小伙一直讨论一个 Obsidian 的 &lt;a href=&quot;https://github.com/tadashi-aikawa/obsidian-various-complements-plugin&quot;&gt;补全插件&lt;/a&gt;，经过一个周末的努力，最终这个插件完善了不
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://chenyukang.github.io/tags/Tools/"/>
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="Obsidian" scheme="http://chenyukang.github.io/tags/Obsidian/"/>
    
  </entry>
  
</feed>
