<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CatCoding</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://catcoding.me/"/>
  <updated>2025-06-11T13:12:20.584Z</updated>
  <id>http://catcoding.me/</id>
  
  <author>
    <name>yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust Week 2025 杂记</title>
    <link href="http://catcoding.me/p/rust-week-notes/"/>
    <id>http://catcoding.me/p/rust-week-notes/</id>
    <published>2025-06-11T10:23:14.000Z</published>
    <updated>2025-06-11T13:12:20.584Z</updated>
    
    <content type="html"><![CDATA[<p>5 月中旬我参加了在荷兰 Utrecht 举行的 Rust Week，想来可以写篇文章记录下所见所闻。</p><p>我年初和 Rust 基金会邮件确认参加，但直到 4 月 9 日才开始动手申请签证。在深圳办理荷兰签证流程简单，只需提交材料并录指纹，但我嫌麻烦找了中介帮忙。据说大概也就两周多就会有结果，但直到五一查询还是没结果，中介说可以加 600 元加急。看到官网解释近期审批延迟，我便花钱加急，第二周拿到了签证。不知道这其中是否有猫腻，但确实有华为的朋友同样卡在那个节点审批，结果没有如期下来。</p><p>从广州白云机场有直飞阿姆斯特丹的航班，只是起飞时间大概是凌晨 1 点多。飞机上座位空间狭小，难以入睡，趴着或躺着都不舒服，到了阿姆斯特丹是早晨 6 点多。通过海关后，我因不熟悉荷兰语而有些迷茫。由于未携带 Visa 卡，只能使用现金，幸好两位路人热心相助。我直接购买火车票前往 Utrecht，约于上午 10 点抵达酒店。因为时间还比较早没有空房，我把行李箱放在酒店自己去城里逛逛。</p><p>Utrecht 据说是荷兰第四大城市，交通方便。我查了一下，人口约为 30 万，这在中国估计只算是小镇了。我信步漫游，城市整洁如画，绿树成荫，空气清新怡人。由于是周六，商户大多已关门，街上行人多在跑步或散步，整体人口密度较低。5 月应该是荷兰最好的天气，不冷不热，只要不在太阳下就会感觉凉凉的。荷兰人身高马大，路上的自行车很多而汽车非常少，大多都是 A 级车，豪车基本没看到。很常见的场景是父母骑自行车，拉着个大篮筐里载着一两个小孩。</p><p>街头的人们神情轻松自在，仿佛时间在这里慢了下来。路旁一个年轻人倚着树，手捧书本读得入了神，旁边的金毛小狗却不耐烦地扯着牵绳，发出几声撒娇。草坪边，几个人懒洋洋地躺在长椅上晒着太阳，像是被微风哄睡了，手中未喝完的咖啡杯歪在一旁。运河边，一对白发苍苍的夫妇沐浴在阳光中，丈夫似乎想起什么趣事，侧身在妻子耳边低语几句，惹得她轻笑出声，随即两人轻轻接吻。这些场景对我这个匆匆旅客而言，宛如《楚门的世界》的开场，美好却略显不真实。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250607184354.png" alt=""></p><p>更实际的问题是吃饭，到了中午饭点，主城区我都快粗略走完了，但只有一两个餐厅开着。无奈，我去超市买了点面包和牛奶当作午饭，顺便看了一下日用品的物价，水果和蔬菜比较贵，牛奶之类的东西便宜点。回到酒店有了空房，前台给我办理了入住，稍微睡了一个来小时，起来后已经是下午三点多了，这时候我才后悔今天应该多在阿姆斯特丹逛逛，可玩的地方应该更多。我只能又往还没逛的城市另一边漫步，城市面貌都挺漂亮，不过总体而言房子大多是联排，空间不是很大，不像多年前第一次逛圣何塞那样户户大别墅带给我震撼。</p><p>晚上看到 zulip 里有消息，和我一样提前到达的人开始组局吃饭了。我们一行四人挑了个餐厅聊了两个小时左右，一个美国教授、一个德国年轻学生、还有一个马来西亚人，聊的都是技术趣闻和 Rust 相关的。但我这时候有点困了，所以主要在吃和听。没想到饭局结束后都晚上九点半了，天还微微暗，这时候 Utrecht 城市运河旁边的餐厅开着，游客熙熙攘攘，这大概是最热闹的时候了。</p><p>5.12 是周一，这天没有什么特别的活动，明天才是主会议的第一天，所以很多人还在路上。我上午去了会场注册领了参会牌，然后在会场逛了逛。我陆陆续续认出来了一些用真实照片做 Github 头像的人，期间和一个老哥聊了起来，他常年维护着 rustc-dev 这份开发文档，之前我提 PR 的时候帮我 Review 过。到了饭点就一起边聊边往市区走，我们想爬到教堂的楼顶参观，据说这里是城市的最高点，风景应该不错。去了之后发现一定要预约和请讲解员，而且一个下午才几十号人，便放弃了。走了 20 多分钟，都没找到什么看起来好吃的餐厅，碰到一个超市又买了点面包和牛奶，在附近的公园旁当作午餐。这老哥来自南非，比我大几岁，之前维护过 Debian 上的一些包。他给 Rust 做开源贡献快十年了，大多是一些文档类的工作。他现在全职远程在一个 Rust 相关的咨询公司工作，主要日常还是做些开源维护工作。</p><p>下午没什么特别的安排，我参加了一个 workshop。我们要做的是一个腐蚀的 Rust 实体 Logo，可以在背后用马克笔写上自己的名字，用磨砂纸摩擦一遍，然后用酒精还有各种化学染料涂在 Logo 的表面，等待一段时间就会形成腐蚀的效果和图案，我也跟着做了一个，是不是看起来很漂亮？但我第二天忘记去取了 :)</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250607173912.png" alt=""></p><p>因为时差原因，我下午就开始犯困，在酒店睡了一下午后，看到群里又有人开始组饭局，这次是都是同住个酒店的人，我们在酒店大堂集合，总共大概有 10 个人左右。我看到了更多的熟悉面孔和 id，有几个维护 Rust 多年的成员，碰到了我第一次提 PR 帮我 review 的 estebank。</p><p>我们找了个店喝了点啤酒，然后服务员过来说后厨到点下班了，所以不提供晚餐。这对于中国人来说真是难以置信，哪有这么做生意的呢，这里果然是到点下班比挣钱更重要。后来我们坐火车去了主城区，接连询问了两家餐厅，均表示已快到打烊时间 (其实也就快晚上 9 点)，最后终于找了一个运河边上的餐厅坐下。我点了个海鲜意面，味道非常不错，20 欧元也值了，但没想到这就是我这一周吃得最满意的一顿饭了。</p><p><img src="http://catcoding.me/images/ob_ad6b5b55398d6fe5b5c743a2f2bcd95c.jpg" alt=""></p><p>一群程序员吃饭聊的还是技术话题，作为 Rust 程序员和维护者，吐槽 C++ 是不可避免的，有的聊得比较细节，比如如何提高链接速度之类的。总体来说气氛非常好，大概是很多人都远程工作，平时无法找到这么一群志同道合的人聊天，而且这些人平时在开源社区里合作交流，能见面聊聊自然是非常开心的。</p><p>有趣的事发生在我们用完餐之后，老板估计是犯懒，结账说不能分开支付，所以我们需要找个人先替大家把单买了，然后大家再转给他。一群程序员大眼对小眼，那气氛有点尴尬。后来是 eholk 站出来先买了单，然后一群人围着他看账单转钱给他，反正是异常耗时和麻烦，看来还是中国手机支付 AA 来得更方便。</p><p>5.13 是 Conference 的第一天，主题很多，而且分了三个分会场：主会场、生态、行业应用。这两天参会的人非常多，我估计得有 500 来人。公司展台比较少，右边有 Jetbrains、Zed、左边有一些硬件相关的和 Rust 培训咨询相关的公司，华为有个招聘展台。现场看到了其他几个中国人，聊了一下他们是在 Cargo 项目团队做开源贡献的。在会场我见到了更多熟悉的面孔，因为挂牌上有 Github 账号，所以基本盯着对方的名片看看就知道是否打过交道，可以说这是一个大型的网友见面会。我在社区里面断断续续也做了四年，有的人只是通过 review comments 交流，有的人通过 zulip 私聊过，能见面聊聊真是一种难得的体验。另外我和华为爱尔兰可信计算实验室的余教授聊了比较久。</p><p>这次会场居然选在了一个电影院，一楼是一个大的会展活动空间，整体非常宽敞。这是我第一次坐在电影院听技术演讲，座位宽敞、音效和视觉都棒极了，他们甚至做了一个类似电影的<a href="https://www.youtube.com/watch?v=E56STygm8i4">片头动画</a>，看起来诙谐可爱。第一天最热的主题应该是 Alex Crichton 的 10 Years of Rust，我第一场也去听了这个演讲。推荐任何对 Rust 感兴趣的去看看这个<a href="https://www.youtube.com/watch?v=zIm6xIOLVkA&amp;ab_channel=RustNL">视频</a>。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250608105940.png" alt=""></p><p>Rust 在嵌入式领域取得了长足的进展，所以也是这次会议的热点，<a href="https://youtu.be/84bX1nPDBr4?t=13035">It’s Embedded Rust Time</a>这个演讲谈到长远来看这个领域里的人希望 Rust 能得到更多应用，volvo 的人分享了他们使用 Rust 开发和发布第一个 ECU 的过程。来自南京大学的 Xiaolong 分享了一个异步任务编程框架 Dagrs。<a href="https://www.youtube.com/watch?v=UOP9q3BRiIA&amp;t=24425s">Refactoring in Rust</a> 分享了些重构技巧，把一个典型场景的代码变得漂亮易维护。 <a href="https://www.youtube.com/watch?v=UOP9q3BRiIA&amp;t=26954s">We deserve helpful tools</a> 介绍了编译器里的错误信息如何更友好，很多初学者喜欢 Rust 的一个原因是 rustc 的错误信息看起来人性化又有帮助，这是社区里很多人努力的结果。</p><p>午饭期间，有个比利时的工程师来拼桌，所以就聊了起来，他几年前去广州待过一个多月，所以有些共同话题。他业余时间喜欢折腾硬件和数学，组织了一个学习系统编程的<a href="https://sysghent.be/">小组</a>。这个人非常健谈有趣，我们一起聊了聊各自的工作经历等，在 Linkedin 上加了个好友。</p><p>第一天会议结束后，我跟着 estebank 一行八个人出去就餐。这次我们选的是一家印度餐厅，因为已经有两三天没吃米饭了，我点了一个看起来有点辣的鱼加米饭，结果菜上来之后让我震惊，不管味道还是品相都达不到沙县小吃级别，但这饭饭菜居然也要 20 欧，这是我这周吃过的最差的一顿饭了吧。这周后面几天的晚上我都不想吃晚饭，一方面是白天在会场吃了很多零食，另一方面到了晚上七点左右我就非常困，这边晚上天黑的时间短，所以我通常回到酒店就睡觉。</p><p>5.14 第二天我首先去听了 <a href="https://www.youtube.com/watch?v=kDVRkcKHCLc&amp;ab_channel=RustNL">Rust for Linux</a> 这个演讲，这场非常火爆，看来大家都非常关注这个领域，无论是在贡献者数量还是提交到主线内核中的代码行数方面，增长都非常快。然后我去听了大部分 Rust Project track 相关的演讲，compiler-errors 没写 PPT，居然直接在 VsCode 里面<a href="https://www.youtube.com/watch?v=aFG5KtpEynk&amp;ab_channel=RustNL">讲解代码</a> 。<a href="https://youtu.be/8vz_pg-eI4I?t=29">The Rust Vision Doc and You</a>讲解了如何获取用户的意见和反馈，Rust 在全世界的整体采用情况，很高兴看到社区像是对待一个产品一样来发展一门编程语言。</p><p>所有两个天的 Conference 会议在油管上直播，也有录像，感兴趣的可以自己<a href="https://www.youtube.com/@rustnederlandrustnl/videos">找来看看</a>。</p><p>5.15 第三天的上午有各种 workshop，会场地址也变了另一个郊区的办公场所，这个会场在运河的旁边，河上经常有各种运货大船漂过，感觉像苏州的运河的场景。华为余教授帮我弄了个参加 workshop 的机会，我去体验了一下玩了会儿跨平台的 Rust GUI 框架 Makepad。然后我去了对面的 Rust all hands 的办公场所，这里都是 Rust 项目维护者和贡献者，大家以分组的方式进行讨论，有的人干脆找个角落写代码。这次组织者非常用心，说不提供单一的 t-shirt，但找了一个打印 Logo 的机器，大家可以自己选择在衣服、背包、帽子上打印 Rust 相关的图案，我把自己的上衣上印了一个黄色的螃蟹。有的人把自己平时收集的一些笔记本贴纸分享出来，我第一次看到这么多 Geek 贴纸，选了好多。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250608105055.png" alt=""></p><p>会场提供了很多酒水和小吃，我不停地喝橙汁。期间碰到了在华为俄罗斯工作的 petrochenkov，他穿着一件 Rust 1.0 发布的纪念 t-shirt，年龄和我相仿却已在开源社区工作十多年。他之前帮我 Review 过不少 PR，以前在中国华为办公室工作过，这次终于见面聊了聊。我们俩一起打乒乓球，虽然两个人水平都不太行，但玩得很来劲。</p><p>这天下午用来庆祝 Rust 1.0 发布 10 周年，有一个小型 Party，并且用实时发布 1.87 版本的方式进行庆祝。Niko 上台演讲了 <a href="https://smallcultfollowing.com/babysteps/blog/2025/05/15/10-years-of-rust/">Rust turns 10</a>，余教授代表华为作为赞助商演讲了，华为应该是中国企业中对 Rust 投入最多的，不管是国内的华为还是海外分部都有投入，而且也在通过其他组织赞助社区的一些资深维护者。这会儿我才知道发行一个 Rust 新版本的脚本要运行一个多小时多，最后发布倒计时那会儿气氛达到高潮，拍下了这张照片，我大概在右边第三排的位置，但是身高不够被淹没了：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250607222131.png" alt=""></p><p>5.16 和 5.17 是两天的 Rust all hands meeting，可以自由选择参加分组讨论也可以自己找个地方工作一会儿。我选择性参与听了一些，比如 Rust society、Let’s talk about Burnout、Infra、Rust Foundation 的 office hours 等，感觉这两天讨论比较多的几个主题是和 C++ 的互操作性。期间也有很多时间留给大家自由讨论，有人安利 <a href="https://github.com/jj-vcs/jj">jj</a>这个工具，我试用了一下还没理解好在哪里。我比较多时间和 Cargo 组的几个中国人待在一起，突然长时间处于全英文环境中，偶尔会感到表达上的疲惫。。</p><p>第二天下午和一个德国大学生聊了比较久，很多社区的贡献者都是业余时间在做开源，比如这个大二学生，他在学校学的是音乐，计算机只是自己的业余爱好。为什么 RustNL 比较活跃呢，大多是因为荷兰这个国家其实 Rust 爱好者还挺多的，加上德国这些周围国家，整个欧洲的 Rust 活跃度比我想象中高很多。在聊天的过程中，我问到一个问题：为什么很多贡献者来自德国？可能是因为德国人最喜欢 follow rules 并且个性严谨，这和 Rust 的特性非常符合。</p><p>另外，我发现很多人采用的是自己开个咨询公司的方式工作，这样可以同时和多个公司签短期劳动合同，按项目收费，当然这样收入也许并不稳定，但这种方式贵在灵活。我们也聊了一些生活类的话题，总体而言我觉得欧洲的国家大多税收比较重，但基础的生活保障方面的福利也挺好，总得来说人对挣钱的欲望没有那么强烈，人的选择和路径也比较多。</p><p>这期间张汉东过来找 jackh726，他们约了一个大约半小时的会谈，主要是聊聊 Rust 在中国的发展和使用情况，jack 让我临时做个翻译。这是我第一次做类似口译这事，几乎有一半时间我只是用英语概括了一下他的讲话。最后我自己也表达了些自己的想法，从全球 IT 产业规模看，Rust 在中国具有广阔发展前景，未来或将有更多中国开发者活跃于 Rust 社区，贡献力量。当然这里有很多因素在影响，一方面大部分国内的 IT 工程师都太忙，还有语言方面的障碍，也许未来情况会好一些，当然这也需要社区的支持。</p><p>访谈完后在茶水间，我偶然瞟了一眼对面人胸前的牌子，这个名字看起来眼熟，原来是世界上 crate 包被下载最多的作者，如果你是 Rust 程序员应该都能猜出来他的名字。我上前打了个招呼聊了起来，他前几天的会议都没参加，只是今天过来逛逛，了解到他现在 FB 工作，我说感觉 FB 的社区贡献不多，他反驳说 FB 也是 Rust Foundation 的铂金赞助者，内部还不少 Rust 相关的项目。我突然想起 GOSIM 要找人 9 月份在杭州演讲，开玩笑邀请他来中国参加技术分享，他说那段时间有事委婉拒绝了。</p><p>在这次 RustWeek 一周的时间里，我见到了各式各样的工程师，多数人看起来简单纯粹，比如《硅谷》里的 Gilfoyle 式的人物，我见到了一个从头到脚都非常类似的人，长发飘飘还赤脚走来走去，随便找个位置就能完全陷入了自己的编程世界。有次回宾馆的大巴上，nnethercote 坐在我旁边，他是 valgrind 的作者，可以说是一个世界级的基础软件工程师，感兴趣的可以读读这篇 <a href="https://nnethercote.github.io/2022/07/27/twenty-years-of-valgrind.html">Twenty years of Valgrind</a>。我的第一份工作写 C/C++，特别依赖 valgrind 找内存问题，所以我一路都在问他问题，聊他的技术旅程。他说 Rust 从语言级的角度解决内存的安全性问题，已经成了另外一条路，valgrind 完全由其他人维护了。社区里的很多人他也是第一次见，随口说 all hands 的一大作用是以后大家在 Review PR 的时候能想起对方的面容，这表述得太正确了！</p><p>在会场乱逛我有时候会盯一下大家的开发环境，有的人真是非常极客，笔记本看起来巨大厚重，操作系统大多是 Linux。我发现一个编译器贡献排前三的大牛打字使用二指禅，有天早餐时他坐我对面，我问起为什么只用两个手指操作键盘，会不会效率不高。他说两个手指的速度已经够了，敲键盘能跟上我的思考速度就行。我那天早上刚好看到个视频，说是美国大学生使用 AI 写作业，把一个教授给逼得崩溃，我知道他在世界顶级大学 Eth 当教授，我问他如何看待学生使用 AI 完成作业或者写程序，他说他的作业 AI 基本无法解决，可能是因为程序语言类的很多作业都是证明，而 AI 通常只能完成简单的，稍微深入点的无法胜任，他还会和学生当面交流，如果依赖 AI 而脑子里没货是很容易被发现的。</p><p>这次没看到什么 AI 相关的主题，聊天时有人会偶尔吐槽一下 LLM。区块链更没有人聊了，每当有人问起我主业在干什么，我都有点不好意思说我在做这个行业，因为我知道社区里面很多人有些厌恶这个术方向，特别是一些投机者损坏了这行的口碑。我通常会解释说，从技术角度来说区块链就是一个抗拜占庭的分布式数据库，还是非常有趣和有挑战的，区块链这行也是 Rust 成为主流选择的第一个领域，推动了 Rust 的发展。仔细想想，做编程语言和编译器的，追求的就是确定性和速度，AI 有其不确定性，而区块链效率不高，所以这些人大多不喜欢相反特性的东西。从去年开始，有些人为了打造出来一个看似大有贡献的 Github 账号来获得某些加密货币的空投，于是用 AI 提出各种琐碎或者错误的 Pull Request，这些维护者看着这些毫无营养的 PR 浪费自己的时间，自然对这两个行业更加厌恶了。</p><p>虽然目前我还很喜欢自己在做的工作，但我顺带了解了些全职做 Rust 社区的工作机会，说不定以后会用到。通过和不同的人聊天，我发现主要有以下一些机构：</p><ol><li>国内华为、<a href="https://trusted-programming.github.io/">爱尔兰华为</a>，全职华为员工或者 Rust 相关工作的 contract</li><li>亚马逊，总体而言公司文化比较 push，我听到不少关于亚马逊工作环境的抱怨</li><li>微软，不一定是做社区的工作，而且微软最近也在裁员</li><li><a href="https://ferrous-systems.com/" title="https://ferrous-systems.com/">ferrous-systems</a> 不确定是否还有职位，contract 或者全职</li><li><a href="https://www.futurewei.com/careers" title="https://www.futurewei.com/careers">futurewei</a> 对员工很灵活，据说完全自己安排工作内容</li><li>Rust Foundation，但主要偏 security 和 infra 相关的，社区里对 Rust 基金会直接雇人做语言方面的工作有顾及</li></ol><p>如果是全职 Rust 开发的工作，欧洲应该是相对好找一些 (但需要签证)，国内据我所知除了华为、还有字节、小米、汽车公司会用到 Rust。现在 AI 很火，AI 的 infra 也会用到些 Rust，我了解到社区里一个非常资深的维护者去了 OpenAI，这次也碰到一个 OpenAI 的人说公司内部有些 Rust 项目。但整体来说，整个世界的大环境不好，工作机会相比往年少很多。</p><hr><p>十年无疑个具有纪念意义的里程碑，就像 Niko 在<a href="https://smallcultfollowing.com/babysteps/blog/2025/05/15/10-years-of-rust/">Rust turns 10</a>所说的：</p><blockquote><p>I just felt that was the most Rust of all problems: having great success but not being able to decide who should take credit. The reality is there is no perfect list – every single person who got named on that award richly deserves it, but so do a bunch of people who aren’t on the list. That’s why the list ends with _All Rust Contributors, Past and Present</p></blockquote><p>Rust 目前的成功无法简单归功于个人和机构，无疑我们需要感谢项目发起人 Graydon Hoare 设置了宏大正确的愿景，而后 Rust 在开源社区自由生长，甚至完全不像是他所设想的编程语言了。现在几个 IT 巨头都有投入，但实际上也没有一个组织和个人能决定未来的发展，这既是社区的刻意设计，也是自然进化的结果。从我这种业余贡献者的角度来说，基金会虽然因为各种事饱受争议，但他们确实做了很好的幕后工作，比如这次参会的社区成员基本都能报销费用，甚至我的费用超过了计划申明的额度，基金会也直接说别担心，我们会如实报销所有费用。</p><p>总的来说，这次参会经历拓宽了我的视野。大家都因为对 Rust 和编程的激情和追求聚到了一起，交流起来非常有趣。十年前，我在 2015 年偶然发现了 Rust，当时并不知道它会塑造我的职业生涯，在我迷茫的时候重新捡起了 Rust，如今成为全职的 Rust 开发和社区贡献者。最近一年育儿和工作占据了我的大部分时间和精力，所以在 Rust 社区没那么活跃，我渴望通过编程和写作继续投入其中。</p><p>顺便一提，Rust Week 这一周我都没吃中餐，回家一称瘦了三四斤，算是意外达成健身目标！我应该是无法在欧洲长待的那类人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;5 月中旬我参加了在荷兰 Utrecht 举行的 Rust Week，想来可以写篇文章记录下所见所闻。&lt;/p&gt;
&lt;p&gt;我年初和 Rust 基金会邮件确认参加，但直到 4 月 9 日才开始动手申请签证。在深圳办理荷兰签证流程简单，只需提交材料并录指纹，但我嫌麻烦找了中介帮忙。
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
      <category term="旅行" scheme="http://catcoding.me/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>从椭圆曲线到 secp256k</title>
    <link href="http://catcoding.me/p/elliptic-curve/"/>
    <id>http://catcoding.me/p/elliptic-curve/</id>
    <published>2025-06-08T18:20:12.000Z</published>
    <updated>2025-06-11T13:12:20.576Z</updated>
    
    <content type="html"><![CDATA[<p>区块链这行经常会和椭圆曲线密码算法打交道，我也在尝试理解这其中的数学原理，这里记录一下。</p><h2 id="什么是椭圆曲线-elliptic-curve"><a href="#什么是椭圆曲线-elliptic-curve" class="headerlink" title="什么是椭圆曲线 (elliptic curve)"></a>什么是椭圆曲线 (elliptic curve)</h2><p>先想象一个普通的曲线，比如抛物线（抛个球的轨迹）。椭圆曲线不是椭圆（名字有点误导），而是一种长得像“对称小山丘”或者“歪歪扭扭的环”的数学图形。</p><p>椭圆曲线通常表示为：</p><p>$$ y^2 = x^3 + ax + b$$</p><p>通过这个方程我们可以看到椭圆曲线是上下对称的，其中 (a) 和 (b) 是曲线参数，比如下面这些曲线就是 b = 1 的情况下，a 从 2 变到 -3 的情况：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250401152936.png" alt=""></p><p>我们通常使用的椭圆曲线必须满足<code>非奇异</code> 的特征，这些参数必须满足判别式：</p><p>$$4a^3 + 27b^2 \neq 0$$</p><p>“非奇异”什么意思？在数学上，椭圆曲线要是“非奇异”（non-singular），就是说这条曲线长得“光滑正常”，没有奇怪的尖角、交叉点或者自己打结的地方。简单讲，就是曲线不能太“怪”，得是个平滑的、像个正常曲线的样子。</p><p>如果曲线“奇异”了，会出现两种毛病：</p><ol><li>尖点（Cusp）：曲线像被捏了个尖角，某个地方变成一个尖尖的点，不光滑了。</li><li>自交点（Node）：曲线自己交叉，像个“X”形，两个方向撞一块儿了。</li></ol><p>这些毛病会让“点加法”出问题，因为公式会算不下去，或者结果不唯一。关于<code>点加法</code>我们后面再谈，下面这两个椭圆曲线都是奇异的：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250401153156.png" alt=""></p><h2 id="阿贝尔群-Abelian-group"><a href="#阿贝尔群-Abelian-group" class="headerlink" title="阿贝尔群 (Abelian group)"></a>阿贝尔群 (Abelian group)</h2><p>这名字来自数学家 Niels Henrik Abel，他研究了这种“顺序无所谓”的结构。</p><p>“群”（group）是数学里的一种概念，就像一个有规则的“俱乐部”。里面有一堆东西（叫元素），加上一个玩法（叫运算），得满足几个条件。阿贝尔群是群的一种特别类型，特点是这个玩法“顺序无所谓”。<br>简单说，阿贝尔群就是一个集合，里面有些元素，能用某种运算（比如加法）组合起来，满足以下条件，而且运算顺序随便换都没问题。</p><p>群的四个基本条件：</p><ul><li>能玩（封闭性）：你拿集合里两个东西玩一下（做运算），结果还是集合里的东西。比如，两个整数相加还是整数。</li><li>有老大（单位元）：集合里有个特殊的东西，跟谁玩都不变。比如加法里的 0，$0+5=5$ ，什么也没变。</li><li>能回头（逆元）：每个东西都有个“反着玩”的朋友，俩人玩一下变老大。比如加法里，5 的逆元是 −5，$-5 + 5 = 0$。</li><li>括号随便（结合律）：玩的时候，先跟谁玩再跟谁玩都一样。比如 (2+3)+4=2+(3+4) 。</li></ul><p>群变成“阿贝尔群”，还得多一条：</p><ul><li>顺序无所谓（交换律）：你拿两个东西玩，先后顺序换一下，结果一样。比如 $2+3 = 3+2$，都是 5。如果顺序有所谓（比如 $2−3≠3−2$），那就不是阿贝尔群了。</li></ul><p>密码学里用阿贝尔群（像椭圆曲线），因为它简单又有规律，适合搞安全。</p><h2 id="椭圆曲线上的离散点"><a href="#椭圆曲线上的离散点" class="headerlink" title="椭圆曲线上的离散点"></a>椭圆曲线上的离散点</h2><p>到了 1900 年代，椭圆曲线跟数论彻底绑定，而数论研究的是整数。</p><p>椭圆曲线方程</p><p>$$y^2 = x^3 + ax + b$$</p><p>通常是在普通实数（无限多的小数）上定义的，画出来是个连续的曲线。但安全领域说的椭圆曲线通常是说通过椭圆曲线定义出来的群，其范围定义在某个有限域 : $F_p$ 。</p><p>简单说，整数也是一个无限数字的世界，而有限域就是一个只有有限个数字的“数字世界”。这里的表示这个世界里只有 <code>0, 1, 2, ..., p-1</code> 这 (p) 个数，(p) 必须是个素数。为什么是素数？因为这样能保证这个小世界里的数学运算（加减乘除）不会出乱子，规则特别“干净”。</p><p>在这个有限域里，所有的计算结果都得落在这 (p) 个数里面。如果算出来超了 (p)，就“绕回去”，用模 (p) 的方式把结果限制住。比如在 $F_5$ 里：3+4=7，但 7 不在范围内，所以 $7mod  5=2$，所以结果是 2。</p><p>这个时候，曲线不再是连续的，而是变成了散落在 $F_p \times F_p$ 网格上的一堆离散的点。比如我<a href="https://github.com/chenyukang/elliptic-curve">这个程序</a>打印出来这条曲线上的点，这里打印的时候 $y =0$ 是在中间，从中间看上下是对称的：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250401160252.png" alt=""></p><h2 id="点加法和对数问题"><a href="#点加法和对数问题" class="headerlink" title="点加法和对数问题"></a>点加法和对数问题</h2><p>上面我们只是通过椭圆曲线找到了一组数字，但这些数字之间还需要一种操作，这种操作才能让这些离散的数字组成一个群的概念。这里就需要引入一个“点加法”的概念。</p><p>点加法就像一个魔法公式，告诉你怎么从一个点“跳”到另一个点，或者同一个点“跳”两次变成新点。想象椭圆曲线是一条弯弯曲曲的线，上面有很多点，在不断做点加法的过程中不断地移动点。</p><p>在椭圆曲线上，点加法有几何和代数两种解释：</p><ol><li><p>几何解释：通过两个点画一条直线，与曲线的第三个交点取关于 x 轴的对称点。<br><img src="http://catcoding.me/images/ob_pasted-image-20250401162659.png" alt=""></p></li><li><p>代数公式：<br><img src="http://catcoding.me/images/ob_pasted-image-20250401163340.png" alt=""></p></li></ol><p>离散对数问题是在一个有限的“数字圈”里玩，比如有限域 $F_p$ （( p ) 是素数）或者椭圆曲线的点群里。比如：</p><ul><li>给你 $y = g^x \mod p$ ，已知 ( y, g, p )，求  x。</li><li>在椭圆曲线上，变成 $Q = k \cdot P$ ，已知  Q 和  P（基点），求 k（跳了几次）。</li></ul><p>这里的 ( x ) 或 ( k ) 就是“离散对数”。这就是离散对数问题，数学家没找到一个快速方式能解决这个问题。</p><p>直观感受一下，我们修改上面那个程序，我定义一个起始点 P，然后不断通过 P + P 的方式进行 20 次，终点是黄色的，然后把中间通过的点用蓝色的线连接起来，可以看到我们经过的点是没有什么规律的。</p><p>反向破解就比如你拿到这幅图，如果不告诉你蓝色的连线，而只有那个黄色的终点，现在问你起点在哪里？这个问题是很难回答的。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250401164453.png" alt=""></p><p>19 世纪数学家就研究过椭圆曲线的性质，但到 20 世纪数学家发现椭圆曲线上的点能通过点加法这类操作组成一个阿贝尔群，这些点的数量和分布特别“诡异”——既有限，又乱得没规律。而点加法这种正向容易、逆向难的特征刚好就适用于密码学。</p><h2 id="从椭圆曲线到密码学"><a href="#从椭圆曲线到密码学" class="headerlink" title="从椭圆曲线到密码学"></a>从椭圆曲线到密码学</h2><p>Neal Koblitz 是专攻数论的数学家，对椭圆曲线很熟。他当时在研究有限域上的数学问题，注意到椭圆曲线的点群和传统离散对数有点像，但更“紧凑”。他想：如果把 Diffie-Hellman 的思路搬到椭圆曲线上，会不会更高效。</p><p>Victor Miller 在 IBM 搞应用数学，也盯着椭圆曲线的群性质。他发现，椭圆曲线的离散对数问题（ECDLP）似乎比普通离散对数还难破解，而且需要的数字（密钥长度）小得多。他俩不谋而合，都觉得这玩意儿能干大事。</p><p>他们的想法不是凭空来的，有几个关键“火花”：</p><ol><li>群论的启发：密码学里的 Diffie-Hellman 用的是乘法群，Koblitz 和 Miller 看到椭圆曲线的点群也是阿贝尔群，觉得可以“照搬”过来。</li><li>Hasse 定理：20 世纪数学家 Hasse 证明了椭圆曲线在 $F_p$ 上的点数大概是 $p + 1 \pm 2\sqrt{p}$，数量够大但分布随机，正好适合做离散对数问题。</li><li>效率优势：他们算了算，椭圆曲线的运算（点加法和倍点）虽然复杂，但用小得多的数字（比如 160 位）就能达到传统方法 1000 位的安全级别，这对硬件来说太诱人了。</li></ol><p>为什么不随便挑个别的曲线？因为椭圆曲线（三次方程）正好有“<strong>三个交点</strong>”的几何性质，点加法规则简单又优雅，其他高次曲线要么太复杂，要么安全性不够。加上数学家几百年的研究，椭圆曲线的性质已经摸得透透的，拿来用最保险。</p><p>椭圆曲线加密从 1985 年的“怪胎”到今天的核心技术，走过了从冷门到爆款的路。它的历史是个典型的“学术变实用”的故事：数学家玩了好多年的椭圆曲线，被 Koblitz 和 Miller 一挖掘成了安全的利器。</p><h2 id="secp256k1"><a href="#secp256k1" class="headerlink" title="secp256k1"></a>secp256k1</h2><p>secp256k1 是一个特殊的椭圆曲线，名字听起来高大上，其实就是密码学里用的一条数学曲线，secp256k1 的名字可以分成几个部分：</p><ul><li>sec：Standards for Efficient Cryptography（高效加密标准）。</li><li>p：Prime（素数），表示这个曲线是用素数域定义的。</li><li>256：表示这个曲线的“大小”是 256 位（也就是密钥长度）。</li><li>k：Koblitz 的缩写，指的是数学家 Neal Koblitz，他研究了这种类型的曲线。</li><li>1：表示这是 Koblitz 曲线中的第一个（最简单的一个）。</li></ul><p>它是比特币、以太坊这些区块链的“安全锁”的核心。简单说，它定义了一个“跳跃游戏”的规则，靠这个规则保护你的私钥和公钥。</p><p>secp256k1 是这么来的：</p><ul><li>方程：它的公式是 $y^2 = x^3 + 7$ 注意，这里的 $a = 0 , b = 7$，是个很简单的椭圆曲线。</li><li>有限域：它不是在普通数字上玩，而是在一个超级大的“数字圈” $F_p$ ，这里的 (p) 是个特定的素数，大约是 $2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1$。</li><li>基点 (P)：它有个固定的起跑点 (P)，坐标是 $(x_P, y_P)$，具体值很长（见下面），但它是公开的，大家都从这点开始跳。</li></ul><p>secp256k1 就像一个超级复杂的“跳格子游戏”：</p><ul><li>你挑一个秘密数字 (k)（私钥），从基点 (P) 开始，用点加法跳 (k) 次，跳到的点是 $Q = k \cdot P$<br>公钥。</li><li>别人看到 (P) 和 (Q)，想猜你跳了几次 (k)，但因为点加法逆运算（离散对数问题）太难，他们算不出来。</li></ul><p>类比一下，想象 secp256k1 是个巨大的迷宫，里面有 (p) 个格子（大概 $2^{256}$个，这个数字大到超乎想象，比宇宙里的原子、沙粒、甚至时间秒数都多得多。它不是“很大”，而是“大的离谱”）。迷宫的形状由上面的椭圆曲线决定，起点是 (P)。你拿着私钥 (k)，按迷宫的跳法（点加法）走 (k) 步，停在 (Q)。这个迷宫设计得太巧妙，别人站在 (Q) 看你走过的路，根本摸不着头脑，只能从 (P) 一步步试，试到宇宙爆炸也试不完，破解难度像“从银河系找一粒沙”。签名时，拿私钥和消息算出两个数（r, s），别人用公钥验证。</p><p>secp256k1 另外一个特点是计算快，主要来自它的特殊数学结构和参数选择。<a href="https://github.com/bitcoin-core/secp256k1?tab=readme-ov-file">bitcoin-core/secp256k1</a> 是高度优化过的 C 语言实现，用了预存表、内敛汇编等各种优化手段来提高效率。通常我们在 Rust 程序上用的也是这个库的 binding。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本来想查找更多资料来写得更详细，但我发现如此太耗费时间，倒不如先把已经理解的部分写在这里，以后如果有新的理解再丰富。在尝试理解的过程中仍然会有这种感受：<br><img src="http://catcoding.me/images/ob_pasted-image-20250402113142.png" alt=""></p><p>更多的参考资料在这里：</p><ul><li><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction - Andrea Corbellini</a> 写的一系列文章很详细</li><li>上面的程序分享在这里： <a href="https://github.com/chenyukang/elliptic-curve">chenyukang/elliptic-curve</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链这行经常会和椭圆曲线密码算法打交道，我也在尝试理解这其中的数学原理，这里记录一下。&lt;/p&gt;
&lt;h2 id=&quot;什么是椭圆曲线-elliptic-curve&quot;&gt;&lt;a href=&quot;#什么是椭圆曲线-elliptic-curve&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="编程" scheme="http://catcoding.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="区块链" scheme="http://catcoding.me/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="密码学" scheme="http://catcoding.me/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Future 的大小对性能的影响</title>
    <link href="http://catcoding.me/p/future-size-perf/"/>
    <id>http://catcoding.me/p/future-size-perf/</id>
    <published>2025-03-24T10:21:03.000Z</published>
    <updated>2025-06-11T13:12:20.578Z</updated>
    
    <content type="html"><![CDATA[<p>在 Rust 异步编程中，有一种观点认为：<strong>Future 的大小显著影响性能</strong>。你是否怀疑过这个说法的真实性？如果是真的，这种性能差异的根源又是什么？今天，我翻阅了一些源码，并编写实验代码来一探究竟。</p><h2 id="Future-的大小如何计算？"><a href="#Future-的大小如何计算？" class="headerlink" title="Future 的大小如何计算？"></a>Future 的大小如何计算？</h2><p>为了验证“Future 大小影响性能”这一说法是否成立，我们先从一些简单代码入手。首要任务是弄清楚一个 Future 的大小是如何确定的。毕竟，在编译器眼里，Future 只是一个 trait：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Future</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">type</span> <span class="token type-definition class-name">Output</span><span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">></span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'_</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么，其大小取决于实现这个 trait 的具体结构体吗？我翻阅了 smol 的源码，发现在 <a href="https://github.com/smol-rs/async-executor/blob/2d72f8705b324c386d22227720d806ea8bc4e257/async-task/src/runnable.rs#L505-L535">spawn 一个 Future</a> 时，相关代码是这样处理的：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">unsafe</span> <span class="token keyword">fn</span> <span class="token function-definition function">spawn_unchecked</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token class-name">Fut</span><span class="token punctuation">,</span> <span class="token class-name">S</span><span class="token operator">></span><span class="token punctuation">(</span>    <span class="token keyword">self</span><span class="token punctuation">,</span>    future<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">,</span>    schedule<span class="token punctuation">:</span> <span class="token class-name">S</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token class-name">Runnable</span><span class="token operator">&lt;</span><span class="token class-name">M</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token class-name">Task</span><span class="token operator">&lt;</span><span class="token class-name">Fut</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token keyword">where</span>    <span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">FnOnce</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Fut</span><span class="token punctuation">,</span>    <span class="token class-name">Fut</span><span class="token punctuation">:</span> <span class="token class-name">Future</span> <span class="token operator">+</span> <span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span>    <span class="token class-name">S</span><span class="token punctuation">:</span> <span class="token class-name">Schedule</span><span class="token operator">&lt;</span><span class="token class-name">M</span><span class="token operator">></span><span class="token punctuation">,</span>    <span class="token class-name">M</span><span class="token punctuation">:</span> <span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>    <span class="token comment">// Allocate large futures on the heap.</span>    <span class="token keyword">let</span> ptr <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token namespace">mem<span class="token punctuation">::</span></span><span class="token function">size_of</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token class-name">Fut</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2048</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> future <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>meta<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> future <span class="token operator">=</span> <span class="token function">future</span><span class="token punctuation">(</span>meta<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">pin</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">RawTask</span><span class="token punctuation">::</span><span class="token operator">&lt;</span>_<span class="token punctuation">,</span> <span class="token class-name">Fut</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token punctuation">,</span> <span class="token class-name">S</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> schedule<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RawTask</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token class-name">Fut</span><span class="token punctuation">,</span> <span class="token class-name">Fut</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token punctuation">,</span> <span class="token class-name">S</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> schedule<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> runnable <span class="token operator">=</span> <span class="token class-name">Runnable</span><span class="token punctuation">::</span><span class="token function">from_raw</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> task <span class="token operator">=</span> <span class="token class-name">Task</span> <span class="token punctuation">&#123;</span>        ptr<span class="token punctuation">,</span>        _marker<span class="token punctuation">:</span> <span class="token class-name">PhantomData</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到 <code>mem::size_of::&lt;Fut&gt;()</code> 是在计算这个 Future 的大小，我来写个简单的 Future 验证：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">async_executor<span class="token punctuation">::</span></span><span class="token class-name">Executor</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">futures_lite<span class="token punctuation">::</span></span>future<span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>future<span class="token punctuation">::</span></span><span class="token class-name">Future</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>pin<span class="token punctuation">::</span></span><span class="token class-name">Pin</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>task<span class="token punctuation">::</span></span><span class="token punctuation">&#123;</span><span class="token class-name">Context</span><span class="token punctuation">,</span> <span class="token class-name">Poll</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">LargeFuture</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">;</span> <span class="token number">10240</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">Future</span> <span class="token keyword">for</span> <span class="token class-name">LargeFuture</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">type</span> <span class="token type-definition class-name">Output</span> <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">></span><span class="token punctuation">,</span> _cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'_</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"First byte: &#123;&#125;"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> ex <span class="token operator">=</span> <span class="token class-name">Executor</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> large_future <span class="token operator">=</span> <span class="token class-name">LargeFuture</span> <span class="token punctuation">&#123;</span> data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0u8</span><span class="token punctuation">;</span> <span class="token number">10240</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">block_on</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">&#123;</span> ex<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span>large_future<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Result: &#123;&#125;"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面那个 async-task 的 <code>spawn_unchecked</code> 函数加上日志，打印出来的大小为 <code>10256</code>，刚好比这个 struct 的大小大 16，顺着代码往上可以看到<a href="https://github.com/smol-rs/async-executor/blob/2d72f8705b324c386d22227720d806ea8bc4e257/src/lib.rs#L250">这里</a>在原始的 Future 上做了一个封装，这里的意思是如果这个 Future 以后执行完，需要从 runtime 里面删掉：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> future <span class="token operator">=</span> <span class="token class-name">AsyncCallOnDrop</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>future<span class="token punctuation">,</span> <span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token function">drop</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token function">active</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">try_remove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这解释了尺寸略有增加的原因。对于结构体的尺寸，我们不难理解，但对于 async 函数，其大小又是如何计算的呢？这就涉及 Rust 编译器对 async 的转换机制。</p><h2 id="异步状态机：冰山之下的庞然大物"><a href="#异步状态机：冰山之下的庞然大物" class="headerlink" title="异步状态机：冰山之下的庞然大物"></a>异步状态机：冰山之下的庞然大物</h2><p>当你写下一个简单的 <code>async fn</code> 函数时，Rust 编译器在幕后悄然完成了一场复杂的转换：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">usize</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0u8</span><span class="token punctuation">;</span> <span class="token number">102400</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">yield_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>    data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码会被编译器转化为一个庞大的状态机，负责追踪执行进度并保存所有跨越 <code>.await</code> 点的变量。转换后的结构体封装了状态切换的逻辑：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">FunctionState</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 初始状态</span>    <span class="token class-name">Initial</span><span class="token punctuation">,</span>    <span class="token comment">// yield_now 挂起后的状态，必须包含所有跨 await 点的变量</span>    <span class="token class-name">Suspended</span> <span class="token punctuation">&#123;</span>        data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">;</span> <span class="token number">102400</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 整个大数组必须保存！</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// 完成状态</span>    <span class="token class-name">Completed</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 2. 定义状态机结构体</span><span class="token keyword">struct</span> <span class="token type-definition class-name">FunctionFuture</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当前状态</span>    state<span class="token punctuation">:</span> <span class="token class-name">FunctionState</span><span class="token punctuation">,</span>    <span class="token comment">// yield_now future</span>    yield_fut<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">YieldNow</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">Future</span> <span class="token keyword">for</span> <span class="token class-name">FunctionFuture</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 3. 为状态机实现 Future traitimpl Future for FunctionFuture &#123;</span>    <span class="token keyword">type</span> <span class="token type-definition class-name">Output</span> <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">poll</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">:</span> <span class="token class-name">Pin</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">Self</span><span class="token operator">></span><span class="token punctuation">,</span> cx<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Context</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'_</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Poll</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 安全地获取可变引用</span>        <span class="token keyword">let</span> this <span class="token operator">=</span> <span class="token keyword">unsafe</span> <span class="token punctuation">&#123;</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">get_unchecked_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">match</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> this<span class="token punctuation">.</span>state <span class="token punctuation">&#123;</span>            <span class="token class-name">FunctionState</span><span class="token punctuation">::</span><span class="token class-name">Initial</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 创建大数组及其长度</span>                <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0u8</span><span class="token punctuation">;</span> <span class="token number">102400</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 创建 yield future 并保存</span>                this<span class="token punctuation">.</span>yield_fut <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">yield_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 状态转换，保存所有需要跨越 await 的数据</span>                this<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token class-name">FunctionState</span><span class="token punctuation">::</span><span class="token class-name">Suspended</span> <span class="token punctuation">&#123;</span> data <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                <span class="token comment">// 立即轮询 yield</span>                <span class="token keyword">match</span> <span class="token class-name">Pin</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> this<span class="token punctuation">.</span>yield_fut<span class="token punctuation">.</span><span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 如果立即完成，返回结果</span>                        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">FunctionState</span><span class="token punctuation">::</span><span class="token class-name">Suspended</span> <span class="token punctuation">&#123;</span> data <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>this<span class="token punctuation">.</span>state <span class="token punctuation">&#123;</span>                            <span class="token keyword">let</span> result <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>                            this<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token class-name">FunctionState</span><span class="token punctuation">::</span><span class="token class-name">Completed</span><span class="token punctuation">;</span>                            <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                            <span class="token macro property">unreachable!</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=></span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">FunctionState</span><span class="token punctuation">::</span><span class="token class-name">Suspended</span> <span class="token punctuation">&#123;</span> data <span class="token punctuation">&#125;</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 继续轮询 yield</span>                <span class="token keyword">match</span> <span class="token class-name">Pin</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> this<span class="token punctuation">.</span>yield_fut<span class="token punctuation">.</span><span class="token function">as_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>cx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// yield 完成，读取数组首元素并返回</span>                        <span class="token keyword">let</span> result <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>                        this<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token class-name">FunctionState</span><span class="token punctuation">::</span><span class="token class-name">Completed</span><span class="token punctuation">;</span>                        <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Ready</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>                    <span class="token punctuation">&#125;</span>                    <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span> <span class="token operator">=></span> <span class="token class-name">Poll</span><span class="token punctuation">::</span><span class="token class-name">Pending</span><span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">FunctionState</span><span class="token punctuation">::</span><span class="token class-name">Completed</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token macro property">panic!</span><span class="token punctuation">(</span><span class="token string">"Future polled after completion"</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>Suspended</code> 状态中包含了那个大数组。当状态从 <code>Initial</code> 切换到 <code>Suspended</code> 时，<code>data</code> 会被完整保留。</p><p>由此可知，对于一个 async 函数，若临时变量需跨越 await 存活，就会被纳入状态机，导致编译时生成的 Future 大小显著增加。</p><h2 id="尺寸对性能的影响"><a href="#尺寸对性能的影响" class="headerlink" title="尺寸对性能的影响"></a>尺寸对性能的影响</h2><p>明确了 Future 大小的定义后，我们接着通过代码验证其对性能的影响。在之前的 <code>mem::size_of::&lt;Fut&gt;() &gt;= 2048</code> 条件中可以看到，如果 Future 的大小过大，<code>Box::pin(future)</code> 会从堆上分配内存，理论上会带来额外开销。这种设计可能基于几点考量：小型 Future 直接嵌入任务结构体中，能提升缓存命中率；而大型 Future 若嵌入，会让任务结构体过于臃肿，占用过多栈空间，反而不利于性能。</p><p>我通过实验验证，若 async 函数中包含较大的结构体，确实会导致 Future 执行变慢（即便计算逻辑相同）：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">RESULTS:--------Small Future (64B): 100000 iterations in 30.863125ms (avg: 308ns per iteration)Medium Future (1KB): 100000 iterations in 61.100916ms (avg: 611ns per iteration)Large Future (3KB): 100000 iterations in 105.185292ms (avg: 1.051µs per iteration)Very Large Future (10KB): 100000 iterations in 273.469167ms (avg: 2.734µs per iteration)Huge Large Future (100KB): 100000 iterations in 5.896455959s (avg: 58.964µs per iteration)PERFORMANCE RATIOS (compared to Small Future):-------------------------------------------Medium Future (1KB): 1.98x slowerLarge Future (3KB): 3.41x slowerVery Large Future (10KB): 8.88x slowerHuge Large Future (100KB): 191.44x slower<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在微调这个 async 函数时，我发现了一些微妙的现象。为了让 <code>data</code> 跨越 await 存活，我特意在最后引用了它，以防编译器优化掉：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">huge_large_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u64</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1u8</span><span class="token punctuation">;</span> <span class="token number">102400</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 10KB * 10</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">yield_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> data<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u64</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理论上，若改成下面这样，由于 <code>len</code> 在 await 前已计算完成，后面又没用引用到，生成的 Future 大小应该很小：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">huge_large_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u64</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1u8</span><span class="token punctuation">;</span> <span class="token number">102400</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 10KB * 10</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">yield_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>    <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> ex <span class="token operator">=</span> <span class="token class-name">Executor</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> task <span class="token operator">=</span> ex<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token function">huge_large_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">block_on</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">eprintln!</span><span class="token punctuation">(</span><span class="token string">"Result: &#123;&#125;"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，我发现 <code>data</code> 仍被保留在状态机中，即便 <code>len</code> 未被后续使用。这涉及到编译器如何判断变量是否跨越 await 存活的问题。当然，若显式限定 <code>data</code> 的生命周期在 await 之前，它就不会被纳入状态机：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">async</span> <span class="token keyword">fn</span> <span class="token function-definition function">huge_large_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u64</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1u8</span><span class="token punctuation">;</span> <span class="token number">102400</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 10KB * 10</span>        <span class="token keyword">let</span> len <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token namespace">future<span class="token punctuation">::</span></span><span class="token function">yield_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">await</span><span class="token punctuation">;</span>    <span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译器如何判断哪些变量应该保存"><a href="#编译器如何判断哪些变量应该保存" class="headerlink" title="编译器如何判断哪些变量应该保存"></a>编译器如何判断哪些变量应该保存</h2><p>我查阅了 Rust 编译器的源码，发现变量是否跨越 await 存活由 <a href="https://github.com/chenyukang/rust/blob/c089b1fe7d6b8ef5889f820fd8be4f78bb7efe42/compiler/rustc_mir_transform/src/coroutine.rs#L655-L660">locals_live_across_suspend_points 函数</a> 决定：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// The basic idea is as follows:</span><span class="token comment">/// - a local is live until we encounter a `StorageDead` statement. In</span><span class="token comment">///   case none exist, the local is considered to be always live.</span><span class="token comment">/// - a local has to be stored if it is either directly used after the</span><span class="token comment">///   the suspend point, or if it is live and has been previously borrowed.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我们的代码中，<code>let len = data.len()</code> 构成了对 <code>data</code> 的借用，因此 <code>data</code> 被保留在状态机中。或许这里仍有优化的空间？我去社区问问看。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>所有实验代码均可在以下链接找到：<a href="https://github.com/chenyukang/async-executor/tree/yukang-post/examples">async-executor-examples</a>。</p><p>在 Rust 异步编程中，代码的细微调整可能引发性能的显著波动。深入理解状态机生成的内在机制，能助你打造更高效的异步代码。下次编写 <code>async fn</code> 时，不妨自问：这个状态机究竟有多大？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Rust 异步编程中，有一种观点认为：&lt;strong&gt;Future 的大小显著影响性能&lt;/strong&gt;。你是否怀疑过这个说法的真实性？如果是真的，这种性能差异的根源又是什么？今天，我翻阅了一些源码，并编写实验代码来一探究竟。&lt;/p&gt;
&lt;h2 id=&quot;Future-的大
      
    
    </summary>
    
    
      <category term="编程" scheme="http://catcoding.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Fiber Network: 基于 CKB 实现的闪电网络</title>
    <link href="http://catcoding.me/p/fiber-network-on-ckb/"/>
    <id>http://catcoding.me/p/fiber-network-on-ckb/</id>
    <published>2025-03-16T08:53:04.000Z</published>
    <updated>2025-06-11T13:12:20.577Z</updated>
    
    <content type="html"><![CDATA[<p>最近一年我在做 <a href="https://github.com/nervosnetwork/fiber">Fiber Network</a> 这个新的开源项目，上个月底刚好<a href="https://x.com/FiberDevs/status/1895486339505893880">主网第一个版本发布</a>：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250316084708.png" alt=""></p><p>这个项目的挑战还是挺大的，上主网只是一个新的开始。我在开发过程中学到了很多东西，这是我前段时间写的一篇关于 Fiber 的大致介绍。</p><h2 id="Fiber-简介"><a href="#Fiber-简介" class="headerlink" title="Fiber 简介"></a>Fiber 简介</h2><p>Fiber 是基于 CKB 构建的闪电网络协议，旨在实现快速、安全且高效的链下支付解决方案。借鉴了比特币闪电网络的核心理念，Fiber 针对 CKB 的独特架构进行了深度优化，提供低延迟、高吞吐量的支付通道，适用于微支付和高频交易等场景。与传统的闪电网络不同，Fiber 拥有多项关键特性：</p><ul><li><strong>多资产支持</strong>：不再局限于单一币种，能够处理多种资产交易，为复杂的跨链金融应用铺平道路。</li><li><strong>可编程性</strong>：基于 CKB 的图灵完备智能合约，支持更复杂的条件执行和业务逻辑，拓展了支付通道的应用边界。</li><li><strong>跨链互操作性</strong>：原生设计支持与其他 UTXO 链（如比特币）的闪电网络交互，提升了链间资产流动性和网络兼容性。</li><li><strong>更灵活的状态管理</strong>：得益于 CKB 的 Cell 模型，Fiber 可以更高效地管理通道状态，降低链下交互的复杂度。</li></ul><p>在这篇文章中，我们将从源码层面介绍 Fiber 的整体架构和主要模块，以及项目的后续展望和规划。</p><h3 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h3><ul><li>Rust, and <a href="https://github.com/slawlor/ractor">actor framework</a>，Fiber 是一个完全由 Rust 编程语言所实现的项目，另外我们在实现中采用了 actor model 的模式，依赖社区的项目 <a href="https://github.com/slawlor/ractor">ractor</a> 框架。</li><li>Lightning network，Fiber 的基本思想沿用了 Bitcoin 的闪电网络，基本原理是一致的，所以  <a href="https://github.com/lnbook/lnbook">Mastering lightning network</a> 和 Bolts: <a href="https://github.com/lightning/bolts">lightning/bolts</a> 是非常有用的参考资料。</li><li>CKB transaction and contract，Fiber 会通过 RPC 与 CKB node 进行交互，比如 funding transaction 或者 shutdown commitment transaction 可能需要通过 RPC 提交给 CKB 的节点，所以掌握 Fiber 需要了解一些 CKB 合约开发方面的知识。</li></ul><h2 id="重要模块"><a href="#重要模块" class="headerlink" title="重要模块"></a>重要模块</h2><p>我们从最高纬度去看一个 Fiber Node，主要包含下面几个主要模块：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250316082730.png" alt=""></p><p>其中：</p><ul><li>Network Actor 是 Fiber Node 中负责节点内外的消息通信</li><li>Network graph 包含一个节点对于整个网络里其他节点和 channel 的信息，当一个 Fiber Node 收到一个支付请求的时候，我们首先会尝试从 network graph 中找到一条路径能够触达收款节点，这个 network graph 结构是跟着网络上的 gossip 信息不断更新的</li><li>PaymentSession 负责管理一个支付的生命周期</li><li><a href="https://github.com/cryptape/fiber-sphinx">fiber-sphinx</a> 是我们自己实现的 onion packet 加解密 Rust 库</li><li>Gossip 是 Fiber 节点之间的交换网络消息的协议，用于 Node 和 Channe 的发现和更新。</li><li>Watchtower，这里负责监听 Fiber node 所关心的 channel 里面的重要事件，另外如果某个 Node 提交一个老的 commitment transaction，watch tower 负责发出 revocation transaction 来进行惩罚</li><li>Cross hub，这个模块负责跨链的互操作，比如付款者通过 Bitcoin 的闪电网络发出 Bitcoin，而接收者收到的是 CKB，cross hub 这里会进行一个转换，将 Bitcoin 的 payment 和 invoice 和 Fiber 这边的 payment 和 invoice 进行映射管理</li><li><a href="https://github.com/nervosnetwork/fiber-scripts/tree/main">Fiber-script</a> 在一个单独的代码仓库，这里面包含了两个主要的合约，<a href="https://github.com/nervosnetwork/fiber-scripts/tree/main/contracts/funding-lock">funding-lock</a> 是一个资金锁定合约，使用 ckb-auth 库来实现一个 2-of-2 多重签名，<a href="https://github.com/nervosnetwork/fiber-scripts/tree/main/contracts/commitment-lock">commitment-lock</a> 实现了 <a href="https://eprint.iacr.org/2022/1295">daric</a> 协议来作为 Fiber 的惩罚机制</li></ul><h3 id="Actor-Model-和-Channel-管理"><a href="#Actor-Model-和-Channel-管理" class="headerlink" title="Actor Model 和 Channel 管理"></a>Actor Model 和 Channel 管理</h3><p>Channel 的管理是闪电网络中非常重要、也是异常复杂的部分。其中的复杂性主要来自于 Channel 内部数据和状态的改变来自于网络上 peer 之间的交互，事件的处理可能存在并发上的问题，一个 Channel 的双边可能同时都有 TLC 的操作。</p><p>闪电网络本质上是一个 P2P 系统，节点之间通过网络消息相互通信进而改变内部的数据状态，我们发现 Actor Model 非常适合这种场景：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250316082740.png" alt=""></p><p>Actor Model 极大地简化了代码实现的复杂度，使用 Actor model 后我们不需要使用锁来保护数据的更新，当一个  Message handle 结束的时候，我们会把 <a href="https://github.com/nervosnetwork/fiber/blob/81014d36502b76e2637dfa414b5a3ee494942c41/src/fiber/channel.rs#L2276">channel state 的数据更新写入 db</a>。而像 rust lightning 如果没用使用 actor model，就可能会涉及到非常复杂的<a href="https://github.com/lightningdevkit/rust-lightning/blob/b8b1ef3149f26992625a03d45c0307bfad70e8bd/lightning/src/ln/channelmanager.rs#L1167">锁相关的操作</a>。</p><p>我们的所有的重要模块都采用了 Actor Model，<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/network.rs#L694-L789">Network Actor</a>负责节点内外的消息通信，比如一个节点要给另外一个节点发送 Open channel 的消息，这个消息首先会通过 Fiber node A 的 channel actor 发送到 network actor，node A 的 network actor 通过更底层的网络层 tentacle 发送到 node B 的 network actor，然后 network actor 再发给 node B 里面的所对应的 channel actor。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250316082758.png" alt=""></p><p>在一个 Fiber Node 内部，每一个新的 Channel 我们都会建立一个对应的 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/channel.rs#L301-L308">ChannelActor</a>，而这个 ChannelActorState 里面包含了这个 Channel 所需要持久化的所有的数据。采用 Actor Model 的另外一个好处就是我们能够在代码实现过程中直观地把 HTLC 网络协议相关的操作映射到一个函数里，比如下图中展示了 HTLC 在多个节点之间的流转过程，对于 A 到 B 之间的 AddTlc 操作，节点 A 里的 actor 0 所应对的代码实现就是 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/channel.rs#L1251">handle_add_tlc_command</a>，而节点 B 里的 actor 1 所对应的代码实现是 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/channel.rs#L1069">handle_add_tlc_peer_message</a>。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250316082810.png" alt=""></p><p>Channel 之间的 TLC 操作是复杂度非常高的部分，我们在实现上延用了 rust-lightning 的方式，<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/channel.rs#L2463-L2496">使用状态机来表示 TLC 的状态</a>，根据 actor 之间的 commitment_sign 和 revoke_ack 的消息来改变状态机，总的来说 AddTlc 的操作流程和两个 Peer TLC 状态的改变过程如下：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250316082818.png" alt=""></p><h3 id="支付和多跳路由"><a href="#支付和多跳路由" class="headerlink" title="支付和多跳路由"></a>支付和多跳路由</h3><p>每个 Fiber 节点都通过 Network graph 保存了自己对于整个网络的了解情况，本质上这是一个双向有向图，每一个 Fiber 节点对应于 Graph 里面的一个 vertex，每一个 Channel 对应于 Graph 里面的一个 edge，出于隐私保护的需求，Channel 的真实 balance 不会广播到网络中，所有 edge 的大小是 Channel 的 capacity。</p><p>在支付开始前，发起者会通过路径规划找到一条通往收款者的路径，如果有多条路径就需要找到各方面综合考虑最优的路径，而在信息缺失的图中找到最优路径是一个在工程上非常具有挑战性的问题，<a href="https://github.com/lnbook/lnbook/blob/develop/12_path_finding.asciidoc#pathfinding-what-problem-are-we-solving">Mastering Lightning Network 对这个问题有很详细的介绍</a>：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250316082831.png" alt=""></p><p>在 Fiber 中，支付动作由用户向 Fiber Node <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/rpc/payment.rs#L171-L209">通过 RPC 发起请求</a>，节点收到请求后会创建对应的 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/network.rs#L1866-L1871">PaymentSession</a> 来追踪支付的生命周期。</p><p>目前我们的路径规划的算法是一个<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/graph.rs#L914-L925">变形的 Dijkstra 算法</a>，这个算法是通过 target 往 source 方向扩展的，搜索路径的过程中通过折算支付成功的概率、fee、TLC 的 lock time 这些因素到一个 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/graph.rs#L1110">weight 来进行排序</a>。其中的概率估算来自于每次支付的结果记录和分析，实现在 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/history.rs#L481-L506">eval_probability</a>。路径的选择质量好坏对于整个网络的效率和支付的成功率非常重要，这部分我们今后将会继续改进，<em>Multipart payments (MPP)</em> 也是一个今后可能要实现的功能。</p><p>路径规划完成后下一步就是<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/network.rs#L1634-L1656">构建 Onion Packet</a>，然后给通过 source node 发起 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/network.rs#L1657-L1667">AddTlcCommand</a>。后续如果 TLC 失败或者成功会通过事件通知的方式处理。</p><p>整个支付的过程可能会发生多次的重试，一个常见的场景就是我们使用 capacity 作为 Graph 里边的容量，可能路径规划出来的路线无法真实满足支付的大小，所以我们需要返回错误并更新 Graph，然后再继续自动发起<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/network.rs#L1767-L1772">下一次路径规划尝试进行支付</a>。</p><h3 id="节点广播协议-Gossip"><a href="#节点广播协议-Gossip" class="headerlink" title="节点广播协议 Gossip"></a>节点广播协议 Gossip</h3><p>Fiber 的节点之间的通过相互发送广播消息交换新的 Node 和 Channel 信息，Fiber 中的 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/gossip.rs#L293-L331">Gossip 模块</a>实现了 <a href="https://github.com/lightning/bolts/blob/master/07-routing-gossip.md">Botls 7 定义的 routing gossip</a>。在实现过程中我们的主要技术决策在这个 <a href="https://github.com/nervosnetwork/fiber/pull/308">PR: Refactor gossip protocol</a>里面有描述。</p><p>当一个 Node 节点第一次启动的时候，会通过配置文件里的 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/network.rs#L3169-L3174">bootnode_addrs</a>来的连接第一批 peers，广播消息的类型有三类：<code>NodeAnnouncement</code> 、<code>ChannelAnnouncement</code> 、<code>ChannelUpdate</code> 。</p><p>Fiber 会把收到的<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/store/store.rs#L482-L711">广播的原始数据保存下来</a>，这样方便通过 timestamp + message_id 组合的 cursor 来对广播消息进行检索，以方便来自 peer node 的 query 请求。</p><p>当一个节点启动的时候，Graph 模块会通过 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/graph.rs#L361">load_from_store</a>来读取所有的 messages，重新构建自己的 network graph。</p><p>我们采用基于订阅的方式在网络中传播消息。一个节点需要主动向另一个节点发送广播消息过滤器（BroadcastMessagesFilter），另一个节点收到了该消息之后会为其创建对应的 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/gossip.rs#L599-L614">PeerFilterActor</a>，在构造函数里创建 Gossip 消息订阅。通过基于订阅的模型这种方式，我们可以让其他节点接收在特定的 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/gossip.rs#L1027-L1049">cursor 之后接收到新保存的 Gossip 消息</a>。</p><h3 id="隐私-Onion-加解密"><a href="#隐私-Onion-加解密" class="headerlink" title="隐私 Onion 加解密"></a>隐私 Onion 加解密</h3><p>处于隐私保护的需求，payment 的 TLC 在多个节点之间传播的时候，每个节点只能知道自己所需要的信息，比如当前节点接收的 TLC 的 amount、expiry、下一个传播的节点等信息，而无法获得其他不必要的信息，而且每个 hop 在发送 TLC 给下一个节点的时候也需要做相应的混淆。</p><p>类似的，如果 payment 在某个节点传播的过程中发生了错误，这个节点也可能返回一个错误信息，而这个错误信息会通过 payment 的 route 反向传递给 payment 的发起节点。这个错误信息也是需要 Onion 加密的，这样确保中间节点无法理解错误的具体内容，而只有发送者能够获得错误内容。</p><p>我们参考了 rust-lightning 在 <a href="https://github.com/lightningdevkit/rust-lightning/blob/master/lightning/src/ln/onion_utils.rs">onion packet 的实现</a>，发现其实现方式还是不够通用 (会绑定于其项目的具体数据结构)，所以我们自己从头开始实现了 <a href="https://github.com/cryptape/fiber-sphinx/blob/develop/docs/spec.md">fiber-sphinx</a>，更详细的内容请参考项目的 spec。</p><p>涉及到 Onion 加解密的几个关键节点在这三个地方：</p><ul><li>send payment 的时候<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/network.rs#L1640-L1666">创建 onion packet</a>，作为 AddTlcCommand 里的一个字段发送给第一个 hop</li><li>payment route 中的每个节点收到 TLC 之后，尝试去解开 <a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/channel.rs#L920-L937">Onion Packet 的一层</a>，就像是剥离一层洋葱皮一样，如果判断自己是接收者则处理 payment settle 相关的逻辑，如果发现后续还有接收者则处理了 TLC 相关的逻辑之后继续<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/channel.rs#L1037-L1064">往下一个 hop 传递剩下的 onion packet</a>。</li><li>如果某个 Hop 在转发 TLC 的过程中出现错误就<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/channel.rs#L774-L797">生成一个新的包含有错误信息的 onion packet</a>，并向前一个 hop 发送 onion packet。</li><li>payment 的发起者收到 TLC fail event 的时候，从其中<a href="https://github.com/nervosnetwork/fiber/blob/e7bb8874e308445fdf63a5bc538fc00c100f3dc9/src/fiber/network.rs#L1518-L1527">解开包含有错误信息的 onion packet</a>，然后根据错误信息去判断是否需要重试和更新 Network graph。</li></ul><p><img src="http://catcoding.me/images/ob_pasted-image-20250316082911.png" alt=""></p><h3 id="Watchtower"><a href="#Watchtower" class="headerlink" title="Watchtower"></a>Watchtower</h3><p>Watchtower 是闪电网络中的重要安全机制，主要用于帮助离线用户防止资金被盗。它通过实时监测链上交易，并在发现违规行为时执行惩罚交易，从而维护闪电网络的公平性和安全性。</p><p>Fiber 的 watchtower 实现在 <a href="https://github.com/nervosnetwork/fiber/blob/b5c38a800e94aaa368a4c8a8699f5db0c08ecfbd/src/watchtower/actor.rs#L73-L124">WatchtowerActor</a>里，这个 actor 会监听 Fiber 节点中发生的关键事件，比如一个新的 Channel 创建成功时将会收到 <code>RemoteTxComplete</code>，watchtower 就在数据库里插入一条对应的记录来开始监听这个通道，Channel 双方协商成功关闭时会收到 <code>ChannelClosed</code>，watchtower 从数据库中移除对应的记录。</p><p>在 Channel 中 TLC 交互时候，watchertower 将会收到 <code>RemoteCommitmentSigned</code> 和 <code>RevokeAndAckReceived</code>，分别去更新数据库中存储的 <code>revocation_data</code> 和 <code>settlement_data</code>，这些字段将会在后续创建 revocation transaction 和 settlement trasaction 的时候用到。</p><p>Watchtower 的惩罚机制是通过<a href="https://github.com/nervosnetwork/fiber/blob/b5c38a800e94aaa368a4c8a8699f5db0c08ecfbd/src/watchtower/actor.rs#L266">比较 <code>commitment_number</code> </a>来判断 CKB 的链上交易是否使用了老的 commitment transaction，如果发现违规则构建一个 revocation transaction 提交到链上进行惩罚，否则就构建发送一个 settlement transaction 提交到链上。</p><h3 id="其他技术决策"><a href="#其他技术决策" class="headerlink" title="其他技术决策"></a>其他技术决策</h3><ul><li>存储：我们使用 RocksDB 作为存储层，写代码的过程中可以直接使用 serde 来序列化。但因为 scheme-less，所以不同版本的数据迁移仍然是一个挑战，我们通过这个<a href="https://github.com/nervosnetwork/fiber/blob/develop/migrate/src/main.rs">独立程序</a>来解决，比较粗暴，但目前没想到更好的办法。</li><li>序列化：节点间的消息使用 Molecule 进行序列化和反序列化，带来效率、兼容性和安全性优势。要确保确定性，这样相同的消息在所有节点上序列化方式相同，这对于签名生成和验证非常重要。</li></ul><h2 id="后续展望"><a href="#后续展望" class="headerlink" title="后续展望"></a>后续展望</h2><p>目前 Fiber 还处于前期活跃开发阶段，后续我们可能将继续做以下几个方面的改进：</p><ul><li>修复还未处理好的 corner case，增强项目整体的健壮性</li><li>目前的 cross hub 还处于 Demo 阶段，我们会对这部分增加如 payment session 等功能</li><li>完善支付路由规划算法，可能会引入其他路径搜索策略，以适应用户不同的路由偏好和需求</li><li>扩展合约的功能，比如引入基于版本号的撤销机制和更安全的 Point Time-Locked Contracts</li></ul><p>Let’s scale P2P finance together! 🩵</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一年我在做 &lt;a href=&quot;https://github.com/nervosnetwork/fiber&quot;&gt;Fiber Network&lt;/a&gt; 这个新的开源项目，上个月底刚好&lt;a href=&quot;https://x.com/FiberDevs/status/1895486
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://catcoding.me/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
      <category term="Fiber" scheme="http://catcoding.me/tags/Fiber/"/>
    
  </entry>
  
  <entry>
    <title>2024：简单的理想生活</title>
    <link href="http://catcoding.me/p/2024-summary/"/>
    <id>http://catcoding.me/p/2024-summary/</id>
    <published>2025-01-01T00:03:41.000Z</published>
    <updated>2025-06-11T13:12:20.573Z</updated>
    
    <content type="html"><![CDATA[<p>2024 年快结束了，在这最后的一两个小时里我写着这篇年终总结准备跨年了，顺着大致时间线来回顾一下就好了。</p><p>年初就起了个好头，众多加密货币开始上涨。总体而言，2024 年是个加密货币和区块链的大年。有那么一小段时间我每天都在关注涨跌，渐渐地我发现这个领域涨跌都是太频繁了，而过多关注除了浪费时间并没有什么大的用处。因为两年前开始在这个领域工作，所以我自然也会投资一些加密货币。刚开始我稍微接触了一下合约，但很快亏掉了几千元，算是交了学费。然后很快理智地退出了，合约本质上来说和赌博有点类似，钱来得也快亏得也快，但大概率是要亏钱的。</p><p>我听从了一些行业老鸟的建议，拿住比特币就行，其他的看着买点。我从 2023 年开始陆续买入了一些比特币，当时的价格不算高，到今年年底看来也有不少涨幅了。我抱着长期拿住的心态在买入，打算至少持有八九年以上。所以现在我基本不怎么关心价格了，如果买了就当作这钱是存在那里好了，把时间幅度拉长，我相信比特币未来会更值钱。我愿意相信这个行业是因为从技术的角度考虑是即有趣又有挑战。这两年来我工作的项目和比特币是非常类似的，就当作为信仰充值。</p><p>2024 年 5 月开始我投入到了公司的一个新项目开发上，这是个完全开源的项目叫作 <a href="https://github.com/nervosnetwork/fiber">nervosnetwork/fiber</a>，简而言之就是 CKB 上的闪电网络实现。所以 2024 年的大部分时间我都专注于这个项目，因为这是个新项目所以很多功能都是从头开始实现，这对于程序员来说时段快乐时光，毕竟维护老项目很多时候都是在考虑兼容性，没有什么大量写代码的快感。</p><p><a href="https://zh.wikipedia.org/wiki/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C">闪电网络</a>似乎现在已经过了最火的时候，但却是古典区块链技术的代表。如何在去中心的环境中构建出信任通道，这是个非常复杂的问题，大多数时候我们都是在参考 <a href="https://github.com/lightning/bolts/tree/master">BOLT</a>这个规范。开发过程中一直需要考虑的是这样安全么，如果对方出错或者发出恶意的请求会怎样，channel 的基本保证是任何时候任意一方都可以退出，而不会造成资金上的损失，另外还需要兼顾的是隐私的问题，所以支付的多跳传输需要使用洋葱加密，错误的返回链路上也需要用洋葱加密。反正本质上，这些都归结为数学问题，多签、加密和解密、哈希时间锁合约，确保了交易的不可伪造性和隐私性。我不打算继续在这篇文中写更多关于闪电网络的技术细节，也许以后会写一系列的相关文章。</p><p>总体来说，2024 年又开心地写了一年代码，甚至我觉得技术越做越有意思了：<br><img src="http://catcoding.me/images/ob_pasted-image-20241228233657.png" alt=""></p><p>远程工作两年后，我更多采用把问题留在脑海中，时不时拿出来思考的工作方式。有几次这样的经历，我像是在睡觉的过程中还在思考某个问题，然后第二天起来还记得当时想出来的办法。</p><p>另一方面，有些遗憾的是我今年参与 Rust 等开源项目的时间比较少了，写文章也比较少。似乎在公司的项目上工作得足够有趣、找到了足够的收获感，没有多少动力和时间去做其他项目。但意想不到的是今年年底还是收到了 Rust 基金会的邮件，愿意资助我一年继续做贡献。所以明年我应该还是会把一些业余时间投入到 Rust 项目上，这也算是把爱好折腾成了责任和义务。可以说 Rust 延长了我的技术生命，让我幸运地投入到一堆 Rust 开源项目上，并且找到适合自己的公司，以远程的方式工作。</p><p>因为整天除了带娃和宅在家编程，2024 年我似乎没认识什么新的人，社交圈很小，甚至到了年底我才想起是不是该约上许久不见的朋友线下聊聊。我不知道如何解决这个问题，这有一半是远程工作带来的副作用，另一半就是人到中年在社交上的需求小了。我还在 Cambly 上练习口语，这已经变成了我强迫自己和人沟通的一个渠道，我每周三节课一共一个半小时，其中一个小时大多数都是和我的固定老师聊，他比我大 10 岁左右，我们聊过很多话题，我给他科普区块链等技术领域、做模拟演讲等。另外我喜欢找那些一直在旅游的人或者退休了的人聊，因为通常能听到一些好玩的事情，有次有个一直满世界漂流的人对我说他希望的是 die with my boots on，我一下子没听出其含义，后来通过他的解释我知道了这个俗语的意思：一个穿着靴子死去的人会一直生活和战斗到最后，他们像往常一样生活时去世，而不是因为年老和因疾病、体弱等卧床不起，对他来说他希望自己死在旅游的途中。我想这种生活态度真是太好了，而且他也在践行自己的这种生活方式。我喜欢看那些一直在路上的博主，比如 <a href="https://www.youtube.com/@shisanyao/videos">十三要和拳头</a> 和 <a href="https://www.youtube.com/@liuweiyuan">刘伟元的旅行</a>，可能正是因为我已经不太可能做到像他们那样随心所欲地玩耍。</p><p>说到旅行，今年五月底公司团建我们去了大理待了一周，那里的风景和气候都还挺不错，有些地方显得商业化太重，但沿着洱海骑行和在苍山徒步都非常惬意。夏天我和家人去了一趟北方，走的是比较热门的路线，青岛、威海、大连。不过这趟很累，因为暑假期间都是家长带着孩子，所以去哪里都是人挤人，但其实孩子们也还太小，他们只是想找个地方玩沙子赶海，而对于历史遗迹之类的地方则完全不感兴趣。</p><p>11 月公司组织去了趟清迈，我们在那里举行了第一次的 <a href="https://www.bitgetapps.com/zh-CN/news/detail/12560604322596">CKCON</a>，我也是第一次用英语做技术演讲。感觉清迈的基础设施还有待提升，有一次我一个人打车，司机好像是中途拐进了城中小道上歪歪扭扭的乱窜，我开始担心自己会不会被拉去割腰子。其实司机是个好人，到了终点后我才发现自己的 Grab 不能付款，他就耐心得等我去找人借现金。</p><p>我很喜欢公司组织的线下聚会，不但可以和平时合作的同事见面聊聊，也可以暂时从一直带娃的生活中抽离出来，每次出去我的感受是这样的：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20241229004417.png" alt=""></p><p>所以带孩子真的很累么？确实比较累，而且得看这个孩子是几岁。我喜欢带两三岁到五岁这个年龄段的孩子，因为这时候的孩子都是天真，又比较听话。像我大女儿到了七岁八岁，开始有自主意识了就很淘气，很多时候也不怎么听话，有时候会让我焦头烂额。小学二年级的作业比较多，我女儿每天需要在家里花大概一个小时来写作业，而且现在的数学作业看起来很多应用题，像我女儿这种没接受过幼小衔接的做起来就很慢，肯定需要家长帮忙。有时候孩子做了坏事，我会想起自己小的时候也做过类似的事情，但我现在已经变成了孩子眼中那个严格的父亲了。有次父亲看我对孩子发火，就对我说对孩子还是要适当宽容一些，然后提起小时候每次打了我之后都会心里很后悔，我听了就很感慨。</p><p>今年下半年开始，我又开始经常打篮球了。刚开始主要是为了缓解久坐的疲劳，后来就变成每天不断地提升自己的投篮技术。深圳的秋冬季节很舒服，我经常中午 11 点半去小区篮球场投篮差不多一个小时，顺便晒晒太阳。每天这样练习之后投篮技术有了很大的提升，无人防守的情况下基本有 70% 左右的命中率。一个人投篮这种事情看起来很枯燥和无聊，但其实沉下心来运动的感受非常好，我把刻意练习的心态投入到了这个项目上，那一个小时内能达到类似心流的状态，时间变得清澈，仿佛只有我和篮球了。投篮最重要的是掌握出手时候的平衡度，手腕和手指用力，让篮球后旋起来，练习多了投篮动作就形成了肌肉记忆，只要动作做完就大致能知道是否命中，篮球空心入网的声音真是太悦耳了。磨练技艺真是一种最好的状态，而编程、写作、篮球都是这样的事情。</p><p>打篮球已经是我整整 20 年的爱好了，但我从未好好练习过投篮，可惜左膝盖在 2017 年伤过一次，运动激烈了容易酸疼，所以再也不怎么去和年轻人打半场了，即使偶尔玩玩总是担心自己受伤，在场上变得畏手畏脚。那些之前理所当然的事情变得奢求了，能力和自由渐渐地丧失，这真是大龄带来的切身痛苦。</p><p>有一次我傍晚还在练习投篮，有个看起来比我大七八岁的大哥过来，渐渐地我们聊了起来。我看他的篮球鞋很漂亮，他说是他儿子的，应该叫作空军一号。我们边投篮边聊天，一直聊到天完全黑掉看不到篮筐。没想到这样一个在国企工作的大哥也经常翻墙看新闻，说这几年的情形是聪明人都在蛰伏和休息。还有一次我正在投篮，刚好碰到一个幼儿园班的小朋友们经过，因为球场上就只有我一个人在锻炼，他们就围在场边观看，渐渐地我每进一个球小朋友们就开始欢呼，每次没进就惋惜叹声，这真是个有趣的经历。日子大多平淡如水，但这些小瞬间却留在了心里。</p><p>回想起来，今年生活中的一些其他变化，彻底不看朋友圈，不怎么追新闻，总体来说信息更闭塞了。但 2024 却是我生活上最朴素充实的一年，上班做感兴趣的项目下班做喜欢的运动，在我做了很多减法后，现在的生活好像就是自己理想中的状态。</p><p>祝各位新年快乐！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2024 年快结束了，在这最后的一两个小时里我写着这篇年终总结准备跨年了，顺着大致时间线来回顾一下就好了。&lt;/p&gt;
&lt;p&gt;年初就起了个好头，众多加密货币开始上涨。总体而言，2024 年是个加密货币和区块链的大年。有那么一小段时间我每天都在关注涨跌，渐渐地我发现这个领域涨跌都
      
    
    </summary>
    
    
      <category term="Notes" scheme="http://catcoding.me/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>CKB new script verification with VM pause</title>
    <link href="http://catcoding.me/p/ckb-new-verify/"/>
    <id>http://catcoding.me/p/ckb-new-verify/</id>
    <published>2024-11-07T12:03:24.000Z</published>
    <updated>2025-06-11T13:12:20.575Z</updated>
    
    <content type="html"><![CDATA[<p>CKB 相关技术文章第三篇。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CKB 的每一个交易在提交到交易池之前都会经过一个 script verification 的过程，本质上就是通过 CKB-VM 把交易里的 script 跑一遍，如果失败了则直接 reject，如果通过了才会继续后面的流程。</p><p><img src="http://catcoding.me/images/ob_what-is-verification.png" alt=""></p><p>这里的 script 就是一种可以在链上执行的二进制可执行文件，也可以称之为 CKB 上的合约。它是图灵完备的，我们通常可以通过 C、Rust 来实现这些 script，比如 <a href="https://github.com/nervosnetwork/ckb-system-scripts">nervosnetwork/ckb-system-scripts</a> 就是 CKB 上的一些常用的系统合约。用户在发起交易的时候就设置好相关的 script，比如 lock script 是用来作为资产才所有权的鉴定，而 type script 通常用来定义 cell 转换的条件，比如发行一个 User Define Token 就需要指定好 UDT 所对应的 type script。script 是通过 RISC-V 指令集的虚拟机上运行的，更多内容可以参考 <a href="https://docs.nervos.org/docs/script/intro-to-script">Intro to Script | Nervos CKB</a>。</p><h2 id="大-cycle-交易的挑战"><a href="#大-cycle-交易的挑战" class="headerlink" title="大 cycle 交易的挑战"></a>大 cycle 交易的挑战</h2><p>通常一个简单的 script 在 CKB-VM 里面执行是非常快的，VM 上跑完之后会返回一个 cycle 数目，这个 cycle 数量很重要，我们用来衡量 script 校验所耗费的计算量。一个合约的 cycle 数多少，理论上来说依赖于 VM 跑的使用用了多少个指令，这由 VM 在跑的时候去计算 <a href="https://docs.nervos.org/docs/script/vm-cycle-limits">VM Cycle Limits</a>。</p><p>随着业务的复杂，逐渐出现了一些大 cycles 的交易，跑这些交易可能会耗费更多的时间，但我们总不可能让 VM 一直占着 CPU，比如在处理新 block 的时候，<a href="https://github.com/chenyukang/ckb/blob/8cb49e4d727f337a2c80e210507a9e277bab3391/chain/src/verify.rs#L79-L87">CPU 应该在让渡出来</a>。但之前 CKB-VM 对这块的支持不够，为了达到变相的暂停，处理大 cycles 的时候我们可以设置一个 step cycles，假设我们设置为 100 cycles，每次启动的时候就把 max_cycles 设置为 100，这样 VM 在跑完 100 cycle 的时候会退出，返回的结果是 cycle limitation exceed，然后我们就知道这个 script 其实是没跑完的，先把状态保存为 suspend，然后切换到其他业务上做完处理之后再继续来跑。回来后如何才能恢复到之前的执行状态呢，这就需要保存 VM 的 <a href="https://github.com/chenyukang/ckb/blob/aaa51583656f022ad64ec98d1fb0205fc2878dba/script/src/types.rs#L319-L333">snapshot</a>，相当于给 VM 当前状态打了一个快照：</p><p><img src="http://catcoding.me/images/ob_ckb-vm-snapshot.png" alt=""><br>根据这个机制，我们老的 script 校验大交易的整个流程是通过一个 FIFO 的队列保存大交易，然后通过一个后台任务不断地从这个队列中取交易跑 VM，每次都跑 1000w cycle 左右，在这个过程中就可能切换出去，没跑完的交易继续放入队列等待下一次执行：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20241106114040.png" alt=""></p><p>对应到代码就是 <a href="https://github.com/nervosnetwork/ckb/blob/develop/tx-pool/src/chunk_process.rs">ChunkProcess</a> 这个单独服务来处理的。由于 ChunkProcess 是一个单独的服务，它的处理流程和其他交易的处理流程是不一样的，这样会导致代码的复杂度增加，比如：</p><ol><li>要针对 ChunkProcess 里面的交易额外判断，<a href="https://github.com/nervosnetwork/ckb/blob/3d674d558e5574f0c77a52798775c903561a933a/tx-pool/src/process.rs#L321">例子 1</a>, <a href="https://github.com/nervosnetwork/ckb/blob/3d674d558e5574f0c77a52798775c903561a933a/tx-pool/src/process.rs#L350">例子 2</a></li><li>暂停 / 恢复 ChunkProcess 处理的时候，需要对 ckb-vm 做相关的状态保存和恢复处理，参考结构 <a href="https://github.com/nervosnetwork/ckb/blob/3d674d558e5574f0c77a52798775c903561a933a/script/src/types.rs#L308">TransactionSnapshot</a>, 代码比较复杂且容易遗漏，历史上也有过相关的 <a href="https://github.com/nervosnetwork/ckb/pull/3188">bug 1</a>, <a href="https://github.com/nervosnetwork/ckb/pull/3177">bug 2</a>, 以及安全问题。</li><li>代码中包含重复逻辑，比如 <code>chunk_process</code> 里的 <code>process_inner</code> 和 <code>_resumeble_process_tx</code>。</li><li>由于它只能同时处理一个大 cycle 交易，在 tx pool 本身比较空闲的情况下如果收到了多个大 cycle 交易也不能并行处理，比如 .bit 团队之前有过反馈他们通过本地 rpc 同时提交多个大 cycle 交易会比较慢的问题。</li></ol><h2 id="CKV-VM-pause"><a href="#CKV-VM-pause" class="headerlink" title="CKV-VM pause"></a>CKV-VM pause</h2><p>这些问题的根本是 VM 只能通过 cycle step 的方式来暂停，有没有一种方式是我们任何时候想暂停就暂停，就是 event based 的方式。所以后来 CKB-VM 团队做了一些改进：</p><ul><li><a href="https://github.com/nervosnetwork/ckb-vm/pull/348">ckb-vm 新的暂停方式</a></li><li><a href="https://github.com/nervosnetwork/ckb-vm/pull/345">feat: Add alternative snapshot design. #345</a></li><li><a href="https://github.com/nervosnetwork/ckb-vm/pull/299">Make ckb-vm thread-safety #299</a></li><li><a href="https://github.com/nervosnetwork/ckb/pull/3752">CKB feature: thread-safe vm</a></li></ul><p>这个方法的本质是通过 VM 的 <code>set_pause</code> 接口，把一个 <code>Arc&lt;AtomicU8&gt;</code> 的 pause 共享变量设置给 VM。然后在 VM 外通过更新这个 pause 的变量让 VM 进入暂停状态或者继续执行，这样我们就不需要 dump snapshot 等操作，因为 VM 整个就还是在内存中等着：</p><p><img src="http://catcoding.me/images/ob_ckb-vm-pause.png" alt=""></p><h2 id="新的实现方案"><a href="#新的实现方案" class="headerlink" title="新的实现方案"></a>新的实现方案</h2><p>基于这些改进我们可以重新设计和实现 CKB verify 这部分的代码，主要是为了简化这部分代码，并且提高大交易处理的效率。这是一个典型的 queue based multiple worker 方案：</p><p><img src="http://catcoding.me/images/ob_new-ckb-verify.png" alt=""></p><p>主要的核心是就是这段异步执行 VM 的逻辑：<a href="https://github.com/nervosnetwork/ckb/blob/develop/script/src/verify.rs#L1166-L1269">chunk_run_with_signal</a>。做的过程中发现一些其他问题：</p><ul><li>交易提交的时候，<code>SubmitLocalTx</code> 和 <code>SubmitRemoteTx</code> 如果 verify 失败目前会立即返回 <code>Reject</code>，如果改成加入队列的方式，这个结果无法实时给到，所以做了如下改动：<ul><li>优先处理本地的交易，本地提交的交易不会放入 queue，而是直接会在 RPC 的处理阶段执行</li><li>所有的来自网络 peer 的交易都全到放入到 queue</li></ul></li><li>后来 CKB vm 又新增了 spawn 的实现，所以会有 parent、child 的概念，那么<code>Child VM</code> 是执行 syscall 的时候执行 <code>machine.run</code> ，如果不改这块执行 child vm 的时候不可暂停<ul><li>后来我们讨论了之后决定 spawn 时把父的 <code>Pause</code> 传递给子，然后暂停的时候给父的 <code>Pause</code> 设置暂停，这样所有的子 machine 同样返回 <code>VMError::Pause</code> ，同时把当前的 machine 栈重新入栈，恢复的时候继续执行，这里逻辑比较重，相关代码实现：<a href="https://github.com/nervosnetwork/ckb/blob/6f643220c704138298e693b0ef737c56a98ed762/script/src/verify.rs#L1452">run_vms_child</a>。</li></ul></li><li>后来用重新设计了 spawn，使用了一种新的 determined scheduler 的方式去管理所有的 vms 和 IO，之前和 VM 的使用者角度来说之前需要和 VM 交互，现在变成了都通过<a href="https://github.com/chenyukang/ckb/blob/8cb49e4d727f337a2c80e210507a9e277bab3391/script/src/scheduler.rs#L207-L236"> scheduler 来管理</a>。关于 spawn 的设计参考这个文档：<a href="https://github.com/nervosnetwork/rfcs/pull/436/files">Update spawn syscalls</a>。</li></ul><hr><p>整个 PR 在这里：<a href="https://github.com/nervosnetwork/ckb/pull/4291">New script verify with ckb-vm pause</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CKB 相关技术文章第三篇。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;CKB 的每一个交易在提交到交易池之前都会经过一个 script verification 的过
      
    
    </summary>
    
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CKB RBF 设计和实现</title>
    <link href="http://catcoding.me/p/ckb-rbf/"/>
    <id>http://catcoding.me/p/ckb-rbf/</id>
    <published>2024-11-06T11:55:13.000Z</published>
    <updated>2025-06-11T13:12:20.575Z</updated>
    
    <content type="html"><![CDATA[<p>CKB 相关技术文章第二篇。</p><h2 id="Replace-by-fee"><a href="#Replace-by-fee" class="headerlink" title="Replace by fee"></a>Replace by fee</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果一个交易成功发送到交易池，但可能出现因为费用较低而一直得不到处理。之前 CKB 没有其他措施来处理这种情况。</p><p>例如 <a href="https://www.notion.so/Dotbit-4-45e129cb4c434bd2902569aff67c4383?pvs=21">Dotbit 4 位域名注册拥堵</a> 这个事故发生过程中，<code>CKB</code> 的应用方无法使用任何方式来尽快让自己的交易被打包，这就是引入 <code>Replace-by-fee（RBF)</code> 的原因，我们需要一个机制来提高已经在交易池里交易的费用，替换掉旧的交易，让新的交易尽快被打包。</p><p>在新的 <code>multi_index_map</code> 重构后，交易在 <code>pending</code> 阶段也会按照交易的 <code>score</code> 来优先处理 (通常费用高的交易 <code>score</code> 也会高)，这会避免高费用的交易被阻塞住，所以理论上述需要手动提高费用的情况会减少，但我们还是需要 RBF 来手动提高交易的费用，应对意外的情况。</p><p>另外，RBF 可能将多个老的交易替换出去，因此也是将两个或多个支付合并为一的方法，例如下图所示，如果满足条件 <code>tx-a</code>, <code>tx-b</code>, <code>tx-c</code>, <code>tx-d</code> 都会被 <code>tx-e</code> 这个交易替换掉：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20241031103004.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">bips/bip-0125.mediawiki</a></li><li><a href="https://bitcoincore.org/en/faq/optin_rbf/">Bitcoin Core :: Opt-in RBF FAQ</a></li><li><a href="https://www.notion.so/RBF-in-CKB-draft-2023-01-05-79736edd0c824fae98f1e7ee42d4e436?pvs=21">RBF in CKB(draft 2023.01.05)</a></li><li><a href="https://bitcoinops.org/en/newsletters/2022/03/16/#ideas-for-improving-rbf-policy">Bitcoin Optech Newsletter #191 | Bitcoin Optech</a></li></ul><p>中本聪最初的 Bitcoin 版本中就有引入一个 <code>nSequence</code> 的字段，如果相同交易的 <code>nSequence</code> 更高，就可以<a href="https://github.com/trottier/original-bitcoin/blob/master/src/main.cpp#L434">替换</a>之前老的交易，这个实现的问题是没有支付额外的 fee，miner 没用动力去替换交易，另外因为没有 rate-limiting 从而导致可能被滥用，所以 Bitcoin 在 0.3.12 版本中禁止了这个功能。后来 Bitcoin 重新引入了新的 RBF 改进，主要包括需要支付额外的费用来替换老交易，另外为 RBF 指定了更多的限制条件。</p><p>在 CKB 上我们之前做过两次 RBF 的相关调研，因为之前 <code>Pending</code> 是一个 FIFO 的数据结构，所以处理替换不是很方便，在 RBF in CKB(draft 2023.01.05) 尝试引入一个 <code>high priority queue</code> 来实现 <code>inject-replace</code>。交易池改造之后，整个交易池可当作一个优先队列，所以应对 <code>RBF</code> 会简单很多。</p><h2 id="新增-RBF-的流程"><a href="#新增-RBF-的流程" class="headerlink" title="新增 RBF 的流程"></a>新增 <code>RBF</code> 的流程</h2><p><img src="http://catcoding.me/images/ob_rbf2.png" alt=""></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul><li><code>pre-check</code> 为 entry 加入到 tx-pool 之前必须要做的检查，之前只是做双花的检查，新增 RBF 后如果双花检查失败（这里意味着冲突），继续做 RBF 的相关检查，如果 RBF 检查成功则也返回成功，否则直接返回错误。这里默认直接做 resolve_tx 的检查，如果成功则走正常流程，目的是不给正常流程增加额外成本。所以这就是<a href="https://github.com/chenyukang/ckb/blob/44331ec5b9fcda217f33c471057fa479bd36a89f/tx-pool/src/process.rs#L216-L255"><code>pre-check</code> 修改后的主要逻辑</a> 。</li></ul><p>RBF 的检查规则参考 Bitcoin 的六条，<a href="https://github.com/chenyukang/ckb/blob/2be67e79acec94369a96f786d3041e6cb00cf1f2/tx-pool/src/pool.rs#L483-L565"><strong>check_rbf 初步实现</strong></a></p><pre class="line-numbers language-none"><code class="language-none">实现细节：（Bitcoin Core 0.12.0）~~1. 交易需要声明为可替换交易~~ 2. 新替换交易没有包含新的、未确认的 inputs3. 新替换交易的交易费用比待替换交易费用高4. 新替换交易费用必须比节点的 min relay fee 高5. 待替换交易的子交易数量不可超过 100 条（即使用了该交易的任意 outputs，该交易替换后它们将被从内存池中移出）6. 因为 ckb 是做了两步提交，我们新增规则：被替换的交易只能是 Pending 或者 Gap 阶段的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们不给交易加新的字段表示是否可以被替换，而是通过节点是否配置了 <code>min_rbf_rate</code> 来决定是否能做替换，因此 <code>规则 1</code> 不做对应考虑。</p><h3 id="替换和提交"><a href="#替换和提交" class="headerlink" title="替换和提交"></a>替换和提交</h3><p>修改 <code>tx-pool</code> 的 <code>submit_entry</code> 函数，传入 <code>conflicts</code>，在新增 entry 之前把所有冲突的交易删除 放入 <code>rejected</code> 记录，另外确保所有检查完成了之后才做删除和写操作：<a href="https://github.com/chenyukang/ckb/blob/2be67e79acec94369a96f786d3041e6cb00cf1f2/tx-pool/src/process.rs#L99-L154">submit_entry 逻辑</a>。</p><p>最终实现在这个 PR 里<a href="https://github.com/nervosnetwork/ckb/pull/4079">Tx pool Replace-by-fee</a>。</p><h3 id="并发的-Bug"><a href="#并发的-Bug" class="headerlink" title="并发的 Bug"></a>并发的 Bug</h3><p>在最初的实现版本中，隐藏了一个并发的 bug 后来在测试发现了。RBF 的检查如果放在 <code>pre-check</code> 中，如果多个线程中的多个交易发生了冲突，input resolve 可能会出问题。<a href="https://github.com/nervosnetwork/ckb/pull/4258">Fix concurrency issue for RBF</a> 这个 PR 修复了这个问题，把 RBF 的冲突检查移动了 submit entry 之前，因为在这个函数里面会持有 write 锁。</p><h3 id="cycling-attack"><a href="#cycling-attack" class="headerlink" title="cycling attack"></a>cycling attack</h3><p>后来我们在做闪电网络的时候又发现 RBF 可能会引入 cycling attack 的风险，这个攻击通过构造巧妙的新交易，让支付路径上的中间节点的 commitment tx 不能按时上链，<a href="https://blog.satsbridge.com/lightning-replacement-cycling-attack-explained-45636e41bc6f">Lightning Replacement Cycling Attack Explained</a>这篇文章有更详细的描述。</p><p>所以我们后来又做了这么一个改进：<a href="https://github.com/nervosnetwork/ckb/pull/4561">Recover possible transaction in conflicted cache when RBF</a> 来规避这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CKB 相关技术文章第二篇。&lt;/p&gt;
&lt;h2 id=&quot;Replace-by-fee&quot;&gt;&lt;a href=&quot;#Replace-by-fee&quot; class=&quot;headerlink&quot; title=&quot;Replace by fee&quot;&gt;&lt;/a&gt;Replace by fee&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CKB 交易池重构</title>
    <link href="http://catcoding.me/p/ckb-txpool-refactor/"/>
    <id>http://catcoding.me/p/ckb-txpool-refactor/</id>
    <published>2024-11-06T11:39:21.000Z</published>
    <updated>2025-06-11T13:12:20.575Z</updated>
    
    <content type="html"><![CDATA[<p>在 11.9 号清迈的 <a href="https://share.foresightnews.pro/article/detail/70811">CKCON</a> 会议上我会做一个关于 CKB 交易池的演讲，这是我准备的 slides <a href="https://ckb-tx-pool.vercel.app/1">Key Upgrades of the CKB Core</a> 。所以这段时间在整理之前做项目的时候写的一些文档，顺便分享到自己的博客上。既然我们整个项目的源码都是公开的，这些文档其实也是可以分享的。</p><p>第一次听说 CKB 的读者可以参考这个文档以了解什么是 CKB 以及如何工作的：<a href="https://docs.nervos.org/docs/getting-started/how-ckb-works">How CKB Works | Nervos CKB</a>。</p><p>我加入 Cryptape 之后一年内做的主要工作，涉及到交易池重构、Replace-by-fee 功能、以及 new-verify。这是第一篇关于交易池重构的文章。</p><h2 id="什么是交易池"><a href="#什么是交易池" class="headerlink" title="什么是交易池"></a>什么是交易池</h2><p>在 bitcoin 中交易池叫作 mempool，比如 <a href="https://mempool.space/">mempool - Bitcoin Explorer</a> 这个网站就很好地展示了其当前的状态。</p><p>交易池是 bitcoin 中的一个重要的组件，但感觉专门关于这块的资料很少，只能通过 PR 和邮件列表上的讨论看到一些文档。但交易池非常重要，因为一个交易要上链必须会通过交易池，而其中的交易打包算法涉及到如何选择合适的交易，这里面有很多因素需要考虑，所以在实现上也是比较复杂的。</p><p>当一个交易被提交到一个节点时，或者一个节点从网络中同步到交易时，这个交易首先需要被加入到交易池中，交易池里会根据一定的算法去选择下一个需要被打包的交易，另外交易池作为一个缓存，我们需要为其设置一个最大的 size。所以交易池里面最重要的两个操作就是 packaging 和 evicting。</p><p>交易池里面的交易存在父子关系，打包的时候需要从交易链的纬度去考虑，后面的 Replace by fee 这些功能也需要关注整个交易的所有子交易。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20250221102123.png" alt=""></p><h2 id="交易池重构"><a href="#交易池重构" class="headerlink" title="交易池重构"></a>交易池重构</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>根据 RFC <a href="https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0020-ckb-consensus-protocol/0020-ckb-consensus-protocol.md#two-step-transaction-confirmation">consensus-protocol</a> 的设计，CKB 里的 tx-pool 采用了两段提交的方式：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20241031100804.png" alt=""></p><p>相应地在交易池最初实现的时候， <code>ckb</code> 的代码实现中 <a href="https://github.com/nervosnetwork/ckb/blob/rc/v0.111.x/tx-pool/src/pool.rs">tx-pool</a> 同样采用了三个独立的队列，具体定义如下：</p><ul><li><code>pending</code> 交易刚加入到交易池时候的状态，我们每次只能处理不多于 <code>MAX_BLOCK_PROPOSALS_LIMIT</code> 个交易，交易需要先进入 <code>gap</code> 备选，具体代码逻辑在 <a href="https://github.com/nervosnetwork/ckb/blob/3de5a20ce60619927f41f81d9584cab9d39d1275/tx-pool/src/block_assembler/mod.rs#L345C11-L345C11">update_proposals</a> 。</li><li><code>gap</code> 已经被 proposed 了，但是还不能被打包，需要等一个块后才能被打包，所以这只是内部中间过渡状态。</li><li><code>proposed</code> 交易可以加入到 <code>block_template.transactions</code> , 最终打包到 block 里，具体代码逻辑在 <a href="https://github.com/nervosnetwork/ckb/blob/e75ab3faf0f7b1d182be2f1daa30f300cfefabc8/tx-pool/src/block_assembler/mod.rs#L195">block_assembler</a>。</li></ul><p>实现中 <code>pending</code> 和 <code>gap</code> 同样都是使用了 <code>PendingQueue(LinkedHashMap)</code>，而 <code>proposed</code> 采用了 <code>SortedTxMap(HashMap + BTreeSet)</code> ：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">TxPool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> config<span class="token punctuation">:</span> <span class="token class-name">TxPoolConfig</span><span class="token punctuation">,</span>    <span class="token comment">/// The short id that has not been proposed</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> pending<span class="token punctuation">:</span> <span class="token class-name">PendingQueue</span><span class="token punctuation">,</span>    <span class="token comment">/// The proposal gap</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> gap<span class="token punctuation">:</span> <span class="token class-name">PendingQueue</span><span class="token punctuation">,</span>    <span class="token comment">/// Tx pool that finely for commit</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> proposed<span class="token punctuation">:</span> <span class="token class-name">ProposedPool</span><span class="token punctuation">,</span>    <span class="token punctuation">...</span><span class="token punctuation">.</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> expiry<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的实现存在以下问题：</p><ul><li><p>我们不容易对所有在交易池中的 entry 做统一排序，这样会存在以下问题：</p><ul><li>一个 fee 高的交易可能在 transaction 多的情况下在 pending 阶段一直卡着，因为我们在 pending 和 gap 阶段只是按照时间顺序来处理，只在 proposed 后的打包阶段按照交易费来处理。</li><li><a href="https://github.com/nervosnetwork/ckb/issues/3942">issue 3942</a> 交易池满了之后，我们需要选择一些 entry 做 evict，我们目前的 evict 逻辑很<a href="https://github.com/nervosnetwork/ckb/blob/fdee47bbd87c66d8a0e54c3ac1f5386cb9aba643/tx-pool/src/pool.rs#L322">简单粗暴</a>。我们希望尽量选择最小 descendants 的交易，这样能避免在 evict 过程中删除过多交易。我们目前在 pending 和 gap 阶段没有记录 descendants，而需要加入这个逻辑就和 proposed 阶段完全重复，而且因为不会统一排序，后续实现也不容易。</li></ul></li><li><p>pending, gap 和 proposed 除了所采用的数据结构不同外，有很多逻辑雷同的代码，比如 entry 的新增和删除等操作，同样都维护了 deps 和 header_deps，resolve_conflict, resolve_conflict_header_dep, resolve_tx 等函数的逻辑也是类似的，但实现上有些细微差异，这导致长期来说代码不容易维护。</p></li><li>同样我们在 <code>tx-pool</code> 上对 entry 做迭代和查询时，需要依次针对 pending, gap, proposed 做相同的逻辑，比如 resolve_conflict_header_dep 这样的函数在 pool 中有几个类似的，甚至 get_tx_with_cycles 这样的函数，需要依次判断各个队列。</li><li>实现其他功能不方便，比如我们如果要实现 Replace by fee，就需要找交易池中和新交易有冲突的交易，我们需要在三个数据结构上分别进行检查才能得到结果。</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>基于以上解决现有问题、应对未来的潜在需求、保持代码可维护性的角度，同时参考 <a href="https://github.com/bitcoin/bitcoin/blob/322ec63b01499c1ec52d3912ee382ebd59f2366b/src/txmempool.h">Bitcoin txmempool</a> 的实现，我们提出引入 <strong>Multi_index_map</strong> 对 tx-pool 进行重构。</p><p>总体方向是把所有的 <code>entry</code> 放入统一的数据结构中进行管理，加入一个新的字段 <code>status</code> 标识目前 <code>entry</code> 所处的阶段，然后通过 index_map 的方式根据不同的属性进行排序和迭代：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">Status</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Pending</span><span class="token punctuation">,</span>    <span class="token class-name">Gap</span><span class="token punctuation">,</span>    <span class="token class-name">Proposed</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[derive(MultiIndexMap, Clone)]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">PoolEntry</span> <span class="token punctuation">&#123;</span>    <span class="token attribute attr-name">#[multi_index(hashed_unique)]</span>    <span class="token keyword">pub</span> id<span class="token punctuation">:</span> <span class="token class-name">ProposalShortId</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> score<span class="token punctuation">:</span> <span class="token class-name">AncestorsScoreSortKey</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> status<span class="token punctuation">:</span> <span class="token class-name">Status</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> evict_key<span class="token punctuation">:</span> <span class="token class-name">EvictKey</span><span class="token punctuation">,</span>    <span class="token comment">// other sort key</span>    <span class="token keyword">pub</span> inner<span class="token punctuation">:</span> <span class="token class-name">TxEntry</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中根据 Rust 社区的 <a href="https://github.com/lun3x/multi_index_map">multi_index_map</a> 内部实现采用的数据结构看，性能上应该没有什么大问题：</p><ul><li>Hashed index retrievals are constant-time. (FxHashMap + Slab).</li><li>Sorted indexes retrievals are logarithmic-time. (BTreeMap + Slab).</li><li>Non-Unique Indexes<ul><li>Hashed index retrievals are still constant-time with the total number of elements, but linear-time with the number of matching elements. (FxHashMap + (Slab * num_matches)).</li><li>Sorted indexes retrievals are still logarithmic-time with total number of elements, but linear-time with the number of matching elements. (BTreeMap + (Slab * num_matches)).</li><li>Iteration within an equal range of a non-unique index is fast, as the matching elements are stored contiguously in memory. Otherwise iteration is the same as unique indexes.</li></ul></li></ul><p>具体实现时我们是否把 inner 也放在 Slab 里面以后可以通过 benchmark 来选择，从实现的简洁性角度考虑统一放在一个数据结构里面更容易。</p><p>目前的实现版本：<a href="https://github.com/nervosnetwork/ckb/pull/3993">Tx pool rewrite with multi_index_map #3993</a></p><h2 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h2><p>我们首先只是做模块内的重构 (保持对外逻辑和以前一样)，当然考虑引入了新的数据结构，不管是从性能上还是内存占用上都会有一些影响。</p><p>为了做统一排序这件额外的事，本质上我们引入了额外的 Map(FxHashMap 或 BTreeMap) 来存储，所以比以前需要更多内存。另外，我们有时候需要调用 <code>get_by_status</code> 来筛选某个状态的 entries，这在新的实现里面需要先从 index 里面找出 slab 的 id，然后再找到对应的 entry，所以必然也会比以前慢。</p><p>从最终的性能对比结果上，除了内存会稍微有增加，性能上没有大的变化。另外我们在实现的过程中对所用到的 Rust 包 multi-index-map 做了一些贡献：<a href="https://github.com/lun3x/multi_index_map/pull/23">Non-unique index support, capacity operations, performance improvement &amp; more by wyjin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 11.9 号清迈的 &lt;a href=&quot;https://share.foresightnews.pro/article/detail/70811&quot;&gt;CKCON&lt;/a&gt; 会议上我会做一个关于 CKB 交易池的演讲，这是我准备的 slides &lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://catcoding.me/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>xz-backdoor 观感</title>
    <link href="http://catcoding.me/p/xz-backdoor/"/>
    <id>http://catcoding.me/p/xz-backdoor/</id>
    <published>2024-04-04T18:04:33.000Z</published>
    <updated>2025-06-11T13:12:20.588Z</updated>
    
    <content type="html"><![CDATA[<p>写写最近一周的大瓜 xz-backdoor，该事件可能成为开源供应链安全的一个分水岭，从技术角度看，这里面的社工和混淆也是精彩。</p><p>简单介绍一下背景，xz 是一个开源的无损压缩工具，在出事之前可能很少有人注意到这个压缩库使用如此之广，几乎任何一个 Unix-Like 的操作系统里面都有 xz-utils。在两年多的时间里，一个名为 <code>Jia Tan</code> 的程序员勤奋而高效地给 xz 项目做贡献，最终获得了该项目的直接提交权和维护权。之后他在 libzma 中加入了一个非常隐蔽的后门，该后门可以让攻击者在 SSH 会话开始时发送隐藏命令，使攻击者能够跳过鉴权远程执行命令。</p><p><a href="https://research.swtch.com/xz-timeline#jia_tan_arrives_on_scene_with_supporting_cast">Timeline of the xz open source attack</a> 总结了该事件的主要时间点，这里我挑一些关键节点：</p><h4 id="潜伏"><a href="#潜伏" class="headerlink" title="潜伏"></a>潜伏</h4><ul><li>2005 ~ 2008 xz 项目的初始版本，这是一个文件压缩算法，主要由 <a href="https://github.com/kobolabs/liblzma/blob/87b7682ce4b1c849504e2b3641cebaad62aaef87/doc/history.txt">Lasse Collin</a> 开发和维护。</li><li>2021-10-29 ~ 2022-06-29 Jia Tan 开始较为密集地给 xz 项目贡献代码，同时几个类似马甲的账号 (Jugar Kumar, Dennis Ens) 在邮件列表里抱怨 Merge 得不到及时处理，问题得不到回复，有点逼宫的意思，在这个过程中项目主导者 Lasse Collin 把最近的优秀贡献者加入了维护者列表。<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4></li><li>2022-09-27 Jia Tan 获得了信任，并开始主导新版本的发布，他在这期间做了几个看似合理的 PR，但其实是在为今后的后门做伏笔，另一个马甲 Hans Jansen 提供了一个钩子可以让后门里的代码替换全局函数，从而绕过检查。</li><li>2023-07-07 Jia Tan 在 Google 的 oss-fuzz 提供修改禁用了 <code>ifunc</code>，这也是为了避免 fuzz 可能发现后门。<h4 id="发动"><a href="#发动" class="headerlink" title="发动"></a>发动</h4></li><li>2024-02-23 Jia Tan 发布了第一个有害的 PR，在测试代码中包含了几个 binary 文件，这些文件看起来只用于测试，所以在代码 review 的过程中肯定不会被仔细查看。</li><li>2024-02-26 Jia Tan 通过一个<a href="https://git.tukaani.org/?p=xz.git;a=commitdiff;h=328c52da8a2bbb81307644efdb58db2c422d9ba7">非常隐蔽的提交</a>，给 CMakeList.txt 增加了一个 <code>.</code>，使得代码会编译失败从而让 Landlock 不会被激活。</li><li>2024-02-24 Jia Tan 发布 v5.6.0，其中使用脚本混淆悄悄地把后门的 payload 塞进了目标文件中。Gentoo 和 Debian 开始在 unstable 版本中含有后门。</li><li>Hans Jansen 同时在发邮件催促 Debian 升级 xz 到 v5.6.1<h4 id="暴露"><a href="#暴露" class="headerlink" title="暴露"></a>暴露</h4></li><li>2024-03-29: 一个叫 Andres Freund 的开发者在分析一个 sshd 可疑的 500ms 延迟时，发现了隐藏在 xz 的恶意后门。如果不是偶然的发现，估计现在世界上无数的服务器处于肉鸡状态，这位微软的员工如英雄一般拯救了世界。</li></ul><hr><h2 id="攻击者是中国人？"><a href="#攻击者是中国人？" class="headerlink" title="攻击者是中国人？"></a>攻击者是中国人？</h2><p>从主要攻击者的名称看似乎是中国人，但 Git 昵称和时区这种东西很容易伪造，有人分析过开发者的代码提交时间，分析得出实际可能是欧洲人/以色列人冒充。</p><p>但不可否认，肯定会有不少国外的开发者会默认这就是中国人所为，我也看到了一些开发者开始带节奏，开始找各种和 Jia Tan 有过互动的中国程序员。</p><p>我倾向于相信这不是中国攻击者，感觉其 commit 信息里面的英文中没找到中式表达。比较确定的是，从这些马甲之间的密切配合来看，这像是一个有密谋的组织团体。</p><h2 id="开源软件的脆弱性"><a href="#开源软件的脆弱性" class="headerlink" title="开源软件的脆弱性"></a>开源软件的脆弱性</h2><p>开源意味着透明，但并不意味着安全。</p><p>10 多年前我们经历了 OpenSSL 的心脏滴血，如今类似的事情再次发生。甚至这次事件的性质更严重，心脏滴血漏洞本身是因为代码的逻辑问题导致被恶意利用，而这次是攻击者通过供应链恶意植入后门。</p><p>有一种观点是开源软件被更多人 review，所以理论上来说安全漏洞更容易被发现。但实际上看来，被巧妙设计过的代码改动，很不容易被发现问题，比如这次事件中这个提交，我相信绝大部分开发者无法发现被恶意添加的 <code>.</code>:</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403114716.png" alt=""></p><p>这次后门被发现有很大的运气成分，多亏了 Andres Freund 的细心和刨根问底的精神，这也算是有足够多的眼睛盯着所以发现了问题吧。</p><h2 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h2><p>如果有一个开源贡献者的身份识别机制，就可能预防类似的事情。我看到有人举例 Linux Kernel 提交必须使用 Git 的 Sign-off，但这个 Sign-off 更多的是在解决法律上的问题，Sign-off 本来就是因为法律诉讼而引入的。而且，在最坏情况下，一个开发者可能被社工或者入侵而导致身份被冒用，所以 Sign-off 并不意味着身份识别。</p><p>有的人提到通过支付来进行 KYC(Know Your Customer)，这必然是不可能的，因为开源本来就是一个黑客文化的产物，大量的开发者会刻意选择使用匿名身份提交代码。</p><p>我们来看看 Bitcoin，如果论项目值钱程度，比特币的代码应该能排得上号。但比特币是支持 Permissionless and Pseudonymous development 的，甚至这是保证比特币去中心化的两个很重要的手段，中本聪的身份仍然是一个迷。中本聪选择匿名对比特币本身来说也至关重要，<code>No one controls Bitcoin</code> 是其价值根本。</p><p>那比特币如何保证不会被植入后门，比如这种供应链攻击？</p><ul><li>Reproducible builds，这是个极大地缓解供应链风险的办法，不同的人编译相同的源代码必然得到相同的二进制文件，binary file 不能存在于源码库中。Bitcoin 使用 Guix container 从源码编译所有的东西，<a href="https://github.com/bitcoin/bitcoin/pull/15277">contrib: Enable building in Guix containers</a>，这个过程可以在任何 Linux 发行版上重现。在这个过程中，几乎所有的一切都从源码编译，所以会存在一个鸡生蛋蛋生鸡的问题，为了解决这个问题必然会需要一些 binary files，但最好是将这个范围限制到最小，<a href="https://guix.gnu.org/manual/en/html_node/Preparing-to-Use-the-Bootstrap-Binaries.html">Preparing to Use the Bootstrap Binaries</a>。</li><li>Don’t forget to verify yourself！</li></ul><p>另外比特币的安全在于 PoW，其设计本来就假设了少部分节点可能是恶意节点，除非黑客控制住了大部分节点才能造成破坏，而要达成这点在的概率可以认为就是零</p><h2 id="开源的可持续性"><a href="#开源的可持续性" class="headerlink" title="开源的可持续性"></a>开源的可持续性</h2><p>从这个安全事件我们可以继续探讨开源的可持续性这个问题。这个事件中 xz 的维护者 Lesse Collin 看起来已经是处于疲于应付的地步。从<a href="https://github.com/xz-mirror/xz/graphs/contributors">贡献者统计</a>可以看到这么多年几乎就是他一个人在给项目提交代码，Jia Tan 通过两年的潜伏就成为了贡献者第二的开发者：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403140505.png" alt=""></p><p>长时间维护一个被大量使用的开源项目是个巨大的负担，对维护者而言不仅仅是时间的投入，有时候也是精神上的折磨，即使开发者当初的有多好的愿景，但谁也无法保证常年的持续投入。关于这点可以阅读这篇文章，<a href="https://kettanaito.com/blog/the-dark-side-of-open-source">The Dark Side of Open Source</a>。</p><p>Lesse Collin 在这次事件中被利用了这个弱点，他在这封邮件里解释到自己作为项目主导者的困境：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403014036.png" alt=""></p><p>写到这里我想起自己也曾经催过一个库的作者，是不是考虑让更多人来维护项目 <a href="https://github.com/GREsau/schemars/issues/272">Maintenance status · Issue</a> 😅。</p><p>也许未来可能有一套机制，能够让基础开源软件的维护者得到经济激励，但这条路如何演化出来我还没看出来，如果真的出来或许与加密货币有一定关联。</p><p>可怕的是，现在还有很多人没有意识到开源贡献者困境，那些价值几千上万亿的公司也是在期望开源的开发者能够像雇员似的响应他们的 High Priority：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403013012.png" alt=""></p><p>这个世界上还是有无数的默默耕耘的开源代码维护者，比如 SQLite，全球大概有上万亿的 SQLite 数据实例跑在服务器上、手机上、浏览器里，但这个软件其实只由 3 个程序员维护了 20 多年；几乎所有工程师都使用的工具 curl，由 Daniel Stenberg 从 1998 维护到至今；vim 的作者 Bram Moolenaar 从 1991 年维护项目到自己去世，总共整整 32 年。</p><p>实际上没有人知道，多少被广泛使用的基础组件和代码是由各种默默无闻、分毫未取的开发者在用自己的业余时间维护着。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403135349.png" alt=""></p><p>从这个角度看，人类数字基础设施这艘巨轮其实建立在非常脆弱的基础上，说不定哪天一个地方就裂开了。我现在养成了一个习惯，升级从来不追新，任何安装到自己电脑上的二进制都小心翼翼。</p><p>这个世界上有无数的恶魔，也会有一些英雄和吹哨人，致敬 Andres Freund。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写写最近一周的大瓜 xz-backdoor，该事件可能成为开源供应链安全的一个分水岭，从技术角度看，这里面的社工和混淆也是精彩。&lt;/p&gt;
&lt;p&gt;简单介绍一下背景，xz 是一个开源的无损压缩工具，在出事之前可能很少有人注意到这个压缩库使用如此之广，几乎任何一个 Unix-Li
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="安全" scheme="http://catcoding.me/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>从明天起，做一个 Rust 程序员</title>
    <link href="http://catcoding.me/p/rust-bootcamp/"/>
    <id>http://catcoding.me/p/rust-bootcamp/</id>
    <published>2024-03-18T16:28:13.000Z</published>
    <updated>2025-06-11T13:12:20.584Z</updated>
    
    <content type="html"><![CDATA[<p>3 月是怀念海子的月份：</p><blockquote><p>从明天起，做一个 Rust 程序员，喂马、劈柴，周游世界。</p></blockquote><p>10 年前我开始写第一行 Rust 程序，到如今全职远程做 Rust 开源项目，也许我真能去过喂马劈柴周游世界了😆。但回想自己的学习旅程，其中有各种曲折有几度放弃的时候，如果你也想学习或者提高 Rust 方面的技能，我这篇文章里有一条更容易的路。</p><h2 id="为什么学习-Rust"><a href="#为什么学习-Rust" class="headerlink" title="为什么学习 Rust"></a>为什么学习 Rust</h2><p>Rust 1.0 发布已经快 10 年，所以并不是一门新编程语言了，从发展的角度来看 Rust 已经度过了生存期，并进入了迅速发展的阶段。从目前可见的业界方向来说，Rust 主要在以下几个方面取得了成功：</p><ul><li>在基础软件领域成为有力竞争者<ul><li>大量开源的 Rust <a href="https://github.com/sts10/rust-command-line-utilities">命令行工具</a>和开发库，如果你使用 Python，可以通过  <a href="https://pyo3.rs/v0.21.0-beta.0/">PyO3</a> 用 Rust 来写对性能要求更高的模块，还出现了 <a href="https://github.com/apache/opendal">opendal</a> 这样优秀的基础库</li><li>Cloudflare 使用 Rust 开发新的网关 <a href="https://blog.cloudflare.com/pingora-open-source">Pingora</a></li><li>开源数据库实现，比如 <a href="https://qdrant.tech/">Qdrant</a>、 <a href="https://risingwave.com/">RisingWave</a>、<a href="https://github.com/datafuselabs/databend">databend</a></li><li>AI 方面参考 <a href="https://www.arewelearningyet.com/">Are we learning yet</a>，虽然 Rust ML 生态系统还很年轻并处于试验阶段，但已经出现了一些雄心勃勃的项目和模块，Hugging Face 开源了 <a href="https://github.com/huggingface/candle">candle</a>机器学习框架</li></ul></li><li>前端的基础设施<ul><li>Rust 在前端领域发展迅速，Rust 是 WebAssembly 支持最好的编程语言，不少 Runtime 都是 Rust 实现的，比如 Wasmer</li><li>大量前端基础工具在使用 Rust 重新实现，比如 <a href="https://www.rspack.dev/">Rspack</a>、<a href="https://vercel.com/blog/turbopack">Turbopack</a>、前几天又出现了 <a href="https://github.com/rolldown/rolldown">rolldown</a>，<a href="https://leerob.io/blog/rust">Rust Is The Future of JavaScript Infrastructure</a>似乎已经成为共识</li></ul></li><li>操作系统<ul><li>Windows 开始使用 Rust 开发一些核心组件</li><li>Rust 开始进入 Linux 内核，使得使用 Rust 开发 Linux module 成为可能</li><li>Andriod 使用 Rust 开发更多组件，并有效减少了内存方面的漏洞，他们发布的 <a href="https://google.github.io/comprehensive-rust/">Comprehensive Rust</a>是一个很好的学习资料。Google 开始尝到 Rust 的好处，并开始投入更多资金和人力，近期 <a href="https://security.googleblog.com/2024/02/improving-interoperability-between-rust-and-c.html">Google 打算捐献 100 万美金给 Rust 基金会</a>着重解决 Rust 和 C++ 的互操作性</li></ul></li><li>区块链领域<ul><li>以我在这个领域工作一件多的经验来说，Rust 成为了区块链领域的标配，基本区块链相关的工作岗位 Rust 技能是一个极大的加分项</li><li>大量公链使用 Rust 来开发</li></ul></li><li>游戏开发，参考 <a href="https://arewegameyet.rs/">Are we game yet?</a>，目前已经有成熟的游戏开发框架 <a href="https://bevyengine.org/">Bevy Engine</a></li></ul><p>如果你对 Rust 的发展情况感兴趣，可以参考 <a href="https://blog.rust-lang.org/2024/02/19/2023-Rust-Annual-Survey-2023-results.html">2023 Annual Rust Survey Results</a>。在内卷的 IT 市场，作为程序员选择一门小众的编程语言是避免过度竞争的方式，我之前介绍过其他人的类似经验，我们称之为 <a href="https://catcoding.me/p/weekly-13/">The Niche Programmer</a>。Rust 还未成为主流编程语言，但潜力和发展空间很大，而门槛相对其他语言比较高，所以我认为从求职的角度来考虑是值得一试的。</p><p>之前提到 Google 投入更多的资金在 Rust 上面，钱进来后相关的职位就出来了 <a href="https://foundation.rust-lang.org/careers/">C++/Rust Interop Initiative Software Engineer Lead</a>。</p><h2 id="我学习-Rust-的体会"><a href="#我学习-Rust-的体会" class="headerlink" title="我学习 Rust 的体会"></a>我学习 Rust 的体会</h2><p>我 2014 年时践行每年学习一门新的编程语言，Rust 作为一门新的编程语言进入了我的视野。我开始使用  Rust 写些简单的个人学习项目，然后我继续做了 <a href="https://exercism.org/tracks/rust/exercises">Rust exercises</a> 。</p><p>后续几年我偶尔看看 Rust 相关的新闻和项目，时不时动手写点代码都会有点磕磕碰碰。直到四年前开始在 Github 上给一些 Rust 开源项目贡献，两年前开始给 Rust 编译器做贡献，一年前开始全职从事 Rust 区块链相关的工作。</p><p>从技术角度来说，Rust 非常有趣，这里面包含了近些年程序设计方面的一些良好实践。全职写 Rust 程序这一年多是我开发体验最好的阶段，当然有时候我们需要和编译器斗智斗勇、做类型体操，但很多问题在开发阶段给规避掉了。</p><p>Rust 的最大问题还是在于学习门槛相对较高，因为在 Rust 中程序员接触最多的  <code>=</code> 语义都变了。从我个人体验来说，在学会了 Rust 语法后会陷入一个瓶颈，如果日常工作中不使用 Rust，就没有多少机会去实践，另外不知道做一些什么项目。</p><p>我相信很多人同样如此，看了官方 tutorial 之后不知道如何下手，我想如果有一个经验丰富的老师带，会少走很多弯路，这就是我要介绍的极客时间训练营要解决的问题。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240316231547.png" alt=""></p><h2 id="极客时间-Rust-训练营"><a href="#极客时间-Rust-训练营" class="headerlink" title="极客时间 Rust 训练营"></a>极客时间 Rust 训练营</h2><p>说起来我与这个训练营还有些渊源。</p><p>当极客时间在筹划这个 Rust 训练营的时候，策划人员找到过我问我是否有意愿当这个课程的讲师。我还稍微犹豫了一下，因为我之前也想过如何在 Rust 领域做更多的分享，我很羡慕优秀的技术分享者比如 <a href="https://www.youtube.com/@jonhoo">Jon Gjengset</a>能够非常自如地通过视频分享 Rust 方面的技术。当老师当然是个机会能从沟通和表达方面提高这方面的能力。</p><p>后来考虑到自己时间方面安排不过来，我有全职工作、有业余的 Rust 社区工作、还有三个小孩，所以我应该真没时间去录制课程了，而且他们已经找到了我认为最合适的讲师：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240316223445.png" alt=""></p><p>我看了这个项目的大纲，陈天老师希望可以教大家怎么用 Rust 比较简单的语法和技巧，来完成 80% 的日常工作，主要是通过各种实践项目来学习，这也是我最推崇的 Learn by doing 的方式。</p><p>有很多主题我都没怎么接触过，比如构建一个 ChatGPT 的应用、比如跨平台 GUI 之类的，所以我对这个课程很感兴趣，然后我和策划说能不能做这个项目的助教，后来沟通下来发现当助教也需要不少时间的，所以就没机会参与到具体的教学里面了。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240316231751.png" alt=""></p><p>总之，这个项目对于想学习 Rust 或者已经有一定 Rust 经验，但想获得更多实践经历的人是非常合适的。在和极客时间的相关人员沟通的过程中，我发现他们做事情很用心，这个训练营的课程质量我认为是有保证的。</p><p>这个训练营一共是 15 周的课程安排，其中每周都会有明确的项目安排，课后还有助教答疑。关于训练营的更多信息请参考：<a href="https://u.geekbang.org/subject/rust">极客时间训练营-Rust 训练营</a></p><p><img src="http://catcoding.me/images/ob_rust-boot-20240318164451.png" alt=""></p><h2 id="我与陈天老师的小故事"><a href="#我与陈天老师的小故事" class="headerlink" title="我与陈天老师的小故事"></a>我与陈天老师的小故事</h2><p>我最早知道陈天是他写的公众号《程序人生》，他是那种技术和文笔都非常棒的程序员，非常难得。我还看过他的 B 站上的技术讲解视频，他的演讲和分享都很流畅。陈天是极客时间《陈天 · Rust 编程第一课》专栏作者，已有 2.3w 人学过，广受好评。技术能力、演讲表达、对技术的热情这些都是讲师最重要的素质要求，所以陈天是这个训练营最好的讲师人选。</p><p>再分享一个小故事，我一年多前跳槽的时候还有些犹豫，因为自己的职业规划方面有些困惑，所以想找些人聊聊。当时我突然想到陈天之前从事过区块链方面的创业，后来从里面退出来了，所以我就想向他咨询一下。我没有他的联系方式，但灵机一动我想到了从 Git 的提交记录里面找 Email，然后抱着试一试的想法给他发了个邮件说明了自己的情况和困惑。没想到他很快给我回复了，并很详细地告诉我他对于区块链的想法，还有如何判断自己是否适合一个公司，通过各种途径了解公司的相关产品来作为决策的依据等等。</p><p>我作为一个陌生人，陈天老师都会乐于给与指导和帮助，可见为人真的很好。还没能有幸和陈天老师现实中有所交流，我本来想用当助教的机会和陈天老师多学习，但时间方面安排不过来了。希望大家能在老师的的训练营学到知识、经验、还有探索技术的乐趣！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;3 月是怀念海子的月份：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从明天起，做一个 Rust 程序员，喂马、劈柴，周游世界。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;10 年前我开始写第一行 Rust 程序，到如今全职远程做 Rust 开源项目，也许我真能去过喂马劈柴周游
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
</feed>
