<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CatCoding</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://catcoding.me/"/>
  <updated>2025-01-03T15:03:41.320Z</updated>
  <id>http://catcoding.me/</id>
  
  <author>
    <name>yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024：简单的理想生活</title>
    <link href="http://catcoding.me/p/2024-summary/"/>
    <id>http://catcoding.me/p/2024-summary/</id>
    <published>2025-01-01T00:03:41.000Z</published>
    <updated>2025-01-03T15:03:41.320Z</updated>
    
    <content type="html"><![CDATA[<p>2024 年快结束了，在这最后的一两个小时里我写着这篇年终总结准备跨年了，顺着大致时间线来回顾一下就好了。</p><p>年初就起了个好头，众多加密货币开始上涨。总体而言，2024 年是个加密货币和区块链的大年。有那么一小段时间我每天都在关注涨跌，渐渐地我发现这个领域涨跌都是太频繁了，而过多关注除了浪费时间并没有什么大的用处。因为两年前开始在这个领域工作，所以我自然也会投资一些加密货币。刚开始我稍微接触了一下合约，但很快亏掉了几千元，算是交了学费。然后很快理智地退出了，合约本质上来说和赌博有点类似，钱来得也快亏得也快，但大概率是要亏钱的。</p><p>我听从了一些行业老鸟的建议，拿住比特币就行，其他的看着买点。我从 2023 年开始陆续买入了一些比特币，当时的价格不算高，到今年年底看来也有不少涨幅了。我抱着长期拿住的心态在买入，打算至少持有八九年以上。所以现在我基本不怎么关心价格了，如果买了就当作这钱是存在那里好了，把时间幅度拉长，我相信比特币未来会更值钱。我愿意相信这个行业是因为从技术的角度考虑是即有趣又有挑战。这两年来我工作的项目和比特币是非常类似的，就当作为信仰充值。</p><p>2024 年 5 月开始我投入到了公司的一个新项目开发上，这是个完全开源的项目叫作 <a href="https://github.com/nervosnetwork/fiber">nervosnetwork/fiber</a>，简而言之就是 CKB 上的闪电网络实现。所以 2024 年的大部分时间我都专注于这个项目，因为这是个新项目所以很多功能都是从头开始实现，这对于程序员来说时段快乐时光，毕竟维护老项目很多时候都是在考虑兼容性，没有什么大量写代码的快感。</p><p><a href="https://zh.wikipedia.org/wiki/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C">闪电网络</a>似乎现在已经过了最火的时候，但却是古典区块链技术的代表。如何在去中心的环境中构建出信任通道，这是个非常复杂的问题，大多数时候我们都是在参考 <a href="https://github.com/lightning/bolts/tree/master">BOLT</a>这个规范。开发过程中一直需要考虑的是这样安全么，如果对方出错或者发出恶意的请求会怎样，channel 的基本保证是任何时候任意一方都可以退出，而不会造成资金上的损失，另外还需要兼顾的是隐私的问题，所以支付的多跳传输需要使用洋葱加密，错误的返回链路上也需要用洋葱加密。反正本质上，这些都归结为数学问题，多签、加密和解密、哈希时间锁合约，确保了交易的不可伪造性和隐私性。我不打算继续在这篇文中写更多关于闪电网络的技术细节，也许以后会写一系列的相关文章。</p><p>总体来说，2024 年又开心地写了一年代码，甚至我觉得技术越做越有意思了：<br><img src="http://catcoding.me/images/ob_pasted-image-20241228233657.png" alt=""></p><p>远程工作两年后，我更多采用把问题留在脑海中，时不时拿出来思考的工作方式。有几次这样的经历，我像是在睡觉的过程中还在思考某个问题，然后第二天起来还记得当时想出来的办法。</p><p>另一方面，有些遗憾的是我今年参与 Rust 等开源项目的时间比较少了，写文章也比较少。似乎在公司的项目上工作得足够有趣、找到了足够的收获感，没有多少动力和时间去做其他项目。但意想不到的是今年年底还是收到了 Rust 基金会的邮件，愿意资助我一年继续做贡献。所以明年我应该还是会把一些业余时间投入到 Rust 项目上，这也算是把爱好折腾成了责任和义务。可以说 Rust 延长了我的技术生命，让我幸运地投入到一堆 Rust 开源项目上，并且找到适合自己的公司，以远程的方式工作。</p><p>因为整天除了带娃和宅在家编程，2024 年我似乎没认识什么新的人，社交圈很小，甚至到了年底我才想起是不是该约上许久不见的朋友线下聊聊。我不知道如何解决这个问题，这有一半是远程工作带来的副作用，另一半就是人到中年在社交上的需求小了。我还在 Cambly 上练习口语，这已经变成了我强迫自己和人沟通的一个渠道，我每周三节课一共一个半小时，其中一个小时大多数都是和我的固定老师聊，他比我大 10 岁左右，我们聊过很多话题，我给他科普区块链等技术领域、做模拟演讲等。另外我喜欢找那些一直在旅游的人或者退休了的人聊，因为通常能听到一些好玩的事情，有次有个一直满世界漂流的人对我说他希望的是 die with my boots on，我一下子没听出其含义，后来通过他的解释我知道了这个俗语的意思：一个穿着靴子死去的人会一直生活和战斗到最后，他们像往常一样生活时去世，而不是因为年老和因疾病、体弱等卧床不起，对他来说他希望自己死在旅游的途中。我想这种生活态度真是太好了，而且他也在践行自己的这种生活方式。我喜欢看那些一直在路上的博主，比如 <a href="https://www.youtube.com/@shisanyao/videos">十三要和拳头</a> 和 <a href="https://www.youtube.com/@liuweiyuan">刘伟元的旅行</a>，可能正是因为我已经不太可能做到像他们那样随心所欲地玩耍。</p><p>说到旅行，今年五月底公司团建我们去了大理待了一周，那里的风景和气候都还挺不错，有些地方显得商业化太重，但沿着洱海骑行和在苍山徒步都非常惬意。夏天我和家人去了一趟北方，走的是比较热门的路线，青岛、威海、大连。不过这趟很累，因为暑假期间都是家长带着孩子，所以去哪里都是人挤人，但其实孩子们也还太小，他们只是想找个地方玩沙子赶海，而对于历史遗迹之类的地方则完全不感兴趣。</p><p>11 月公司组织去了趟清迈，我们在那里举行了第一次的 <a href="https://www.bitgetapps.com/zh-CN/news/detail/12560604322596">CKCON</a>，我也是第一次用英语做技术演讲。感觉清迈的基础设施还有待提升，有一次我一个人打车，司机好像是中途拐进了城中小道上歪歪扭扭的乱窜，我开始担心自己会不会被拉去割腰子。其实司机是个好人，到了终点后我才发现自己的 Grab 不能付款，他就耐心得等我去找人借现金。</p><p>我很喜欢公司组织的线下聚会，不但可以和平时合作的同事见面聊聊，也可以暂时从一直带娃的生活中抽离出来，每次出去我的感受是这样的：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20241229004417.png" alt=""></p><p>所以带孩子真的很累么？确实比较累，而且得看这个孩子是几岁。我喜欢带两三岁到五岁这个年龄段的孩子，因为这时候的孩子都是天真，又比较听话。像我大女儿到了七岁八岁，开始有自主意识了就很淘气，很多时候也不怎么听话，有时候会让我焦头烂额。小学二年级的作业比较多，我女儿每天需要在家里花大概一个小时来写作业，而且现在的数学作业看起来很多应用题，像我女儿这种没接受过幼小衔接的做起来就很慢，肯定需要家长帮忙。有时候孩子做了坏事，我会想起自己小的时候也做过类似的事情，但我现在已经变成了孩子眼中那个严格的父亲了。有次父亲看我对孩子发火，就对我说对孩子还是要适当宽容一些，然后提起小时候每次打了我之后都会心里很后悔，我听了就很感慨。</p><p>今年下半年开始，我又开始经常打篮球了。刚开始主要是为了缓解久坐的疲劳，后来就变成每天不断地提升自己的投篮技术。深圳的秋冬季节很舒服，我经常中午 11 点半去小区篮球场投篮差不多一个小时，顺便晒晒太阳。每天这样练习之后投篮技术有了很大的提升，无人防守的情况下基本有 70% 左右的命中率。一个人投篮这种事情看起来很枯燥和无聊，但其实沉下心来运动的感受非常好，我把刻意练习的心态投入到了这个项目上，那一个小时内能达到类似心流的状态，时间变得清澈，仿佛只有我和篮球了。投篮最重要的是掌握出手时候的平衡度，手腕和手指用力，让篮球后旋起来，练习多了投篮动作就形成了肌肉记忆，只要动作做完就大致能知道是否命中，篮球空心入网的声音真是太悦耳了。磨练技艺真是一种最好的状态，而编程、写作、篮球都是这样的事情。</p><p>打篮球已经是我整整 20 年的爱好了，但我从未好好练习过投篮，可惜左膝盖在 2017 年伤过一次，运动激烈了容易酸疼，所以再也不怎么去和年轻人打半场了，即使偶尔玩玩总是担心自己受伤，在场上变得畏手畏脚。那些之前理所当然的事情变得奢求了，能力和自由渐渐地丧失，这真是大龄带来的切身痛苦。</p><p>有一次我傍晚还在练习投篮，有个看起来比我大七八岁的大哥过来，渐渐地我们聊了起来。我看他的篮球鞋很漂亮，他说是他儿子的，应该叫作空军一号。我们边投篮边聊天，一直聊到天完全黑掉看不到篮筐。没想到这样一个在国企工作的大哥也经常翻墙看新闻，说这几年的情形是聪明人都在蛰伏和休息。还有一次我正在投篮，刚好碰到一个幼儿园班的小朋友们经过，因为球场上就只有我一个人在锻炼，他们就围在场边观看，渐渐地我每进一个球小朋友们就开始欢呼，每次没进就惋惜叹声，这真是个有趣的经历。日子大多平淡如水，但这些小瞬间却留在了心里。</p><p>回想起来，今年生活中的一些其他变化，彻底不看朋友圈，不怎么追新闻，总体来说信息更闭塞了。但 2024 却是我生活上最朴素充实的一年，上班做感兴趣的项目下班做喜欢的运动，在我做了很多减法后，现在的生活好像就是自己理想中的状态。</p><p>祝各位新年快乐！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2024 年快结束了，在这最后的一两个小时里我写着这篇年终总结准备跨年了，顺着大致时间线来回顾一下就好了。&lt;/p&gt;
&lt;p&gt;年初就起了个好头，众多加密货币开始上涨。总体而言，2024 年是个加密货币和区块链的大年。有那么一小段时间我每天都在关注涨跌，渐渐地我发现这个领域涨跌都
      
    
    </summary>
    
    
      <category term="Notes" scheme="http://catcoding.me/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>CKB new script verification with VM pause</title>
    <link href="http://catcoding.me/p/ckb-new-verify/"/>
    <id>http://catcoding.me/p/ckb-new-verify/</id>
    <published>2024-11-07T12:03:24.000Z</published>
    <updated>2025-01-03T15:03:41.324Z</updated>
    
    <content type="html"><![CDATA[<p>CKB 相关技术文章第三篇。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CKB 的每一个交易在提交到交易池之前都会经过一个 script verification 的过程，本质上就是通过 CKB-VM 把交易里的 script 跑一遍，如果失败了则直接 reject，如果通过了才会继续后面的流程。</p><p><img src="http://catcoding.me/images/ob_what-is-verification.png" alt=""></p><p>这里的 script 就是一种可以在链上执行的二进制可执行文件，也可以称之为 CKB 上的合约。它是图灵完备的，我们通常可以通过 C、Rust 来实现这些 script，比如 <a href="https://github.com/nervosnetwork/ckb-system-scripts">nervosnetwork/ckb-system-scripts</a> 就是 CKB 上的一些常用的系统合约。用户在发起交易的时候就设置好相关的 script，比如 lock script 是用来作为资产才所有权的鉴定，而 type script 通常用来定义 cell 转换的条件，比如发行一个 User Define Token 就需要指定好 UDT 所对应的 type script。script 是通过 RISC-V 指令集的虚拟机上运行的，更多内容可以参考 <a href="https://docs.nervos.org/docs/script/intro-to-script">Intro to Script | Nervos CKB</a>。</p><h2 id="大-cycle-交易的挑战"><a href="#大-cycle-交易的挑战" class="headerlink" title="大 cycle 交易的挑战"></a>大 cycle 交易的挑战</h2><p>通常一个简单的 script 在 CKB-VM 里面执行是非常快的，VM 上跑完之后会返回一个 cycle 数目，这个 cycle 数量很重要，我们用来衡量 script 校验所耗费的计算量。一个合约的 cycle 数多少，理论上来说依赖于 VM 跑的使用用了多少个指令，这由 VM 在跑的时候去计算 <a href="https://docs.nervos.org/docs/script/vm-cycle-limits">VM Cycle Limits</a>。</p><p>随着业务的复杂，逐渐出现了一些大 cycles 的交易，跑这些交易可能会耗费更多的时间，但我们总不可能让 VM 一直占着 CPU，比如在处理新 block 的时候，<a href="https://github.com/chenyukang/ckb/blob/8cb49e4d727f337a2c80e210507a9e277bab3391/chain/src/verify.rs#L79-L87">CPU 应该在让渡出来</a>。但之前 CKB-VM 对这块的支持不够，为了达到变相的暂停，处理大 cycles 的时候我们可以设置一个 step cycles，假设我们设置为 100 cycles，每次启动的时候就把 max_cycles 设置为 100，这样 VM 在跑完 100 cycle 的时候会退出，返回的结果是 cycle limitation exceed，然后我们就知道这个 script 其实是没跑完的，先把状态保存为 suspend，然后切换到其他业务上做完处理之后再继续来跑。回来后如何才能恢复到之前的执行状态呢，这就需要保存 VM 的 <a href="https://github.com/chenyukang/ckb/blob/aaa51583656f022ad64ec98d1fb0205fc2878dba/script/src/types.rs#L319-L333">snapshot</a>，相当于给 VM 当前状态打了一个快照：</p><p><img src="http://catcoding.me/images/ob_ckb-vm-snapshot.png" alt=""><br>根据这个机制，我们老的 script 校验大交易的整个流程是通过一个 FIFO 的队列保存大交易，然后通过一个后台任务不断地从这个队列中取交易跑 VM，每次都跑 1000w cycle 左右，在这个过程中就可能切换出去，没跑完的交易继续放入队列等待下一次执行：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20241106114040.png" alt=""></p><p>对应到代码就是 <a href="https://github.com/nervosnetwork/ckb/blob/develop/tx-pool/src/chunk_process.rs">ChunkProcess</a> 这个单独服务来处理的。由于 ChunkProcess 是一个单独的服务，它的处理流程和其他交易的处理流程是不一样的，这样会导致代码的复杂度增加，比如：</p><ol><li>要针对 ChunkProcess 里面的交易额外判断，<a href="https://github.com/nervosnetwork/ckb/blob/3d674d558e5574f0c77a52798775c903561a933a/tx-pool/src/process.rs#L321">例子 1</a>, <a href="https://github.com/nervosnetwork/ckb/blob/3d674d558e5574f0c77a52798775c903561a933a/tx-pool/src/process.rs#L350">例子 2</a></li><li>暂停 / 恢复 ChunkProcess 处理的时候，需要对 ckb-vm 做相关的状态保存和恢复处理，参考结构 <a href="https://github.com/nervosnetwork/ckb/blob/3d674d558e5574f0c77a52798775c903561a933a/script/src/types.rs#L308">TransactionSnapshot</a>, 代码比较复杂且容易遗漏，历史上也有过相关的 <a href="https://github.com/nervosnetwork/ckb/pull/3188">bug 1</a>, <a href="https://github.com/nervosnetwork/ckb/pull/3177">bug 2</a>, 以及安全问题。</li><li>代码中包含重复逻辑，比如 <code>chunk_process</code> 里的 <code>process_inner</code> 和 <code>_resumeble_process_tx</code>。</li><li>由于它只能同时处理一个大 cycle 交易，在 tx pool 本身比较空闲的情况下如果收到了多个大 cycle 交易也不能并行处理，比如 .bit 团队之前有过反馈他们通过本地 rpc 同时提交多个大 cycle 交易会比较慢的问题。</li></ol><h2 id="CKV-VM-pause"><a href="#CKV-VM-pause" class="headerlink" title="CKV-VM pause"></a>CKV-VM pause</h2><p>这些问题的根本是 VM 只能通过 cycle step 的方式来暂停，有没有一种方式是我们任何时候想暂停就暂停，就是 event based 的方式。所以后来 CKB-VM 团队做了一些改进：</p><ul><li><a href="https://github.com/nervosnetwork/ckb-vm/pull/348">ckb-vm 新的暂停方式</a></li><li><a href="https://github.com/nervosnetwork/ckb-vm/pull/345">feat: Add alternative snapshot design. #345</a></li><li><a href="https://github.com/nervosnetwork/ckb-vm/pull/299">Make ckb-vm thread-safety #299</a></li><li><a href="https://github.com/nervosnetwork/ckb/pull/3752">CKB feature: thread-safe vm</a></li></ul><p>这个方法的本质是通过 VM 的 <code>set_pause</code> 接口，把一个 <code>Arc&lt;AtomicU8&gt;</code> 的 pause 共享变量设置给 VM。然后在 VM 外通过更新这个 pause 的变量让 VM 进入暂停状态或者继续执行，这样我们就不需要 dump snapshot 等操作，因为 VM 整个就还是在内存中等着：</p><p><img src="http://catcoding.me/images/ob_ckb-vm-pause.png" alt=""></p><h2 id="新的实现方案"><a href="#新的实现方案" class="headerlink" title="新的实现方案"></a>新的实现方案</h2><p>基于这些改进我们可以重新设计和实现 CKB verify 这部分的代码，主要是为了简化这部分代码，并且提高大交易处理的效率。这是一个典型的 queue based multiple worker 方案：</p><p><img src="http://catcoding.me/images/ob_new-ckb-verify.png" alt=""></p><p>主要的核心是就是这段异步执行 VM 的逻辑：<a href="https://github.com/nervosnetwork/ckb/blob/develop/script/src/verify.rs#L1166-L1269">chunk_run_with_signal</a>。做的过程中发现一些其他问题：</p><ul><li>交易提交的时候，<code>SubmitLocalTx</code> 和 <code>SubmitRemoteTx</code> 如果 verify 失败目前会立即返回 <code>Reject</code>，如果改成加入队列的方式，这个结果无法实时给到，所以做了如下改动：<ul><li>优先处理本地的交易，本地提交的交易不会放入 queue，而是直接会在 RPC 的处理阶段执行</li><li>所有的来自网络 peer 的交易都全到放入到 queue</li></ul></li><li>后来 CKB vm 又新增了 spawn 的实现，所以会有 parent、child 的概念，那么<code>Child VM</code> 是执行 syscall 的时候执行 <code>machine.run</code> ，如果不改这块执行 child vm 的时候不可暂停<ul><li>后来我们讨论了之后决定 spawn 时把父的 <code>Pause</code> 传递给子，然后暂停的时候给父的 <code>Pause</code> 设置暂停，这样所有的子 machine 同样返回 <code>VMError::Pause</code> ，同时把当前的 machine 栈重新入栈，恢复的时候继续执行，这里逻辑比较重，相关代码实现：<a href="https://github.com/nervosnetwork/ckb/blob/6f643220c704138298e693b0ef737c56a98ed762/script/src/verify.rs#L1452">run_vms_child</a>。</li></ul></li><li>后来用重新设计了 spawn，使用了一种新的 determined scheduler 的方式去管理所有的 vms 和 IO，之前和 VM 的使用者角度来说之前需要和 VM 交互，现在变成了都通过<a href="https://github.com/chenyukang/ckb/blob/8cb49e4d727f337a2c80e210507a9e277bab3391/script/src/scheduler.rs#L207-L236"> scheduler 来管理</a>。关于 spawn 的设计参考这个文档：<a href="https://github.com/nervosnetwork/rfcs/pull/436/files">Update spawn syscalls</a>。</li></ul><hr><p>整个 PR 在这里：<a href="https://github.com/nervosnetwork/ckb/pull/4291">New script verify with ckb-vm pause</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CKB 相关技术文章第三篇。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;CKB 的每一个交易在提交到交易池之前都会经过一个 script verification 的过
      
    
    </summary>
    
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CKB RBF 设计和实现</title>
    <link href="http://catcoding.me/p/ckb-rbf/"/>
    <id>http://catcoding.me/p/ckb-rbf/</id>
    <published>2024-11-06T11:55:13.000Z</published>
    <updated>2025-01-03T15:03:41.324Z</updated>
    
    <content type="html"><![CDATA[<p>CKB 相关技术文章第二篇。</p><h2 id="Replace-by-fee"><a href="#Replace-by-fee" class="headerlink" title="Replace by fee"></a>Replace by fee</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果一个交易成功发送到交易池，但可能出现因为费用较低而一直得不到处理。之前 CKB 没有其他措施来处理这种情况。</p><p>例如 <a href="https://www.notion.so/Dotbit-4-45e129cb4c434bd2902569aff67c4383?pvs=21">Dotbit 4 位域名注册拥堵</a> 这个事故发生过程中，<code>CKB</code> 的应用方无法使用任何方式来尽快让自己的交易被打包，这就是引入 <code>Replace-by-fee（RBF)</code> 的原因，我们需要一个机制来提高已经在交易池里交易的费用，替换掉旧的交易，让新的交易尽快被打包。</p><p>在新的 <code>multi_index_map</code> 重构后，交易在 <code>pending</code> 阶段也会按照交易的 <code>score</code> 来优先处理 (通常费用高的交易 <code>score</code> 也会高)，这会避免高费用的交易被阻塞住，所以理论上述需要手动提高费用的情况会减少，但我们还是需要 RBF 来手动提高交易的费用，应对意外的情况。</p><p>另外，RBF 可能将多个老的交易替换出去，因此也是将两个或多个支付合并为一的方法，例如下图所示，如果满足条件 <code>tx-a</code>, <code>tx-b</code>, <code>tx-c</code>, <code>tx-d</code> 都会被 <code>tx-e</code> 这个交易替换掉：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20241031103004.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">bips/bip-0125.mediawiki</a></li><li><a href="https://bitcoincore.org/en/faq/optin_rbf/">Bitcoin Core :: Opt-in RBF FAQ</a></li><li><a href="https://www.notion.so/RBF-in-CKB-draft-2023-01-05-79736edd0c824fae98f1e7ee42d4e436?pvs=21">RBF in CKB(draft 2023.01.05)</a></li><li><a href="https://bitcoinops.org/en/newsletters/2022/03/16/#ideas-for-improving-rbf-policy">Bitcoin Optech Newsletter #191 | Bitcoin Optech</a></li></ul><p>中本聪最初的 Bitcoin 版本中就有引入一个 <code>nSequence</code> 的字段，如果相同交易的 <code>nSequence</code> 更高，就可以<a href="https://github.com/trottier/original-bitcoin/blob/master/src/main.cpp#L434">替换</a>之前老的交易，这个实现的问题是没有支付额外的 fee，miner 没用动力去替换交易，另外因为没有 rate-limiting 从而导致可能被滥用，所以 Bitcoin 在 0.3.12 版本中禁止了这个功能。后来 Bitcoin 重新引入了新的 RBF 改进，主要包括需要支付额外的费用来替换老交易，另外为 RBF 指定了更多的限制条件。</p><p>在 CKB 上我们之前做过两次 RBF 的相关调研，因为之前 <code>Pending</code> 是一个 FIFO 的数据结构，所以处理替换不是很方便，在 RBF in CKB(draft 2023.01.05) 尝试引入一个 <code>high priority queue</code> 来实现 <code>inject-replace</code>。交易池改造之后，整个交易池可当作一个优先队列，所以应对 <code>RBF</code> 会简单很多。</p><h2 id="新增-RBF-的流程"><a href="#新增-RBF-的流程" class="headerlink" title="新增 RBF 的流程"></a>新增 <code>RBF</code> 的流程</h2><p><img src="http://catcoding.me/images/ob_rbf2.png" alt=""></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul><li><code>pre-check</code> 为 entry 加入到 tx-pool 之前必须要做的检查，之前只是做双花的检查，新增 RBF 后如果双花检查失败（这里意味着冲突），继续做 RBF 的相关检查，如果 RBF 检查成功则也返回成功，否则直接返回错误。这里默认直接做 resolve_tx 的检查，如果成功则走正常流程，目的是不给正常流程增加额外成本。所以这就是<a href="https://github.com/chenyukang/ckb/blob/44331ec5b9fcda217f33c471057fa479bd36a89f/tx-pool/src/process.rs#L216-L255"><code>pre-check</code> 修改后的主要逻辑</a> 。</li></ul><p>RBF 的检查规则参考 Bitcoin 的六条，<a href="https://github.com/chenyukang/ckb/blob/2be67e79acec94369a96f786d3041e6cb00cf1f2/tx-pool/src/pool.rs#L483-L565"><strong>check_rbf 初步实现</strong></a></p><pre class="line-numbers language-none"><code class="language-none">实现细节：（Bitcoin Core 0.12.0）~~1. 交易需要声明为可替换交易~~ 2. 新替换交易没有包含新的、未确认的 inputs3. 新替换交易的交易费用比待替换交易费用高4. 新替换交易费用必须比节点的 min relay fee 高5. 待替换交易的子交易数量不可超过 100 条（即使用了该交易的任意 outputs，该交易替换后它们将被从内存池中移出）6. 因为 ckb 是做了两步提交，我们新增规则：被替换的交易只能是 Pending 或者 Gap 阶段的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们不给交易加新的字段表示是否可以被替换，而是通过节点是否配置了 <code>min_rbf_rate</code> 来决定是否能做替换，因此 <code>规则 1</code> 不做对应考虑。</p><h3 id="替换和提交"><a href="#替换和提交" class="headerlink" title="替换和提交"></a>替换和提交</h3><p>修改 <code>tx-pool</code> 的 <code>submit_entry</code> 函数，传入 <code>conflicts</code>，在新增 entry 之前把所有冲突的交易删除 放入 <code>rejected</code> 记录，另外确保所有检查完成了之后才做删除和写操作：<a href="https://github.com/chenyukang/ckb/blob/2be67e79acec94369a96f786d3041e6cb00cf1f2/tx-pool/src/process.rs#L99-L154">submit_entry 逻辑</a>。</p><p>最终实现在这个 PR 里<a href="https://github.com/nervosnetwork/ckb/pull/4079">Tx pool Replace-by-fee</a>。</p><h3 id="并发的-Bug"><a href="#并发的-Bug" class="headerlink" title="并发的 Bug"></a>并发的 Bug</h3><p>在最初的实现版本中，隐藏了一个并发的 bug 后来在测试发现了。RBF 的检查如果放在 <code>pre-check</code> 中，如果多个线程中的多个交易发生了冲突，input resolve 可能会出问题。<a href="https://github.com/nervosnetwork/ckb/pull/4258">Fix concurrency issue for RBF</a> 这个 PR 修复了这个问题，把 RBF 的冲突检查移动了 submit entry 之前，因为在这个函数里面会持有 write 锁。</p><h3 id="cycling-attack"><a href="#cycling-attack" class="headerlink" title="cycling attack"></a>cycling attack</h3><p>后来我们在做闪电网络的时候又发现 RBF 可能会引入 cycling attack 的风险，这个攻击通过构造巧妙的新交易，让支付路径上的中间节点的 commitment tx 不能按时上链，<a href="https://blog.satsbridge.com/lightning-replacement-cycling-attack-explained-45636e41bc6f">Lightning Replacement Cycling Attack Explained</a>这篇文章有更详细的描述。</p><p>所以我们后来又做了这么一个改进：<a href="https://github.com/nervosnetwork/ckb/pull/4561">Recover possible transaction in conflicted cache when RBF</a> 来规避这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CKB 相关技术文章第二篇。&lt;/p&gt;
&lt;h2 id=&quot;Replace-by-fee&quot;&gt;&lt;a href=&quot;#Replace-by-fee&quot; class=&quot;headerlink&quot; title=&quot;Replace by fee&quot;&gt;&lt;/a&gt;Replace by fee&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CKB 交易池重构</title>
    <link href="http://catcoding.me/p/ckb-txpool-refactor/"/>
    <id>http://catcoding.me/p/ckb-txpool-refactor/</id>
    <published>2024-11-06T11:39:21.000Z</published>
    <updated>2025-01-03T15:03:41.324Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><h1 id="在-11-9-号清迈的-CKCON-会议上我会做一个关于-CKB-交易池的演讲，这是我准备的-slides-Key-Upgrades-of-the-CKB-Core-。所以这段时间在整理之前做项目的时候写的一些文档，顺便分享到自己的博客上。既然我们整个项目的源码都是公开的，所以这些文档其实也是可以分享的。"><a href="#在-11-9-号清迈的-CKCON-会议上我会做一个关于-CKB-交易池的演讲，这是我准备的-slides-Key-Upgrades-of-the-CKB-Core-。所以这段时间在整理之前做项目的时候写的一些文档，顺便分享到自己的博客上。既然我们整个项目的源码都是公开的，所以这些文档其实也是可以分享的。" class="headerlink" title=" 在 11.9 号清迈的 CKCON 会议上我会做一个关于 CKB 交易池的演讲，这是我准备的 slides Key Upgrades of the CKB Core 。所以这段时间在整理之前做项目的时候写的一些文档，顺便分享到自己的博客上。既然我们整个项目的源码都是公开的，所以这些文档其实也是可以分享的。"></a> 在 11.9 号清迈的 <a href="https://share.foresightnews.pro/article/detail/70811">CKCON</a> 会议上我会做一个关于 CKB 交易池的演讲，这是我准备的 slides <a href="https://ckb-tx-pool.vercel.app/1">Key Upgrades of the CKB Core</a> 。所以这段时间在整理之前做项目的时候写的一些文档，顺便分享到自己的博客上。既然我们整个项目的源码都是公开的，所以这些文档其实也是可以分享的。</h1><p> 在 11.9 号清迈的 ckconf 会议上我会做一个关于 CKB 交易池的演讲，所以这段时间在整理之前做项目时候写的一些文档，顺便分享到自己的博客上。既然我们整个项目的源码都是公开的，所以这些文档其实也是可以分享的。</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>23a61d549 (android backup: 2024-12-29 16-03-03)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>第一次听说 CKB 的读者可以参考这个文档以了解什么是 CKB 以及如何工作的：<a href="https://docs.nervos.org/docs/getting-started/how-ckb-works">How CKB Works | Nervos CKB</a>。</p><p>我加入 Cryptape 之后一年内做的主要工作，涉及到交易池重构、Replace-by-fee 功能、以及 new-verify。这是第一篇关于交易池重构的文章。</p><h2 id="什么是交易池"><a href="#什么是交易池" class="headerlink" title="什么是交易池"></a>什么是交易池</h2><p>在 bitcoin 中交易池叫作 mempool，比如 <a href="https://mempool.space/">mempool - Bitcoin Explorer</a> 这个网站就很好地展示了其当前的状态。</p><p>交易池是 bitcoin 中的一个重要的组件，但感觉专门关于这块的资料很少，只能通过 PR 和邮件列表上的讨论看到一些文档。但交易池非常重要，因为一个交易要上链必须会通过交易池，而其中的交易打包算法涉及到如何选择合适的交易，这里面有很多因素需要考虑，所以在实现上也是比较复杂的。</p><p>当一个交易被提交到一个节点时，或者一个节点从网络中同步到交易时，这个交易首先需要被加入到交易池中，交易池里会根据一定的算法去选择下一个需要被打包的交易，另外交易池作为一个缓存，我们需要为其设置一个最大的 size。所以交易池里面最重要的两个操作就是 packaging 和 evicting。</p><p>交易池里面的交易存在父子关系，打包的时候需要从交易链的纬度去考虑，后面的 Replace by fee 这些功能也需要关注整个交易的所有子交易。</p><p><img src="http://catcoding.me/images/ob_transaction-pool.jpg" alt=""></p><h2 id="交易池重构"><a href="#交易池重构" class="headerlink" title="交易池重构"></a>交易池重构</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>根据 RFC <a href="https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0020-ckb-consensus-protocol/0020-ckb-consensus-protocol.md#two-step-transaction-confirmation">consensus-protocol</a> 的设计，CKB 里的 tx-pool 采用了两段提交的方式：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20241031100804.png" alt=""></p><p>相应地在交易池最初实现的时候， <code>ckb</code> 的代码实现中 <a href="https://github.com/nervosnetwork/ckb/blob/rc/v0.111.x/tx-pool/src/pool.rs">tx-pool</a> 同样采用了三个独立的队列，具体定义如下：</p><ul><li><code>pending</code> 交易刚加入到交易池时候的状态，我们每次只能处理不多于 <code>MAX_BLOCK_PROPOSALS_LIMIT</code> 个交易，交易需要先进入 <code>gap</code> 备选，具体代码逻辑在 <a href="https://github.com/nervosnetwork/ckb/blob/3de5a20ce60619927f41f81d9584cab9d39d1275/tx-pool/src/block_assembler/mod.rs#L345C11-L345C11">update_proposals</a> 。</li><li><code>gap</code> 已经被 proposed 了，但是还不能被打包，需要等一个块后才能被打包，所以这只是内部中间过渡状态。</li><li><code>proposed</code> 交易可以加入到 <code>block_template.transactions</code> , 最终打包到 block 里，具体代码逻辑在 <a href="https://github.com/nervosnetwork/ckb/blob/e75ab3faf0f7b1d182be2f1daa30f300cfefabc8/tx-pool/src/block_assembler/mod.rs#L195">block_assembler</a>。</li></ul><p>实现中 <code>pending</code> 和 <code>gap</code> 同样都是使用了 <code>PendingQueue(LinkedHashMap)</code>，而 <code>proposed</code> 采用了 <code>SortedTxMap(HashMap + BTreeSet)</code> ：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">TxPool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> config<span class="token punctuation">:</span> <span class="token class-name">TxPoolConfig</span><span class="token punctuation">,</span>    <span class="token comment">/// The short id that has not been proposed</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> pending<span class="token punctuation">:</span> <span class="token class-name">PendingQueue</span><span class="token punctuation">,</span>    <span class="token comment">/// The proposal gap</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> gap<span class="token punctuation">:</span> <span class="token class-name">PendingQueue</span><span class="token punctuation">,</span>    <span class="token comment">/// Tx pool that finely for commit</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> proposed<span class="token punctuation">:</span> <span class="token class-name">ProposedPool</span><span class="token punctuation">,</span>    <span class="token punctuation">...</span><span class="token punctuation">.</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> expiry<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的实现存在以下问题：</p><ul><li><p>我们不容易对所有在交易池中的 entry 做统一排序，这样会存在以下问题：</p><ul><li>一个 fee 高的交易可能在 transaction 多的情况下在 pending 阶段一直卡着，因为我们在 pending 和 gap 阶段只是按照时间顺序来处理，只在 proposed 后的打包阶段按照交易费来处理。</li><li><a href="https://github.com/nervosnetwork/ckb/issues/3942">issue 3942</a> 交易池满了之后，我们需要选择一些 entry 做 evict，我们目前的 evict 逻辑很<a href="https://github.com/nervosnetwork/ckb/blob/fdee47bbd87c66d8a0e54c3ac1f5386cb9aba643/tx-pool/src/pool.rs#L322">简单粗暴</a>。我们希望尽量选择最小 descendants 的交易，这样能避免在 evict 过程中删除过多交易。我们目前在 pending 和 gap 阶段没有记录 descendants，而需要加入这个逻辑就和 proposed 阶段完全重复，而且因为不会统一排序，后续实现也不容易。</li></ul></li><li><p>pending, gap 和 proposed 除了所采用的数据结构不同外，有很多逻辑雷同的代码，比如 entry 的新增和删除等操作，同样都维护了 deps 和 header_deps，resolve_conflict, resolve_conflict_header_dep, resolve_tx 等函数的逻辑也是类似的，但实现上有些细微差异，这导致长期来说代码不容易维护。</p></li><li>同样我们在 <code>tx-pool</code> 上对 entry 做迭代和查询时，需要依次针对 pending, gap, proposed 做相同的逻辑，比如 resolve_conflict_header_dep 这样的函数在 pool 中有几个类似的，甚至 get_tx_with_cycles 这样的函数，需要依次判断各个队列。</li><li>实现其他功能不方便，比如我们如果要实现 Replace by fee，就需要找交易池中和新交易有冲突的交易，我们需要在三个数据结构上分别进行检查才能得到结果。</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>基于以上解决现有问题、应对未来的潜在需求、保持代码可维护性的角度，同时参考 <a href="https://github.com/bitcoin/bitcoin/blob/322ec63b01499c1ec52d3912ee382ebd59f2366b/src/txmempool.h">Bitcoin txmempool</a> 的实现，我们提出引入 <strong>Multi_index_map</strong> 对 tx-pool 进行重构。</p><p>总体方向是把所有的 <code>entry</code> 放入统一的数据结构中进行管理，加入一个新的字段 <code>status</code> 标识目前 <code>entry</code> 所处的阶段，然后通过 index_map 的方式根据不同的属性进行排序和迭代：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">Status</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Pending</span><span class="token punctuation">,</span>    <span class="token class-name">Gap</span><span class="token punctuation">,</span>    <span class="token class-name">Proposed</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[derive(MultiIndexMap, Clone)]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">PoolEntry</span> <span class="token punctuation">&#123;</span>    <span class="token attribute attr-name">#[multi_index(hashed_unique)]</span>    <span class="token keyword">pub</span> id<span class="token punctuation">:</span> <span class="token class-name">ProposalShortId</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> score<span class="token punctuation">:</span> <span class="token class-name">AncestorsScoreSortKey</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> status<span class="token punctuation">:</span> <span class="token class-name">Status</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> evict_key<span class="token punctuation">:</span> <span class="token class-name">EvictKey</span><span class="token punctuation">,</span>    <span class="token comment">// other sort key</span>    <span class="token keyword">pub</span> inner<span class="token punctuation">:</span> <span class="token class-name">TxEntry</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中根据 Rust 社区的 <a href="https://github.com/lun3x/multi_index_map">multi_index_map</a> 内部实现采用的数据结构看，性能上应该没有什么大问题：</p><ul><li>Hashed index retrievals are constant-time. (FxHashMap + Slab).</li><li>Sorted indexes retrievals are logarithmic-time. (BTreeMap + Slab).</li><li>Non-Unique Indexes<ul><li>Hashed index retrievals are still constant-time with the total number of elements, but linear-time with the number of matching elements. (FxHashMap + (Slab * num_matches)).</li><li>Sorted indexes retrievals are still logarithmic-time with total number of elements, but linear-time with the number of matching elements. (BTreeMap + (Slab * num_matches)).</li><li>Iteration within an equal range of a non-unique index is fast, as the matching elements are stored contiguously in memory. Otherwise iteration is the same as unique indexes.</li></ul></li></ul><p>具体实现时我们是否把 inner 也放在 Slab 里面以后可以通过 benchmark 来选择，从实现的简洁性角度考虑统一放在一个数据结构里面更容易。</p><p>目前的实现版本：<a href="https://github.com/nervosnetwork/ckb/pull/3993">Tx pool rewrite with multi_index_map #3993</a></p><h2 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h2><p>我们首先只是做模块内的重构 (保持对外逻辑和以前一样)，当然考虑引入了新的数据结构，不管是从性能上还是内存占用上都会有一些影响。</p><p>为了做统一排序这件额外的事，本质上我们引入了额外的 Map(FxHashMap 或 BTreeMap) 来存储，所以比以前需要更多内存。另外，我们有时候需要调用 <code>get_by_status</code> 来筛选某个状态的 entries，这在新的实现里面需要先从 index 里面找出 slab 的 id，然后再找到对应的 entry，所以必然也会比以前慢。</p><p>从最终的性能对比结果上，除了内存会稍微有增加，性能上没有大的变化。另外我们在实现的过程中对所用到的 Rust 包 multi-index-map 做了一些贡献：<a href="https://github.com/lun3x/multi_index_map/pull/23">Non-unique index support, capacity operations, performance improvement &amp; more by wyjin</a>。</p><p>这是我入职后做的第一个主要工作，因为我们的各种测试比较齐全，所以做大的重写信心也比较足。Rust 的生态就有这种问题，如果一个 crate 不是被广泛使用的，必然还是会存在各种坑需要填。总体来说，第一个项目很顺利。做完这个重构之后对于后面的 Replace by fee 等功能也准备好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD&lt;/p&gt;
&lt;h1 id=&quot;在-11-9-号清迈的-CKCON-会议上我会做一个关于-CKB-交易池的演讲，这是我准备的-slides-Key-Upgrades-of-the-CKB-Core-。所以这段时间在
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://catcoding.me/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>xz-backdoor 观感</title>
    <link href="http://catcoding.me/p/xz-backdoor/"/>
    <id>http://catcoding.me/p/xz-backdoor/</id>
    <published>2024-04-04T18:04:33.000Z</published>
    <updated>2025-01-03T15:03:41.336Z</updated>
    
    <content type="html"><![CDATA[<p>写写最近一周的大瓜 xz-backdoor，该事件可能成为开源供应链安全的一个分水岭，从技术角度看，这里面的社工和混淆也是精彩。</p><p>简单介绍一下背景，xz 是一个开源的无损压缩工具，在出事之前可能很少有人注意到这个压缩库使用如此之广，几乎任何一个 Unix-Like 的操作系统里面都有 xz-utils。在两年多的时间里，一个名为 <code>Jia Tan</code> 的程序员勤奋而高效地给 xz 项目做贡献，最终获得了该项目的直接提交权和维护权。之后他在 libzma 中加入了一个非常隐蔽的后门，该后门可以让攻击者在 SSH 会话开始时发送隐藏命令，使攻击者能够跳过鉴权远程执行命令。</p><p><a href="https://research.swtch.com/xz-timeline#jia_tan_arrives_on_scene_with_supporting_cast">Timeline of the xz open source attack</a> 总结了该事件的主要时间点，这里我挑一些关键节点：</p><h4 id="潜伏"><a href="#潜伏" class="headerlink" title="潜伏"></a>潜伏</h4><ul><li>2005 ~ 2008 xz 项目的初始版本，这是一个文件压缩算法，主要由 <a href="https://github.com/kobolabs/liblzma/blob/87b7682ce4b1c849504e2b3641cebaad62aaef87/doc/history.txt">Lasse Collin</a> 开发和维护。</li><li>2021-10-29 ~ 2022-06-29 Jia Tan 开始较为密集地给 xz 项目贡献代码，同时几个类似马甲的账号 (Jugar Kumar, Dennis Ens) 在邮件列表里抱怨 Merge 得不到及时处理，问题得不到回复，有点逼宫的意思，在这个过程中项目主导者 Lasse Collin 把最近的优秀贡献者加入了维护者列表。<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4></li><li>2022-09-27 Jia Tan 获得了信任，并开始主导新版本的发布，他在这期间做了几个看似合理的 PR，但其实是在为今后的后门做伏笔，另一个马甲 Hans Jansen 提供了一个钩子可以让后门里的代码替换全局函数，从而绕过检查。</li><li>2023-07-07 Jia Tan 在 Google 的 oss-fuzz 提供修改禁用了 <code>ifunc</code>，这也是为了避免 fuzz 可能发现后门。<h4 id="发动"><a href="#发动" class="headerlink" title="发动"></a>发动</h4></li><li>2024-02-23 Jia Tan 发布了第一个有害的 PR，在测试代码中包含了几个 binary 文件，这些文件看起来只用于测试，所以在代码 review 的过程中肯定不会被仔细查看。</li><li>2024-02-26 Jia Tan 通过一个<a href="https://git.tukaani.org/?p=xz.git;a=commitdiff;h=328c52da8a2bbb81307644efdb58db2c422d9ba7">非常隐蔽的提交</a>，给 CMakeList.txt 增加了一个 <code>.</code>，使得代码会编译失败从而让 Landlock 不会被激活。</li><li>2024-02-24 Jia Tan 发布 v5.6.0，其中使用脚本混淆悄悄地把后门的 payload 塞进了目标文件中。Gentoo 和 Debian 开始在 unstable 版本中含有后门。</li><li>Hans Jansen 同时在发邮件催促 Debian 升级 xz 到 v5.6.1<h4 id="暴露"><a href="#暴露" class="headerlink" title="暴露"></a>暴露</h4></li><li>2024-03-29: 一个叫 Andres Freund 的开发者在分析一个 sshd 可疑的 500ms 延迟时，发现了隐藏在 xz 的恶意后门。如果不是偶然的发现，估计现在世界上无数的服务器处于肉鸡状态，这位微软的员工如英雄一般拯救了世界。</li></ul><hr><h2 id="攻击者是中国人？"><a href="#攻击者是中国人？" class="headerlink" title="攻击者是中国人？"></a>攻击者是中国人？</h2><p>从主要攻击者的名称看似乎是中国人，但 Git 昵称和时区这种东西很容易伪造，有人分析过开发者的代码提交时间，分析得出实际可能是欧洲人/以色列人冒充。</p><p>但不可否认，肯定会有不少国外的开发者会默认这就是中国人所为，我也看到了一些开发者开始带节奏，开始找各种和 Jia Tan 有过互动的中国程序员。</p><p>我倾向于相信这不是中国攻击者，感觉其 commit 信息里面的英文中没找到中式表达。比较确定的是，从这些马甲之间的密切配合来看，这像是一个有密谋的组织团体。</p><h2 id="开源软件的脆弱性"><a href="#开源软件的脆弱性" class="headerlink" title="开源软件的脆弱性"></a>开源软件的脆弱性</h2><p>开源意味着透明，但并不意味着安全。</p><p>10 多年前我们经历了 OpenSSL 的心脏滴血，如今类似的事情再次发生。甚至这次事件的性质更严重，心脏滴血漏洞本身是因为代码的逻辑问题导致被恶意利用，而这次是攻击者通过供应链恶意植入后门。</p><p>有一种观点是开源软件被更多人 review，所以理论上来说安全漏洞更容易被发现。但实际上看来，被巧妙设计过的代码改动，很不容易被发现问题，比如这次事件中这个提交，我相信绝大部分开发者无法发现被恶意添加的 <code>.</code>:</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403114716.png" alt=""></p><p>这次后门被发现有很大的运气成分，多亏了 Andres Freund 的细心和刨根问底的精神，这也算是有足够多的眼睛盯着所以发现了问题吧。</p><h2 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h2><p>如果有一个开源贡献者的身份识别机制，就可能预防类似的事情。我看到有人举例 Linux Kernel 提交必须使用 Git 的 Sign-off，但这个 Sign-off 更多的是在解决法律上的问题，Sign-off 本来就是因为法律诉讼而引入的。而且，在最坏情况下，一个开发者可能被社工或者入侵而导致身份被冒用，所以 Sign-off 并不意味着身份识别。</p><p>有的人提到通过支付来进行 KYC(Know Your Customer)，这必然是不可能的，因为开源本来就是一个黑客文化的产物，大量的开发者会刻意选择使用匿名身份提交代码。</p><p>我们来看看 Bitcoin，如果论项目值钱程度，比特币的代码应该能排得上号。但比特币是支持 Permissionless and Pseudonymous development 的，甚至这是保证比特币去中心化的两个很重要的手段，中本聪的身份仍然是一个迷。中本聪选择匿名对比特币本身来说也至关重要，<code>No one controls Bitcoin</code> 是其价值根本。</p><p>那比特币如何保证不会被植入后门，比如这种供应链攻击？</p><ul><li>Reproducible builds，这是个极大地缓解供应链风险的办法，不同的人编译相同的源代码必然得到相同的二进制文件，binary file 不能存在于源码库中。Bitcoin 使用 Guix container 从源码编译所有的东西，<a href="https://github.com/bitcoin/bitcoin/pull/15277">contrib: Enable building in Guix containers</a>，这个过程可以在任何 Linux 发行版上重现。在这个过程中，几乎所有的一切都从源码编译，所以会存在一个鸡生蛋蛋生鸡的问题，为了解决这个问题必然会需要一些 binary files，但最好是将这个范围限制到最小，<a href="https://guix.gnu.org/manual/en/html_node/Preparing-to-Use-the-Bootstrap-Binaries.html">Preparing to Use the Bootstrap Binaries</a>。</li><li>Don’t forget to verify yourself！</li></ul><p>另外比特币的安全在于 PoW，其设计本来就假设了少部分节点可能是恶意节点，除非黑客控制住了大部分节点才能造成破坏，而要达成这点在的概率可以认为就是零</p><h2 id="开源的可持续性"><a href="#开源的可持续性" class="headerlink" title="开源的可持续性"></a>开源的可持续性</h2><p>从这个安全事件我们可以继续探讨开源的可持续性这个问题。这个事件中 xz 的维护者 Lesse Collin 看起来已经是处于疲于应付的地步。从<a href="https://github.com/xz-mirror/xz/graphs/contributors">贡献者统计</a>可以看到这么多年几乎就是他一个人在给项目提交代码，Jia Tan 通过两年的潜伏就成为了贡献者第二的开发者：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403140505.png" alt=""></p><p>长时间维护一个被大量使用的开源项目是个巨大的负担，对维护者而言不仅仅是时间的投入，有时候也是精神上的折磨，即使开发者当初的有多好的愿景，但谁也无法保证常年的持续投入。关于这点可以阅读这篇文章，<a href="https://kettanaito.com/blog/the-dark-side-of-open-source">The Dark Side of Open Source</a>。</p><p>Lesse Collin 在这次事件中被利用了这个弱点，他在这封邮件里解释到自己作为项目主导者的困境：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403014036.png" alt=""></p><p>写到这里我想起自己也曾经催过一个库的作者，是不是考虑让更多人来维护项目 <a href="https://github.com/GREsau/schemars/issues/272">Maintenance status · Issue</a> 😅。</p><p>也许未来可能有一套机制，能够让基础开源软件的维护者得到经济激励，但这条路如何演化出来我还没看出来，如果真的出来或许与加密货币有一定关联。</p><p>可怕的是，现在还有很多人没有意识到开源贡献者困境，那些价值几千上万亿的公司也是在期望开源的开发者能够像雇员似的响应他们的 High Priority：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403013012.png" alt=""></p><p>这个世界上还是有无数的默默耕耘的开源代码维护者，比如 SQLite，全球大概有上万亿的 SQLite 数据实例跑在服务器上、手机上、浏览器里，但这个软件其实只由 3 个程序员维护了 20 多年；几乎所有工程师都使用的工具 curl，由 Daniel Stenberg 从 1998 维护到至今；vim 的作者 Bram Moolenaar 从 1991 年维护项目到自己去世，总共整整 32 年。</p><p>实际上没有人知道，多少被广泛使用的基础组件和代码是由各种默默无闻、分毫未取的开发者在用自己的业余时间维护着。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240403135349.png" alt=""></p><p>从这个角度看，人类数字基础设施这艘巨轮其实建立在非常脆弱的基础上，说不定哪天一个地方就裂开了。我现在养成了一个习惯，升级从来不追新，任何安装到自己电脑上的二进制都小心翼翼。</p><p>这个世界上有无数的恶魔，也会有一些英雄和吹哨人，致敬 Andres Freund。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写写最近一周的大瓜 xz-backdoor，该事件可能成为开源供应链安全的一个分水岭，从技术角度看，这里面的社工和混淆也是精彩。&lt;/p&gt;
&lt;p&gt;简单介绍一下背景，xz 是一个开源的无损压缩工具，在出事之前可能很少有人注意到这个压缩库使用如此之广，几乎任何一个 Unix-Li
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="安全" scheme="http://catcoding.me/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>从明天起，做一个 Rust 程序员</title>
    <link href="http://catcoding.me/p/rust-bootcamp/"/>
    <id>http://catcoding.me/p/rust-bootcamp/</id>
    <published>2024-03-18T16:28:13.000Z</published>
    <updated>2025-01-03T15:03:41.332Z</updated>
    
    <content type="html"><![CDATA[<p>3 月是怀念海子的月份：</p><blockquote><p>从明天起，做一个 Rust 程序员，喂马、劈柴，周游世界。</p></blockquote><p>10 年前我开始写第一行 Rust 程序，到如今全职远程做 Rust 开源项目，也许我真能去过喂马劈柴周游世界了😆。但回想自己的学习旅程，其中有各种曲折有几度放弃的时候，如果你也想学习或者提高 Rust 方面的技能，我这篇文章里有一条更容易的路。</p><h2 id="为什么学习-Rust"><a href="#为什么学习-Rust" class="headerlink" title="为什么学习 Rust"></a>为什么学习 Rust</h2><p>Rust 1.0 发布已经快 10 年，所以并不是一门新编程语言了，从发展的角度来看 Rust 已经度过了生存期，并进入了迅速发展的阶段。从目前可见的业界方向来说，Rust 主要在以下几个方面取得了成功：</p><ul><li>在基础软件领域成为有力竞争者<ul><li>大量开源的 Rust <a href="https://github.com/sts10/rust-command-line-utilities">命令行工具</a>和开发库，如果你使用 Python，可以通过  <a href="https://pyo3.rs/v0.21.0-beta.0/">PyO3</a> 用 Rust 来写对性能要求更高的模块，还出现了 <a href="https://github.com/apache/opendal">opendal</a> 这样优秀的基础库</li><li>Cloudflare 使用 Rust 开发新的网关 <a href="https://blog.cloudflare.com/pingora-open-source">Pingora</a></li><li>开源数据库实现，比如 <a href="https://qdrant.tech/">Qdrant</a>、 <a href="https://risingwave.com/">RisingWave</a>、<a href="https://github.com/datafuselabs/databend">databend</a></li><li>AI 方面参考 <a href="https://www.arewelearningyet.com/">Are we learning yet</a>，虽然 Rust ML 生态系统还很年轻并处于试验阶段，但已经出现了一些雄心勃勃的项目和模块，Hugging Face 开源了 <a href="https://github.com/huggingface/candle">candle</a>机器学习框架</li></ul></li><li>前端的基础设施<ul><li>Rust 在前端领域发展迅速，Rust 是 WebAssembly 支持最好的编程语言，不少 Runtime 都是 Rust 实现的，比如 Wasmer</li><li>大量前端基础工具在使用 Rust 重新实现，比如 <a href="https://www.rspack.dev/">Rspack</a>、<a href="https://vercel.com/blog/turbopack">Turbopack</a>、前几天又出现了 <a href="https://github.com/rolldown/rolldown">rolldown</a>，<a href="https://leerob.io/blog/rust">Rust Is The Future of JavaScript Infrastructure</a>似乎已经成为共识</li></ul></li><li>操作系统<ul><li>Windows 开始使用 Rust 开发一些核心组件</li><li>Rust 开始进入 Linux 内核，使得使用 Rust 开发 Linux module 成为可能</li><li>Andriod 使用 Rust 开发更多组件，并有效减少了内存方面的漏洞，他们发布的 <a href="https://google.github.io/comprehensive-rust/">Comprehensive Rust</a>是一个很好的学习资料。Google 开始尝到 Rust 的好处，并开始投入更多资金和人力，近期 <a href="https://security.googleblog.com/2024/02/improving-interoperability-between-rust-and-c.html">Google 打算捐献 100 万美金给 Rust 基金会</a>着重解决 Rust 和 C++ 的互操作性</li></ul></li><li>区块链领域<ul><li>以我在这个领域工作一件多的经验来说，Rust 成为了区块链领域的标配，基本区块链相关的工作岗位 Rust 技能是一个极大的加分项</li><li>大量公链使用 Rust 来开发</li></ul></li><li>游戏开发，参考 <a href="https://arewegameyet.rs/">Are we game yet?</a>，目前已经有成熟的游戏开发框架 <a href="https://bevyengine.org/">Bevy Engine</a></li></ul><p>如果你对 Rust 的发展情况感兴趣，可以参考 <a href="https://blog.rust-lang.org/2024/02/19/2023-Rust-Annual-Survey-2023-results.html">2023 Annual Rust Survey Results</a>。在内卷的 IT 市场，作为程序员选择一门小众的编程语言是避免过度竞争的方式，我之前介绍过其他人的类似经验，我们称之为 <a href="https://catcoding.me/p/weekly-13/">The Niche Programmer</a>。Rust 还未成为主流编程语言，但潜力和发展空间很大，而门槛相对其他语言比较高，所以我认为从求职的角度来考虑是值得一试的。</p><p>之前提到 Google 投入更多的资金在 Rust 上面，钱进来后相关的职位就出来了 <a href="https://foundation.rust-lang.org/careers/">C++/Rust Interop Initiative Software Engineer Lead</a>。</p><h2 id="我学习-Rust-的体会"><a href="#我学习-Rust-的体会" class="headerlink" title="我学习 Rust 的体会"></a>我学习 Rust 的体会</h2><p>我 2014 年时践行每年学习一门新的编程语言，Rust 作为一门新的编程语言进入了我的视野。我开始使用  Rust 写些简单的个人学习项目，然后我继续做了 <a href="https://exercism.org/tracks/rust/exercises">Rust exercises</a> 。</p><p>后续几年我偶尔看看 Rust 相关的新闻和项目，时不时动手写点代码都会有点磕磕碰碰。直到四年前开始在 Github 上给一些 Rust 开源项目贡献，两年前开始给 Rust 编译器做贡献，一年前开始全职从事 Rust 区块链相关的工作。</p><p>从技术角度来说，Rust 非常有趣，这里面包含了近些年程序设计方面的一些良好实践。全职写 Rust 程序这一年多是我开发体验最好的阶段，当然有时候我们需要和编译器斗智斗勇、做类型体操，但很多问题在开发阶段给规避掉了。</p><p>Rust 的最大问题还是在于学习门槛相对较高，因为在 Rust 中程序员接触最多的  <code>=</code> 语义都变了。从我个人体验来说，在学会了 Rust 语法后会陷入一个瓶颈，如果日常工作中不使用 Rust，就没有多少机会去实践，另外不知道做一些什么项目。</p><p>我相信很多人同样如此，看了官方 tutorial 之后不知道如何下手，我想如果有一个经验丰富的老师带，会少走很多弯路，这就是我要介绍的极客时间训练营要解决的问题。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240316231547.png" alt=""></p><h2 id="极客时间-Rust-训练营"><a href="#极客时间-Rust-训练营" class="headerlink" title="极客时间 Rust 训练营"></a>极客时间 Rust 训练营</h2><p>说起来我与这个训练营还有些渊源。</p><p>当极客时间在筹划这个 Rust 训练营的时候，策划人员找到过我问我是否有意愿当这个课程的讲师。我还稍微犹豫了一下，因为我之前也想过如何在 Rust 领域做更多的分享，我很羡慕优秀的技术分享者比如 <a href="https://www.youtube.com/@jonhoo">Jon Gjengset</a>能够非常自如地通过视频分享 Rust 方面的技术。当老师当然是个机会能从沟通和表达方面提高这方面的能力。</p><p>后来考虑到自己时间方面安排不过来，我有全职工作、有业余的 Rust 社区工作、还有三个小孩，所以我应该真没时间去录制课程了，而且他们已经找到了我认为最合适的讲师：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240316223445.png" alt=""></p><p>我看了这个项目的大纲，陈天老师希望可以教大家怎么用 Rust 比较简单的语法和技巧，来完成 80% 的日常工作，主要是通过各种实践项目来学习，这也是我最推崇的 Learn by doing 的方式。</p><p>有很多主题我都没怎么接触过，比如构建一个 ChatGPT 的应用、比如跨平台 GUI 之类的，所以我对这个课程很感兴趣，然后我和策划说能不能做这个项目的助教，后来沟通下来发现当助教也需要不少时间的，所以就没机会参与到具体的教学里面了。</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240316231751.png" alt=""></p><p>总之，这个项目对于想学习 Rust 或者已经有一定 Rust 经验，但想获得更多实践经历的人是非常合适的。在和极客时间的相关人员沟通的过程中，我发现他们做事情很用心，这个训练营的课程质量我认为是有保证的。</p><p>这个训练营一共是 15 周的课程安排，其中每周都会有明确的项目安排，课后还有助教答疑。关于训练营的更多信息请参考：<a href="https://u.geekbang.org/subject/rust">极客时间训练营-Rust 训练营</a></p><p><img src="http://catcoding.me/images/ob_rust-boot-20240318164451.png" alt=""></p><h2 id="我与陈天老师的小故事"><a href="#我与陈天老师的小故事" class="headerlink" title="我与陈天老师的小故事"></a>我与陈天老师的小故事</h2><p>我最早知道陈天是他写的公众号《程序人生》，他是那种技术和文笔都非常棒的程序员，非常难得。我还看过他的 B 站上的技术讲解视频，他的演讲和分享都很流畅。陈天是极客时间《陈天 · Rust 编程第一课》专栏作者，已有 2.3w 人学过，广受好评。技术能力、演讲表达、对技术的热情这些都是讲师最重要的素质要求，所以陈天是这个训练营最好的讲师人选。</p><p>再分享一个小故事，我一年多前跳槽的时候还有些犹豫，因为自己的职业规划方面有些困惑，所以想找些人聊聊。当时我突然想到陈天之前从事过区块链方面的创业，后来从里面退出来了，所以我就想向他咨询一下。我没有他的联系方式，但灵机一动我想到了从 Git 的提交记录里面找 Email，然后抱着试一试的想法给他发了个邮件说明了自己的情况和困惑。没想到他很快给我回复了，并很详细地告诉我他对于区块链的想法，还有如何判断自己是否适合一个公司，通过各种途径了解公司的相关产品来作为决策的依据等等。</p><p>我作为一个陌生人，陈天老师都会乐于给与指导和帮助，可见为人真的很好。还没能有幸和陈天老师现实中有所交流，我本来想用当助教的机会和陈天老师多学习，但时间方面安排不过来了。希望大家能在老师的的训练营学到知识、经验、还有探索技术的乐趣！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;3 月是怀念海子的月份：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从明天起，做一个 Rust 程序员，喂马、劈柴，周游世界。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;10 年前我开始写第一行 Rust 程序，到如今全职远程做 Rust 开源项目，也许我真能去过喂马劈柴周游
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>我喜欢的 shell 工具</title>
    <link href="http://catcoding.me/p/handy-sh-tools/"/>
    <id>http://catcoding.me/p/handy-sh-tools/</id>
    <published>2024-03-16T23:52:40.000Z</published>
    <updated>2025-01-03T15:03:41.328Z</updated>
    
    <content type="html"><![CDATA[<p>分享一些日常经常使用的命令行小工具，我认为这些小东西能提高我的工作效率。</p><h2 id="percol"><a href="#percol" class="headerlink" title="percol"></a>percol</h2><p><a href="https://github.com/mooz/percol?tab=readme-ov-file#zsh-history-search">mooz/percol</a> 这个工具是典型的 Unix 风格工具，它唯一做的事情就是通过管道接收输入，提供一个模糊搜索和 UI，用户选择后再把结果返回给后面的管道继续执行。</p><p>比如我这个 <code>gt</code> 的 alias 是我日常使用非常多的一个命令，做的事情就是 check out 一个 git 分支，因为我的本地通常有很多的分支，所以使用这个命令来模糊查找，然后选中就非常方便了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">gt</span><span class="token operator">=</span><span class="token string">"git branch| percol | awk '&#123; print \<span class="token variable">$1</span> &#125;' | xargs git checkout "</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似的下面这个命令是 kill 掉某个进程，我们可以通过模糊搜索来找进程：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">pk</span><span class="token operator">=</span><span class="token string">"ps eaux | percol | awk '&#123; print \<span class="token variable">$2</span> &#125;' | xargs kill -9 "</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>如果你仔细总结，日常开发任何需要选择的地方都可以使用这个小工具来达到更高的效率，比如我工作的目录下有很多测试文件，测试其中一个文件的命令是 <code>just ts file-path</code>，我需要找到其中一个来测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./tests/ui/ <span class="token parameter variable">-name</span> <span class="token punctuation">\</span>*.rs  <span class="token operator">|</span> percol <span class="token operator">|</span> <span class="token function">xargs</span> just ts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>percol</code> 可以嵌入到很多配置里面，比如在 <code>tmux.conf</code> 里面加入这个配置，这样可以模糊查找 tmux 的 session 和 window：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">bind</span> B split-window <span class="token string">"tmux lsw | percol --initial-index <span class="token variable"><span class="token variable">$(</span>tmux lsw <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/active.$/ &#123;print NR-1&#125;'</span><span class="token variable">)</span></span> | cut -d':' -f 1 | tr -d '<span class="token entity" title="\n">\n</span>' | xargs -0 tmux select-window -t"</span><span class="token builtin class-name">bind</span> b split-window <span class="token string">"tmux ls | percol --initial-index <span class="token variable"><span class="token variable">$(</span>tmux <span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token punctuation">\</span>"/^<span class="token punctuation">$(</span>tmux display-message <span class="token parameter variable">-p</span> <span class="token string">'#&#123;session_name&#125;'</span><span class="token punctuation">)</span>:/ <span class="token punctuation">&#123;</span>print NR-1<span class="token punctuation">&#125;</span><span class="token punctuation">\</span>"<span class="token variable">)</span></span> | cut -d':' -f 1 | tr -d '<span class="token entity" title="\n">\n</span>' | xargs -0 tmux switch-client -t"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="atuin"><a href="#atuin" class="headerlink" title="atuin"></a>atuin</h2><p><a href="https://github.com/atuinsh/atuin">atuinsh</a> 是一个记录 shell 历史的小工具，不同于普通的记录 shell history 的工具，atuin 会把数据记录在一个 SQLite 的数据库文件中，这样可以支持更丰富的查询功能。</p><p>另外 atuin 也支持不同机器之间的同步，当然这需要加密通信。我目前还没使用这种场景，只是把 <code>Ctrl-R</code> 绑定到了 atuin。</p><p>atuin 也是一个 Rust 实现的工具。</p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>tmux 我之前听很多人推荐过，但是我一直没怎么尝试，直到某天我需要通过网页打开跳板机登录到服务器上，网络不稳定的情况下我经常需要重新登录，这时候我尝试了一下 tmux 发现真是太好用了。</p><p>tmux 的教程很多，比如 <a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志</a>。我的 <code>tmux.conf</code>配置很简单：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token parameter variable">-g</span> @plugin <span class="token string">'tmux-plugins/tpm'</span><span class="token builtin class-name">set</span> <span class="token parameter variable">-g</span> @plugin <span class="token string">'tmux-plugins/tmux-sensible'</span><span class="token builtin class-name">set</span> <span class="token parameter variable">-g</span> @plugin <span class="token string">'tmux-plugins/tmux-resurrect'</span><span class="token builtin class-name">set</span> <span class="token parameter variable">-g</span> @plugin <span class="token string">'tmux-plugins/tmux-continuum'</span>unbind-key C-bset-option <span class="token parameter variable">-g</span> prefix C-Spacebind-key C-Space send-prefixset-option <span class="token parameter variable">-s</span> set-titles onset-option <span class="token parameter variable">-g</span> set-titles-string <span class="token string">"#W/#T"</span>run <span class="token string">'~/.tmux/plugins/tpm/tpm'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装 <code>tmux-resurrect</code> 和 <code>tmux-continuum</code>，这样即使我重启了机器，打开 tmux 后我的 session 仍然和之前一样。</p><p>最近也有个 Rust 写的 <a href="https://github.com/zellij-org/zellij">zellij</a>，但我认为这种软件使用更老的会更方便，比如公司的远程服务器必然有 tmux，但不一定有 zellij。</p><h2 id="just"><a href="#just" class="headerlink" title="just"></a>just</h2><p><a href="https://github.com/casey/just">casey/just: 🤖 Just a command runner</a> 是我喜欢的另外一个 Rust 写的工具，我的日常工作中严重依赖这个工具，比如我的 rustc-dev 项目中配置渐渐积累了这么多的配置：<a href="https://gist.github.com/chenyukang/1483cbbf75a4bd5ae2930415329cb682">rustc-justfile</a></p><p><code>just</code> 有些像 Makefile，但使用起来又比 Makefile 的语法简单和直观，我通常是来把一些常用的命令写入 justfile，然后留下经常需要调整的参数，比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">err FILE N:        rustup toolchain <span class="token function">link</span> dev2 ./build/aarch64-apple-darwin/stage1/        <span class="token assign-left variable">RUSTC_ICE</span><span class="token operator">=</span>/tmp rustc +dev2 <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>FILE<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token parameter variable">-Z</span> treat-err-as-bug<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>N<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样我执行 <code>just err tests/ui/consts/const-eval/infinite_loop.rs 1</code> 的时候就相当于执行配置的一系列命令。</p><p>另外我也会把一些频繁需要修改的参数放到最后一个位置，比如本来我需要执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CKB_TEST_ARGS</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>SPEC<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token function">make</span> integration<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 justfile 里面配置：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test-one SPEC:        <span class="token assign-left variable">CKB_TEST_ARGS</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>SPEC<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token function">make</span> integration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>执行 <code>just test-one SPEC</code>  来测试不同的用例就会方便点。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/bootandy/dust">bootandy/dust: A more intuitive version of du in rust</a> 一个更直观的 du</li><li><a href="https://github.com/aristocratos/btop">aristocratos/btop: A monitor of resources</a> 和 htop 类似，但是 UI 更好看些</li><li><a href="https://github.com/Orange-OpenSource/hurl?tab=readme-ov-file">hurl: Hurl, run and test HTTP requests with plain text.</a> 类似 Curl，但是更方便</li></ul><hr><p>你有什么喜欢的 Shell 工具，希望也能分享给我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分享一些日常经常使用的命令行小工具，我认为这些小东西能提高我的工作效率。&lt;/p&gt;
&lt;h2 id=&quot;percol&quot;&gt;&lt;a href=&quot;#percol&quot; class=&quot;headerlink&quot; title=&quot;percol&quot;&gt;&lt;/a&gt;percol&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="工具" scheme="http://catcoding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>中外程序员差异</title>
    <link href="http://catcoding.me/p/diff/"/>
    <id>http://catcoding.me/p/diff/</id>
    <published>2024-02-24T21:58:03.000Z</published>
    <updated>2025-01-03T15:03:41.324Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到这个<a href="https://twitter.com/Piglei/status/1761051133135687853">推特</a>，我理解作者的心情非常复杂，因为我前三年写过一段时间技术类的英文文章，也发现英文技术社区还有那种认真讨论的氛围，而在中文技术圈里，这种氛围已经几乎绝迹。</p><p>这几年因为我在外企和开源上的工作经历，接触了很多来自各个国家的程序员，今天想写写我发现的一些国内外程序员间的差异，我相信经常混迹开源社区的人会有些类似感受。</p><h2 id="讲究细节"><a href="#讲究细节" class="headerlink" title="讲究细节"></a>讲究细节</h2><p>这点是我感受最深的，我自认为已经算是一个对细节比较在乎的人了，但我接触到一些国外的程序员，他们对细节的把握让人佩服。</p><p>最近的一个例子是我在写这篇<a href="https://github.com/nervosnetwork/docs.nervos.org/pull/206">英文文档</a> 的时候遇到的，其中的 Reviewer jordanmack 对我文档里面的所有内容逐字逐句都过了一遍，发现不懂的地方一定要弄明白。这里面有的是中英文表达差异造成的理解偏差，也有他对这个功能的逻辑上的质疑，甚至可以细节到我在文中给出的 json 例子里的数字范围和自洽性。我们在 Github 上来回讨论了很久，然后继续在 Discord 上讨论，而在这个过程中我也确实发现了些代码上需要调整的地方，最后他给我的文章几乎全部<a href="https://github.com/chenyukang/docs.nervos.org/pull/3">润色了一遍</a>。</p><p>jordanmack 不算是全职的程序员，但他也有一些程序员背景。在我做开源的经历中，PR 中被挑细节的时候太多了，一度我已经不再认为自己是个对细节很把握的人了。后来我总结了一下，有时候我是在赶时间，觉得某些 corner case 就暂且跳过吧，但大多会在代码 Review 中被提出来的。</p><p>然后经历多了也就看淡了，不光是我，任何人的 PR 都可能引发大量的讨论，比如到底是使用 <a href="https://github.com/rust-lang/rust/pull/75065">µs 还是 us</a>。也许在很多人看来这是个小问题，但却引起了大量的讨论，细看其中还有些引经据典和长篇大论。随便挑一个 RFC，也都可以看到<a href="https://github.com/rust-lang/rfcs/pull/3573">大量的讨论</a>。</p><p>所以我的感受是，国外程序员中在意细节的比例更大。那么问题是，他们为什么能看这么细？固然其中一个很重要的原因是他们确实有时间，才能静下心来看和写。</p><p>在国内公司我也碰到过对细节的把握，但很多用在了我最讨厌的形式主义上。在微软的时候，我见过各种不够漂亮的 PPT，有的时候翻来一段 onenote 就开始讲，因为都没人关注这些。</p><h2 id="文字表达"><a href="#文字表达" class="headerlink" title="文字表达"></a>文字表达</h2><p>文字表达能力是开源社区里一个非常重要的，因为但凡一个大的改动都需要和其他人广泛讨论和协作。</p><p>不少国外的程序员有文字表达的习惯，就是即使看很小的一点问题也会通过文字表达出来。这是很多国内程序员所没有的习惯，因为我们大多比较含蓄，认为多做比说强，说多容易错，说多容易暴露自己。</p><p>可能和教育和网络环境也有一定关系，如果不是刻意维持文字表达的习惯，很多人高中毕业后就没有写过几篇长文，对很多事情也没有自己的看法。</p><p>另外他们习惯使用 Email 来沟通，但中国开发人员大多习惯使用 IM 沟通。这两者还是有区别的，IM 沟通会让人不自觉地回复得更快，有的模糊想法随口就就表达了。而 Email 沟通更容易让人把事情写清楚，也更容易写得更长和有条理。</p><p>这种细微的差异长久了之后就可看出中英文技术社区的巨大差别。另外，中文网络的环境中戾气更重一些，人们对自我推销很反感，容易揣测你的意图。</p><h2 id="个人目标"><a href="#个人目标" class="headerlink" title="个人目标"></a>个人目标</h2><p>很多欧美大公司里有不少只做 Individual Contributor 而不做管理的人，在这些公司里，管理和技术是两条并行线，薪资和职级挂钩，也就是说纯 IC 的岗位可能收入比管理岗位更高，因为职级更高。</p><p>管理人员和技术人员大多是上下级关系，但下属对管理人员没有绝对的单向服从关系。当然大多数情况下，管理更容易升职上去，因为纯做技术岗位不容易通过杆杠来放大自己，管理就是一种很有效的杠杆。但这种纯粹的并行晋级路线是非常重要的，可以让技术人员有更多的选择权，甚至如果对自己的管理者不满意直接给差评和换组就是了。</p><p>所以在国外程序员中，如果一个人做了多年开发，很可能就是他确实喜欢做技术和更擅长做技术。而中国职场中，管理和技术岗的差别太大了，或者说绝大部分人到了一定年龄，如果你不混个管理的 title，好像就已经落后了，甚至没有职场安全感。</p><p>另外有些人是喜欢混到管理岗之后，纯粹为了获取更高的薪水，或者是为了把不喜欢做的事情推给别人。当然，这其中也有很大一部分中国文化里的官本位的影响，还有一部分原因是太看中钱了。</p><p>我接触过一些年龄在 40 岁多的国外程序员，他们还是对技术有很大热情。如果喜欢做技术，而又能通过做技术挣钱，这没有什么失败的，这与年龄没关系，反而这是一种很好的度过自己短暂一生的方式。</p><p>只是在国内要做到这点并不容易，很多岗位做的事情本来就不够有深度，时间更久也无法积累起来足够的壁垒，业务上的开发年轻人上手很快，而需要深入做下去的岗位不够，所以年龄大了就容易失业。</p><h2 id="业余时间"><a href="#业余时间" class="headerlink" title="业余时间"></a>业余时间</h2><p>国外程序员的业余时间真是非常多，如果你经常混 Github 就会发现，每当到了 12 月份就很多出来很多 aoc 字样的项目，这是他们在做<a href="https://adventofcode.com/">Advent of Code 2023</a>。</p><p>Advent of Code 就是整个 12 月份每天出一道题目，都是些编程谜题，有点类似 leetcode，但题目描述更长。你可以用任何语言来实现，反正要的结果就是答案。可以发现这些 aoc 项目基本都是欧美的程序员在做，因为他们大多在 12 月份有几乎一个月的假期，我在微软工作的时候，很多人也是 12 月份开始基本不见人影。</p><p>创造性的前提是不用为生存问题发愁，欧洲那些搞哲学、做研究的，大多都是家底丰厚，闲得多了自然就能搞事。如果有大把的业余时间，用来发展工作外的开源项目可就太好了。其实很多著名的开源项目只有吃饱饭没事做的时候才能搞出来，我之前在知乎问题 <a href="https://www.zhihu.com/question/502884696/answer/2296787480">为什么中国程序员不如外国程序员有创造性</a> 中写到：</p><blockquote><p>荷兰人<a href="https://www.zhihu.com/search?q=%E8%9F%92%E8%9B%87&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2296787480%7D">蟒蛇</a>大叔想着哇塞圣诞假期这么长，找点事做，结果出了 Python。<br>日本人松本行弘，经济危机时闲得发慌，搞出了 Ruby。<br>芬兰人<a href="https://www.zhihu.com/search?q=%E6%9D%8E%E7%BA%B3%E6%96%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2296787480%7D">李纳斯</a>，大三不用为了找工作背八股和考研，冬眠似地宅家里写代码，搞出了 Linux。</p></blockquote><p>在 Rust 社区中的贡献人员里，除了美国，第二多的是欧洲，他们也不是为了挣钱，完全就是感兴趣做做而已，我看到好几个大学年轻人做的事情已经非常深入了，当然其中花费的时间也是很多，他们几乎一直在线。</p><hr><p>这些总结比较粗略，另外也可能有幸存者偏差因素。这个话题很大，深入下去探讨会包含很多方面。</p><p>我也不是在抱怨，年龄大了之后发现多看看历史相关的书还挺好，让自己更容易理解所处的环境为什么是这样的，比如《中国国民性演变史》这本书值得推荐。另外《美国种族简史》这本书也值得一看，多了解了解其他人的特点和长处，努力让自己不要局限于国界，另外做到程序员中的 80% 以上水平，保持英文能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看到这个&lt;a href=&quot;https://twitter.com/Piglei/status/1761051133135687853&quot;&gt;推特&lt;/a&gt;，我理解作者的心情非常复杂，因为我前三年写过一段时间技术类的英文文章，也发现英文技术社区还有那种认真讨论的氛围，而在中文技
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="程序员" scheme="http://catcoding.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>Copilot，最好的编程助手</title>
    <link href="http://catcoding.me/p/copilot-for-programming/"/>
    <id>http://catcoding.me/p/copilot-for-programming/</id>
    <published>2024-01-21T14:43:34.000Z</published>
    <updated>2025-01-03T15:03:41.324Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午我解决一个小问题的时候，在 Copilot 的帮助下快速给出了修复，这个工具似乎有些超过期望了，所以突然想写篇文章分享这个目前我最愿意付费的 AI 工具。</p><p><sub>Copilot 价格是每个月 10 美金，但我至今还没付费过，感谢微软支持开源，从测试阶段就邀请我试用，到现在还一直在免费使用。Github 应该有些政策，比如如果你持续给一些 star 数比较多的开源项目做贡献，就可以免费使用 Copilot</sub>：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240120212918.png" alt=""></p><p>我会给出日常碰到过的一些具体的实际案例截图，以方便你更直观地感受到这个工具准确度。</p><h3 id="Manual-类查询"><a href="#Manual-类查询" class="headerlink" title="Manual 类查询"></a>Manual 类查询</h3><p>我们在编程过程中经常会碰到一些命令的参数记不太清楚，这种问题很适合问 Copilot。这比自己去 Google 的感受好很多，因为他几乎能完全理解用户说的自然语言，而且给出的答案简介明了：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240120224637.png" alt=""><br>比 Google 更好的地方在于上下文的交谈，比如我继续基于上面的问题说我的想法，他就能继续给出反馈，比如我说大概有个类似 <code>--exact</code> 的参数，Copilot 会继续给出使用案例。</p><p>Copilot 非常善于回答对这种 manual 类的问题，因为这是有标准答案的，并且我作为用户对这些是有判断的，只是我们细节上记不清楚了。</p><p>还有一次我发现跑测试的时候挂了，分析下来是这个命令行失败了（但既然 CI 是过的，所以必然只是在 MacOs 下失败了)：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">diff</span> <span class="token parameter variable">-u</span> --strip-trailing-cr <span class="token parameter variable">-r</span> <span class="token parameter variable">-q</span> A_file.txt A_file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是在 diff 同一个文件，所以必然应该返回 0，但在 MacOS 下这个命令会报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">✗ <span class="token function">diff</span> <span class="token parameter variable">-u</span> --strip-trailing-cr  <span class="token parameter variable">-r</span> <span class="token parameter variable">-q</span> ./x.py ./x.pyerror: conflicting output <span class="token function">format</span> options.blah blah 一大堆错误 blah blah 一大堆错误 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我知道这里面肯定是有参数冲突了，但我具体不知道是哪两个冲突了，所以这时候我问 Copilot：<br><img src="http://catcoding.me/images/ob_pasted-image-20240120230403.png" alt=""></p><p>可以看到这个解释非常清楚，并且帮我找到了问题的根源，所以我就能很快地发 PR 修复这个问题，并且我 PR 里的描述基本都是从 Copilot 里来的：<br><a href="https://github.com/rust-lang/rust/pull/109036">Fix diff option conflict in UI test #109036</a></p><h2 id="给出示例代码"><a href="#给出示例代码" class="headerlink" title="给出示例代码"></a>给出示例代码</h2><p>我们在写代码的时候，经常会出现固定的 Pattern，不同的语言对固定的 Pattern 有一些相对固定的代码样式。我很喜欢找 Example 类的代码，然后在这个基础上再思考或者修改：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240120230905.png" alt=""></p><p>对这种情况我们需要给 Copilot 足够的信息，他给出的 Rust 代码通常是可直接编译通过的，但当然这些示例代码需要进行仔细的修改，但这也比我自己翻 Doc 会快很多。</p><h2 id="辅助排查问题"><a href="#辅助排查问题" class="headerlink" title="辅助排查问题"></a>辅助排查问题</h2><p>VSCode 上的 Copliot 更新很快，肉眼可见地体验越来越好，现在我们可以选择一段代码，然后就选择的代码来进行提问。</p><p>有时候我会选中一个函数，然后问这段函数能不能重构得更简单一些，或者我们能不能用其他方式实现。</p><p>今天让我有欲望写下这篇分享的文章是因为这个问题：<br><a href="https://github.com/nervosnetwork/ckb/issues/4309">Missing request extension: Extension of type</a></p><p>这是一个有非常明确的报错的繁琐 issue，应该就是 Server 端限制了 HTTP 的请求类型，客户端通过 curl 发 GET 请求的时候报错了，只是这个报错信息看起来很不友好，而且和老版本行为不同。所以我就选中代码中对应的函数，然后问这里为什么会有这个错：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240120232057.png" alt=""><br>其实我对 Copilot 解决这个问题不怎么报有信心，只是好奇先试了试，没想到 Copilot 真的能理解我的代码，并且指出了问题所在。注意看它加的注释就是我代码中缺少的逻辑 (之前的代码只是在 <code>enable_websocket</code> 的条件下才加载了 stream_config 这个 Extension)：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240120232121.png" alt=""></p><p>加上它建议的代码之后，那个错误信息没了，但是现在发 GET 请求是另外一个问题：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">Connection header did not include &#39;upgrade&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这看起来是服务端期望客户使用 Websocket，但是客户端只是在通过 Curl 发一个 GET 请求，并没有按照这个期望来。所以我继续问 Copilot：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240120232647.png" alt=""></p><p>他给的回复里的代码并没有直接修复问题，但里面的<br><code>you can separate the handlers for POST and GET requests</code><br>提示了我应该尝试对 HTTP endpoint 和 Websocket endpoint 的 handler 进行分开，所以我一下想到了修复方案：</p><p><img src="http://catcoding.me/images/ob_pasted-image-20240120232901.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如今使用 Copilot 已经成为我的一个编程习惯，就如同之前我严重依赖 Google 一样，但这个工具明显比搜索引擎高级了一个维度，当然现在我还是依赖搜索，但使用比率明显下降了不少，搜索引擎更像是成了一个书签的角色了。</p><p>我之前认为 Copliot 这种工具甚至是这辈程序员所不能体验到的东西，在我第一次尝试到 ChatGPT 居然可以理解一个函数，并且找出函数中的问题时，就感觉新的编程时代来临了。</p><p>前段时间 Redis 的创始人在文章 <a href="http://antirez.com/news/140">LLMs and Programming in the first days of 2024</a> 中写到：</p><blockquote><p>随着时间的推移，我们见证了框架、编程语言、各种库的大量涌现。这种复杂性通常是不必要的，甚至无法自圆其说，但事实就是如此。在这样的情况下，一个无所不知的“白痴”成了宝贵的助手。</p></blockquote><blockquote><p>这是一个事实：现今的编程大多是在微调同样的内容，只是形式略有变化。这种工作并不需要太高的推理能力。</p></blockquote><p>Copilot 已经可以在一些具体的编码问题上给到我们很多帮助，甚至你把这个当作一个包含万物的文档查询工具都非常有效。</p><p>当然没有银弹，Copilot 并不能解决编程中的所有问题，比如理解大规模的程序，通过深入分析去找出 bug，或者做设计问题中的各种折中和取舍，这些都是不能取代人类的，这也是我认为编程中的乐趣还没有完全消失。</p><p>我会把繁琐和细节的问题抛给 Copilot，然后更开心地做重要和有趣的部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天下午我解决一个小问题的时候，在 Copilot 的帮助下快速给出了修复，这个工具似乎有些超过期望了，所以突然想写篇文章分享这个目前我最愿意付费的 AI 工具。&lt;/p&gt;
&lt;p&gt;&lt;sub&gt;Copilot 价格是每个月 10 美金，但我至今还没付费过，感谢微软支持开源，从测试
      
    
    </summary>
    
    
      <category term="工具" scheme="http://catcoding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="AI" scheme="http://catcoding.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>我的 2023</title>
    <link href="http://catcoding.me/p/2023-summary/"/>
    <id>http://catcoding.me/p/2023-summary/</id>
    <published>2023-12-30T22:36:00.000Z</published>
    <updated>2025-01-03T15:03:41.320Z</updated>
    
    <content type="html"><![CDATA[<p>2023 年很快就要结束了，赶紧抓住这个冲动总结一下。今年对我来说有几个大的转变，从几个方面谈起：</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>生活上最大的变化是我又有了一个儿子，所以我现在是三个孩子的父亲了。</p><p>同龄人中几乎没有生三胎的，有些人问我为什么这么想不开，自己找罪受。我只能说是命运的馈赠吧，我从小生活在一个大家庭里，加上我和老婆都算是喜欢小孩的人，三胎顺其自然地接受了，这个孩子也促使了我们更早地离开了苏州。</p><p>孩子 8 月底出生，前两个月请到了一个靠谱的月嫂，所以生活方面还不算痛苦。最近女儿生病才开始感受到三个孩子带来的巨大挑战，看来我们是低估了其难度。</p><p>我的大女儿开始在深圳上一年级，没想到现在的一年级都这么卷，基本上每天都有语数外作业，一个月一次的考试。我们力不从心已经放弃了一些家庭作业，比如数学之类的无聊作业我们就不怎么做，我认为每个小孩的大脑发育有自己的节奏，小学数学这种东西到了年龄自己会懂，小学阶段重要的是培养学习习惯和兴趣，强压给孩子只会让她产生对数学的恐惧。陪小孩做作业真是一件极其需要耐心的事情，我现在还在努力尝试从孩子的角度考虑问题。</p><p>三个孩子带来的另外一件事情就是冲突，大女儿心情好的时候会带着小的玩，心情不好的时候就会和妹妹争东西。如何在这些孩子中平衡，在吵闹中克服情绪去解决问题，这些都是在磨炼心性。</p><p>纪伯伦在《论孩子》中写到：<em>你的孩子，其实不是你的孩子，他们藉助你来到这个世界，却非因你而来，他们属于你做梦也无法达到的明天。</em></p><p>有孩子之前我觉得养育孩子重要的是把他们当朋友，但真的等孩子三岁后有了更多自主意识之后，作为父母就会面临更多困难，什么时候该管教孩子，什么时候该放任他们。有时候我也忍不住发火，而后又觉得自己是个失败的父亲，心里多默念『还只是个孩子』几遍，如何做一个好父亲这必然是我今后一直需要学习的。</p><p>生活中的另一个变化是今年身体状态更好了，可能是因为深圳的暖和天气更适合我，加上在家办公出去本职工作外，没感受到什么职场上的琐事和压力，另外在家里办公相关的设备更适合自己，所以整体身体上没有大的问题。</p><p>但从心理方面，我能感受到和以前的更大差别，主要是彻底接受了中年这个年龄阶段。这是一点点积累起来的，那些曾经我看着长大的晚辈们都到了谈婚论嫁的年龄，或者偶然想起一些人和事心里一算已经是十多二十年前了，或是我发现自己某些方面更像印象中的父亲了。</p><p>我的生活看起来极其单调，不是坐在屏幕前写程序就是在带娃和遛娃，和梦想与激情这些词汇毫不沾边。但我满足并感恩目前的状态，我几乎没有焦虑，物欲低所以也不觉得缺钱，做着自己喜欢的工作和事情，有足够多的时间陪家人，这就很好了。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>2023 我全职远程做开源项目，很幸运在 Cryptape 这大半年里工作感受非常好，这大概是我工作这么多年来写程序最开心的一段时间。因为远程办公，今年我的人际圈子似乎更小了，日常微信沟通的都是些认识了 10 来年的朋友。</p><p>我的工作主要是做区块链 Layer 1 相关的事情，入职以后做的事情是交易池这块，后来又涉及到一些 RPC 相关的工作，还有些 Infra 类的工作。区块链这行涉及范围太多了，有网络、性能、分布式、密码学等各种，所以对于纯喜欢技术的人来说，这里面挑战太多，比 CRUD 之类的项目好玩得多。</p><p>我做的主要工作都是集中在 <a href="https://github.com/nervosnetwork/ckb">nervosnetwork/ckb</a>这个项目，这里可以看到我做的一些 <a href="https://github.com/nervosnetwork/ckb/pulls?q=is:pr+author:chenyukang+is:closed">Pull requests</a>。</p><p>另外现在日常工作中纯用 Rust，编程体验和之前完全不是一个层次，除了如何实现功能，我们也会在乎项目的长期可维护性和优雅程度。区块链 Layer 1 也算是一个复杂度高和对准确度要求很高的项目，Rust 是很适合的。我虽然这两年一直在写 Rust 代码和做开源，但之前还真没有用 Rust 在实际工作中，特别是异步这块我之前甚少涉及。同事中有对 Rust 理解很深入的人，沟通也很顺畅，所以我特别喜欢这个工作氛围。</p><p>在工作过程中我看了更多 Bitcoin 相关的代码，越发觉得这真是一个伟大的发明，这像是个黑客用技术发起的社会性实验，在 beta 阶段就能如此深刻地影响了世界。关于 Bitcoin 推荐看这一系列文章 <a href="https://www.btcstudy.org/search/?w=%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E8%BF%87%E5%8E%BB">比特币的过去、现在和未来</a>。</p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p><img src="http://catcoding.me/images/ob_pasted-image-20231229200920.png" alt=""></p><p>今年继续在为 Rust compiler 做贡献，能回想到的一些事情是：</p><ul><li>参与了一个播客的录制 <a href="https://rusttalk.github.io/podcast/007/">于康的 Rust 贡献之旅 – RustTalk</a>。</li><li>参加了第三界 Rust Conf，做了一个主题为  <a href="https://www.bilibili.com/video/BV11X4y1q7Lm/?spm_id_from=333.337.search-card.all.click">Learning by Contributing to Rust Compiler</a> 的演讲。</li><li>成功申请 Rust Foundation 2023 Follows 的资助，算是一个开源副业。</li><li>今年大概完成 70 来个 PR，大多数时候还是做一些小改进，很多时间花在了这个 <a href="https://github.com/rust-lang/rust/pull/117867">New attribute macros format for diagnostic structs</a> 上。</li><li>机缘巧合和 compiler team 的 davidtwco 在深圳吃了个饭面基了一次，线上和更多社区成员沟通更多了，同时深感英语口语需要进一步提高。</li></ul><p>因为在 Cryptape 的工作涉及到其他一些 Rust 项目，所以参与到了一些，比如我们在改造交易池的过程中用到了 <code>multi_index_map</code> 这个数据结构，顺带完善了一些不足 <a href="https://github.com/lun3x/multi_index_map/pull/23">Non-unique index support, capacity operations, performance improvement</a> 。</p><p>作为技术人，能全职使用自己喜欢的编程语言工作是一个很大的幸运，希望能继续在 Rust 开源这条路上走得更远。</p><h2 id="阅读和写作"><a href="#阅读和写作" class="headerlink" title="阅读和写作"></a>阅读和写作</h2><p>2023 看书的时间也少了很多，回顾了一下很多书没有看完，但这些书看完后值得分享：</p><ul><li>《硅谷钢铁侠：埃隆·马斯克的冒险人生》，这就是那些改变世界的人吧</li><li>《失明症漫记》，似乎是重新回顾一遍疫情的场景<ul><li>如果我们亵渎生活的尊严，我们也就扭曲了理智；而人的尊严每天都会受到我们世界中权势者的侮辱；普遍的谎言已经替代了多元的真理；人一旦失去来自其他成员的尊重，他也就不再尊重自己。</li></ul></li><li>《作个闲人：苏东坡的治愈主义》，这书我估计我年轻的时候看不进去，现在看就觉得很好：<ul><li>人生如逆旅，我亦是行人</li><li>可以寓意于物，而不可以留意于物</li><li>一张琴，一壶酒，一溪云</li></ul></li><li>《走出戈壁》优秀的人在逆境中也能成长起来。</li><li>《了不起的盖茨比》也许是因为我先看了电影，所以再看书就满脑子小李子那样子，也许有的作品就不应该看电影。</li><li>《被讨厌的勇气》，一切烦恼都来自人际关系，让干涉你生活的人去见鬼，解决了一些我的日常困惑。</li><li>《哲学家们都干了些什么》，你思考过的很多问题，前人必然已经思考过了。</li><li>《夜晚的潜水艇》，这就是文笔好。我喜欢里面的《裁云记》<ul><li>值得人沉迷一生的事太多了。像你说的，每个洞穴都充满诱惑，难以取舍。我年轻时也在分岔处犹豫过。后来我才明白，不是所有洞口都陈列在那里，任人选择；有的埋伏在暗处：我一脚踏空，就一头栽了下来，到现在也没有落到底。</li></ul></li><li>《美国种族简史》</li><li>《高山下的花环》</li><li>《凤凰项目，一个 IT 运维的传奇故事》</li></ul><p>同样在写作上的时间就更少了，总结下来居然是 13 篇博客，勉强达到月更的节奏。</p><p>写作这件事情似乎停下来之后就容易长时间停顿。带孩子太耗精力算是一个借口，但我其实很是可以把一些日常的琐碎时间利用好来做这件事情的，只是确实犯懒了。</p><p>希望借这次写年终总结的劲头，把写作这件事情捡起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2023 年很快就要结束了，赶紧抓住这个冲动总结一下。今年对我来说有几个大的转变，从几个方面谈起：&lt;/p&gt;
&lt;h2 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h2&gt;&lt;p&gt;生活上最大的变化是我又有了
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
</feed>
