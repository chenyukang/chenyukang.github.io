<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CatCoding</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://catcoding.me/"/>
  <updated>2024-11-06T04:08:02.379Z</updated>
  <id>http://catcoding.me/</id>
  
  <author>
    <name>yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CKB RBF 设计和实现</title>
    <link href="http://catcoding.me/p/ckb-rbf/"/>
    <id>http://catcoding.me/p/ckb-rbf/</id>
    <published>2024-11-06T11:55:13.000Z</published>
    <updated>2024-11-06T04:08:02.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Replace-by-fee"><a href="#Replace-by-fee" class="headerlink" title="Replace by fee"></a>Replace by fee</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果一个交易成功发送到交易池，但可能出现因为费用较低而一直得不到处理。之前 CKB 没有其他措施来处理这种情况。</p><p>例如 <a href="https://www.notion.so/Dotbit-4-45e129cb4c434bd2902569aff67c4383?pvs=21">Dotbit 4 位域名注册拥堵</a> 这个事故发生过程中，<code>CKB</code> 的应用方无法使用任何方式来尽快让自己的交易被打包，这就是引入 <code>Replace-by-fee（RBF)</code> 的原因，我们需要一个机制来提高已经在交易池里交易的费用，替换掉旧的交易，让新的交易尽快被打包。</p><p>在新的 <code>multi_index_map</code> 重构后，交易在 <code>pending</code> 阶段也会按照交易的 <code>score</code> 来优先处理 (通常费用高的交易 <code>score</code> 也会高)，这会避免高费用的交易被阻塞住，所以理论上述需要手动提高费用的情况会减少，但我们还是需要 RBF 来手动提高交易的费用，应对意外的情况。</p><p>另外，RBF 可能将多个老的交易替换出去，因此也是将两个或多个支付合并为一的方法，例如下图所示，如果满足条件 <code>tx-a</code>, <code>tx-b</code>, <code>tx-c</code>, <code>tx-d</code> 都会被 <code>tx-e</code> 这个交易替换掉：</p><p><img src="/images/ob_pasted-image-20241031103004.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">bips/bip-0125.mediawiki</a></li><li><a href="https://bitcoincore.org/en/faq/optin_rbf/">Bitcoin Core :: Opt-in RBF FAQ</a></li><li><a href="https://www.notion.so/RBF-in-CKB-draft-2023-01-05-79736edd0c824fae98f1e7ee42d4e436?pvs=21">RBF in CKB(draft 2023.01.05)</a></li><li><a href="https://bitcoinops.org/en/newsletters/2022/03/16/#ideas-for-improving-rbf-policy">Bitcoin Optech Newsletter #191 | Bitcoin Optech</a></li></ul><p>中本聪最初的 Bitcoin 版本中就有引入一个 <code>nSequence</code> 的字段，如果相同交易的 <code>nSequence</code> 更高，就可以<a href="https://github.com/trottier/original-bitcoin/blob/master/src/main.cpp#L434">替换</a>之前老的交易，这个实现的问题是没有支付额外的 fee，miner 没用动力去替换交易，另外因为没有 rate-limiting 从而导致可能被滥用，所以 Bitcoin 在 0.3.12 版本中禁止了这个功能。后来 Bitcoin 重新引入了新的 RBF 改进，主要包括需要支付额外的费用来替换老交易，另外为 RBF 指定了更多的限制条件。</p><p>在 CKB 上我们之前做过两次 RBF 的相关调研，因为之前 <code>Pending</code> 是一个 FIFO 的数据结构，所以处理替换不是很方便，在 RBF in CKB(draft 2023.01.05) 尝试引入一个 <code>high priority queue</code> 来实现 <code>inject-replace</code>。交易池改造之后，整个交易池可当作一个优先队列，所以应对 <code>RBF</code> 会简单很多。</p><h2 id="新增-RBF-的流程"><a href="#新增-RBF-的流程" class="headerlink" title="新增 RBF 的流程"></a>新增 <code>RBF</code> 的流程</h2><p><img src="/images/ob_rbf2.png" alt=""></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul><li><code>pre-check</code> 为 entry 加入到 tx-pool 之前必须要做的检查，之前只是做双花的检查，新增 RBF 后如果双花检查失败（这里意味着冲突），继续做 RBF 的相关检查，如果 RBF 检查成功则也返回成功，否则直接返回错误。这里默认直接做 resolve_tx 的检查，如果成功则走正常流程，目的是不给正常流程增加额外成本。所以这就是<a href="https://github.com/chenyukang/ckb/blob/44331ec5b9fcda217f33c471057fa479bd36a89f/tx-pool/src/process.rs#L216-L255"><code>pre-check</code> 修改后的主要逻辑</a> 。</li></ul><p>RBF 的检查规则参考 Bitcoin 的六条，<a href="https://github.com/chenyukang/ckb/blob/2be67e79acec94369a96f786d3041e6cb00cf1f2/tx-pool/src/pool.rs#L483-L565"><strong>check_rbf 初步实现</strong></a></p><pre class="line-numbers language-none"><code class="language-none">实现细节：（Bitcoin Core 0.12.0）~~1. 交易需要声明为可替换交易~~ 2. 新替换交易没有包含新的、未确认的 inputs3. 新替换交易的交易费用比待替换交易费用高4. 新替换交易费用必须比节点的 min relay fee 高5. 待替换交易的子交易数量不可超过 100 条（即使用了该交易的任意 outputs，该交易替换后它们将被从内存池中移出）6. 因为 ckb 是做了两步提交，我们新增规则：被替换的交易只能是 Pending 或者 Gap 阶段的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们不给交易加新的字段表示是否可以被替换，而是通过节点是否配置了 <code>min_rbf_rate</code> 来决定是否能做替换，因此 <code>规则 1</code> 不做对应考虑。</p><h3 id="替换和提交"><a href="#替换和提交" class="headerlink" title="替换和提交"></a>替换和提交</h3><p>修改 <code>tx-pool</code> 的 <code>submit_entry</code> 函数，传入 <code>conflicts</code>，在新增 entry 之前把所有冲突的交易删除 放入 <code>rejected</code> 记录，另外确保所有检查完成了之后才做删除和写操作：<a href="https://github.com/chenyukang/ckb/blob/2be67e79acec94369a96f786d3041e6cb00cf1f2/tx-pool/src/process.rs#L99-L154">submit_entry 逻辑</a>。</p><p>最终实现在这个 PR 里<a href="https://github.com/nervosnetwork/ckb/pull/4079">Tx pool Replace-by-fee</a>。</p><h3 id="并发的-Bug"><a href="#并发的-Bug" class="headerlink" title="并发的 Bug"></a>并发的 Bug</h3><p>在最初的实现版本中，隐藏了一个并发的 bug 后来在测试发现了。RBF 的检查如果放在 <code>pre-check</code> 中，如果多个线程中的多个交易发生了冲突，input resolve 可能会出问题。<a href="https://github.com/nervosnetwork/ckb/pull/4258">Fix concurrency issue for RBF</a> 这个 PR 修复了这个问题，把 RBF 的冲突检查移动了 submit entry 之前，因为在这个函数里面会持有 write 锁。</p><h3 id="cycling-attack"><a href="#cycling-attack" class="headerlink" title="cycling attack"></a>cycling attack</h3><p>后来我们在做闪电网络的时候又发现 RBF 可能会引入 cycling attack 的风险，这个攻击通过构造巧妙的新交易，让支付路径上的中间节点的 commitment tx 不能按时上链，<a href="https://blog.satsbridge.com/lightning-replacement-cycling-attack-explained-45636e41bc6f">Lightning Replacement Cycling Attack Explained</a>这篇文章有更详细的描述。</p><p>所以我们后来又做了这么一个改进：<a href="https://github.com/nervosnetwork/ckb/pull/4561">Recover possible transaction in conflicted cache when RBF</a> 来规避这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Replace-by-fee&quot;&gt;&lt;a href=&quot;#Replace-by-fee&quot; class=&quot;headerlink&quot; title=&quot;Replace by fee&quot;&gt;&lt;/a&gt;Replace by fee&lt;/h2&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot;
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
  </entry>
  
  <entry>
    <title>CKB 交易池重构</title>
    <link href="http://catcoding.me/p/ckb-txpool-refactor/"/>
    <id>http://catcoding.me/p/ckb-txpool-refactor/</id>
    <published>2024-11-06T11:39:21.000Z</published>
    <updated>2024-11-06T04:08:02.379Z</updated>
    
    <content type="html"><![CDATA[<p> 在 11.9 号清迈的 <a href="https://share.foresightnews.pro/article/detail/70811">CKCON</a> 会议上我会做一个关于 CKB 交易池的演讲，这是我准备的 slides <a href="https://ckb-tx-pool.vercel.app/1">Key Upgrades of the CKB Core</a> 。所以这段时间在整理之前做项目的时候写的一些文档，顺便分享到自己的博客上。既然我们整个项目的源码都是公开的，所以这些文档其实也是可以分享的。</p><p>第一次听说 CKB 的读者可以参考这个文档以了解什么是 CKB 以及如何工作的：<a href="https://docs.nervos.org/docs/getting-started/how-ckb-works">How CKB Works | Nervos CKB</a>。</p><p>我加入 Cryptape 之后一年内做的主要工作，涉及到交易池重构、Replace-by-fee 功能、以及 new-verify。这是第一篇关于交易池重构的文章。</p><h2 id="什么是交易池"><a href="#什么是交易池" class="headerlink" title="什么是交易池"></a>什么是交易池</h2><p>在 bitcoin 中交易池叫作 mempool，比如 <a href="https://mempool.space/">mempool - Bitcoin Explorer</a> 这个网站就很好地展示了其当前的状态。</p><p>交易池是 bitcoin 中的一个重要的组件，但感觉专门关于这块的资料很少，只能通过 PR 和邮件列表上的讨论看到一些文档。但交易池非常重要，因为一个交易要上链必须会通过交易池，而其中的交易打包算法涉及到如何选择合适的交易，这里面有很多因素需要考虑，所以在实现上也是比较复杂的。</p><p>当一个交易被提交到一个节点时，或者一个节点从网络中同步到交易时，这个交易首先需要被加入到交易池中，交易池里会根据一定的算法去选择下一个需要被打包的交易，另外交易池作为一个缓存，我们需要为其设置一个最大的 size。所以交易池里面最重要的两个操作就是 packaging 和 evicting。</p><p>交易池里面的交易存在父子关系，打包的时候需要从交易链的纬度去考虑，后面的 Replace by fee 这些功能也需要关注整个交易的所有子交易。</p><p><img src="/images/ob_transaction-pool.jpg" alt=""></p><h2 id="交易池重构"><a href="#交易池重构" class="headerlink" title="交易池重构"></a>交易池重构</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>根据 RFC <a href="https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0020-ckb-consensus-protocol/0020-ckb-consensus-protocol.md#two-step-transaction-confirmation">consensus-protocol</a> 的设计，CKB 里的 tx-pool 采用了两段提交的方式：</p><p><img src="/images/ob_pasted-image-20241031100804.png" alt=""></p><p>相应地在交易池最初实现的时候， <code>ckb</code> 的代码实现中 <a href="https://github.com/nervosnetwork/ckb/blob/rc/v0.111.x/tx-pool/src/pool.rs">tx-pool</a> 同样采用了三个独立的队列，具体定义如下：</p><ul><li><code>pending</code> 交易刚加入到交易池时候的状态，我们每次只能处理不多于 <code>MAX_BLOCK_PROPOSALS_LIMIT</code> 个交易，交易需要先进入 <code>gap</code> 备选，具体代码逻辑在 <a href="https://github.com/nervosnetwork/ckb/blob/3de5a20ce60619927f41f81d9584cab9d39d1275/tx-pool/src/block_assembler/mod.rs#L345C11-L345C11">update_proposals</a> 。</li><li><code>gap</code> 已经被 proposed 了，但是还不能被打包，需要等一个块后才能被打包，所以这只是内部中间过渡状态。</li><li><code>proposed</code> 交易可以加入到 <code>block_template.transactions</code> , 最终打包到 block 里，具体代码逻辑在 <a href="https://github.com/nervosnetwork/ckb/blob/e75ab3faf0f7b1d182be2f1daa30f300cfefabc8/tx-pool/src/block_assembler/mod.rs#L195">block_assembler</a>。</li></ul><p>实现中 <code>pending</code> 和 <code>gap</code> 同样都是使用了 <code>PendingQueue(LinkedHashMap)</code>，而 <code>proposed</code> 采用了 <code>SortedTxMap(HashMap + BTreeSet)</code> ：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">TxPool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> config<span class="token punctuation">:</span> <span class="token class-name">TxPoolConfig</span><span class="token punctuation">,</span>    <span class="token comment">/// The short id that has not been proposed</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> pending<span class="token punctuation">:</span> <span class="token class-name">PendingQueue</span><span class="token punctuation">,</span>    <span class="token comment">/// The proposal gap</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> gap<span class="token punctuation">:</span> <span class="token class-name">PendingQueue</span><span class="token punctuation">,</span>    <span class="token comment">/// Tx pool that finely for commit</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> proposed<span class="token punctuation">:</span> <span class="token class-name">ProposedPool</span><span class="token punctuation">,</span>    <span class="token punctuation">...</span><span class="token punctuation">.</span>    <span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> expiry<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的实现存在以下问题：</p><ul><li><p>我们不容易对所有在交易池中的 entry 做统一排序，这样会存在以下问题：</p><ul><li>一个 fee 高的交易可能在 transaction 多的情况下在 pending 阶段一直卡着，因为我们在 pending 和 gap 阶段只是按照时间顺序来处理，只在 proposed 后的打包阶段按照交易费来处理。</li><li><a href="https://github.com/nervosnetwork/ckb/issues/3942">issue 3942</a> 交易池满了之后，我们需要选择一些 entry 做 evict，我们目前的 evict 逻辑很<a href="https://github.com/nervosnetwork/ckb/blob/fdee47bbd87c66d8a0e54c3ac1f5386cb9aba643/tx-pool/src/pool.rs#L322">简单粗暴</a>。我们希望尽量选择最小 descendants 的交易，这样能避免在 evict 过程中删除过多交易。我们目前在 pending 和 gap 阶段没有记录 descendants，而需要加入这个逻辑就和 proposed 阶段完全重复，而且因为不会统一排序，后续实现也不容易。</li></ul></li><li><p>pending, gap 和 proposed 除了所采用的数据结构不同外，有很多逻辑雷同的代码，比如 entry 的新增和删除等操作，同样都维护了 deps 和 header_deps，resolve_conflict, resolve_conflict_header_dep, resolve_tx 等函数的逻辑也是类似的，但实现上有些细微差异，这导致长期来说代码不容易维护。</p></li><li>同样我们在 <code>tx-pool</code> 上对 entry 做迭代和查询时，需要依次针对 pending, gap, proposed 做相同的逻辑，比如 resolve_conflict_header_dep 这样的函数在 pool 中有几个类似的，甚至 get_tx_with_cycles 这样的函数，需要依次判断各个队列。</li><li>实现其他功能不方便，比如我们如果要实现 Replace by fee，就需要找交易池中和新交易有冲突的交易，我们需要在三个数据结构上分别进行检查才能得到结果。</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>基于以上解决现有问题、应对未来的潜在需求、保持代码可维护性的角度，同时参考 <a href="https://github.com/bitcoin/bitcoin/blob/322ec63b01499c1ec52d3912ee382ebd59f2366b/src/txmempool.h">Bitcoin txmempool</a> 的实现，我们提出引入 <strong>Multi_index_map</strong> 对 tx-pool 进行重构。</p><p>总体方向是把所有的 <code>entry</code> 放入统一的数据结构中进行管理，加入一个新的字段 <code>status</code> 标识目前 <code>entry</code> 所处的阶段，然后通过 index_map 的方式根据不同的属性进行排序和迭代：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">Status</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Pending</span><span class="token punctuation">,</span>    <span class="token class-name">Gap</span><span class="token punctuation">,</span>    <span class="token class-name">Proposed</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[derive(MultiIndexMap, Clone)]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">PoolEntry</span> <span class="token punctuation">&#123;</span>    <span class="token attribute attr-name">#[multi_index(hashed_unique)]</span>    <span class="token keyword">pub</span> id<span class="token punctuation">:</span> <span class="token class-name">ProposalShortId</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> score<span class="token punctuation">:</span> <span class="token class-name">AncestorsScoreSortKey</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> status<span class="token punctuation">:</span> <span class="token class-name">Status</span><span class="token punctuation">,</span>    <span class="token attribute attr-name">#[multi_index(ordered_non_unique)]</span>    <span class="token keyword">pub</span> evict_key<span class="token punctuation">:</span> <span class="token class-name">EvictKey</span><span class="token punctuation">,</span>    <span class="token comment">// other sort key</span>    <span class="token keyword">pub</span> inner<span class="token punctuation">:</span> <span class="token class-name">TxEntry</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中根据 Rust 社区的 <a href="https://github.com/lun3x/multi_index_map">multi_index_map</a> 内部实现采用的数据结构看，性能上应该没有什么大问题：</p><ul><li>Hashed index retrievals are constant-time. (FxHashMap + Slab).</li><li>Sorted indexes retrievals are logarithmic-time. (BTreeMap + Slab).</li><li>Non-Unique Indexes<ul><li>Hashed index retrievals are still constant-time with the total number of elements, but linear-time with the number of matching elements. (FxHashMap + (Slab * num_matches)).</li><li>Sorted indexes retrievals are still logarithmic-time with total number of elements, but linear-time with the number of matching elements. (BTreeMap + (Slab * num_matches)).</li><li>Iteration within an equal range of a non-unique index is fast, as the matching elements are stored contiguously in memory. Otherwise iteration is the same as unique indexes.</li></ul></li></ul><p>具体实现时我们是否把 inner 也放在 Slab 里面以后可以通过 benchmark 来选择，从实现的简洁性角度考虑统一放在一个数据结构里面更容易。</p><p>目前的实现版本：<a href="https://github.com/nervosnetwork/ckb/pull/3993">Tx pool rewrite with multi_index_map #3993</a></p><h2 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h2><p>我们首先只是做模块内的重构 (保持对外逻辑和以前一样)，当然考虑引入了新的数据结构，不管是从性能上还是内存占用上都会有一些影响。</p><p>为了做统一排序这件额外的事，本质上我们引入了额外的 Map(FxHashMap 或 BTreeMap) 来存储，所以比以前需要更多内存。另外，我们有时候需要调用 <code>get_by_status</code> 来筛选某个状态的 entries，这在新的实现里面需要先从 index 里面找出 slab 的 id，然后再找到对应的 entry，所以必然也会比以前慢。</p><p>从最终的性能对比结果上，除了内存会稍微有增加，性能上没有大的变化。另外我们在实现的过程中对所用到的 Rust 包 multi-index-map 做了一些贡献：<a href="https://github.com/lun3x/multi_index_map/pull/23">Non-unique index support, capacity operations, performance improvement &amp; more by wyjin</a>。</p><p>这是我入职后做的第一个主要工作，因为我们的各种测试比较齐全，所以做大的重写信心也比较足。Rust 的生态就有这种问题，如果一个 crate 不是被广泛使用的，必然还是会存在各种坑需要填。总体来说，第一个项目很顺利。做完这个重构之后对于后面的 Replace by fee 等功能也准备好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 在 11.9 号清迈的 &lt;a href=&quot;https://share.foresightnews.pro/article/detail/70811&quot;&gt;CKCON&lt;/a&gt; 会议上我会做一个关于 CKB 交易池的演讲，这是我准备的 slides &lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://catcoding.me/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
      <category term="CKB" scheme="http://catcoding.me/tags/CKB/"/>
    
  </entry>
  
  <entry>
    <title>xz-backdoor 观感</title>
    <link href="http://catcoding.me/p/xz-backdoor/"/>
    <id>http://catcoding.me/p/xz-backdoor/</id>
    <published>2024-04-04T18:04:33.000Z</published>
    <updated>2024-11-06T04:08:02.399Z</updated>
    
    <content type="html"><![CDATA[<p>写写最近一周的大瓜 xz-backdoor，该事件可能成为开源供应链安全的一个分水岭，从技术角度看，这里面的社工和混淆也是精彩。</p><p>简单介绍一下背景，xz 是一个开源的无损压缩工具，在出事之前可能很少有人注意到这个压缩库使用如此之广，几乎任何一个 Unix-Like 的操作系统里面都有 xz-utils。在两年多的时间里，一个名为 <code>Jia Tan</code> 的程序员勤奋而高效地给 xz 项目做贡献，最终获得了该项目的直接提交权和维护权。之后他在 libzma 中加入了一个非常隐蔽的后门，该后门可以让攻击者在 SSH 会话开始时发送隐藏命令，使攻击者能够跳过鉴权远程执行命令。</p><p><a href="https://research.swtch.com/xz-timeline#jia_tan_arrives_on_scene_with_supporting_cast">Timeline of the xz open source attack</a> 总结了该事件的主要时间点，这里我挑一些关键节点：</p><h4 id="潜伏"><a href="#潜伏" class="headerlink" title="潜伏"></a>潜伏</h4><ul><li>2005 ~ 2008 xz 项目的初始版本，这是一个文件压缩算法，主要由 <a href="https://github.com/kobolabs/liblzma/blob/87b7682ce4b1c849504e2b3641cebaad62aaef87/doc/history.txt">Lasse Collin</a> 开发和维护。</li><li>2021-10-29 ~ 2022-06-29 Jia Tan 开始较为密集地给 xz 项目贡献代码，同时几个类似马甲的账号 (Jugar Kumar, Dennis Ens) 在邮件列表里抱怨 Merge 得不到及时处理，问题得不到回复，有点逼宫的意思，在这个过程中项目主导者 Lasse Collin 把最近的优秀贡献者加入了维护者列表。<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4></li><li>2022-09-27 Jia Tan 获得了信任，并开始主导新版本的发布，他在这期间做了几个看似合理的 PR，但其实是在为今后的后门做伏笔，另一个马甲 Hans Jansen 提供了一个钩子可以让后门里的代码替换全局函数，从而绕过检查。</li><li>2023-07-07 Jia Tan 在 Google 的 oss-fuzz 提供修改禁用了 <code>ifunc</code>，这也是为了避免 fuzz 可能发现后门。<h4 id="发动"><a href="#发动" class="headerlink" title="发动"></a>发动</h4></li><li>2024-02-23 Jia Tan 发布了第一个有害的 PR，在测试代码中包含了几个 binary 文件，这些文件看起来只用于测试，所以在代码 review 的过程中肯定不会被仔细查看。</li><li>2024-02-26 Jia Tan 通过一个<a href="https://git.tukaani.org/?p=xz.git;a=commitdiff;h=328c52da8a2bbb81307644efdb58db2c422d9ba7">非常隐蔽的提交</a>，给 CMakeList.txt 增加了一个 <code>.</code>，使得代码会编译失败从而让 Landlock 不会被激活。</li><li>2024-02-24 Jia Tan 发布 v5.6.0，其中使用脚本混淆悄悄地把后门的 payload 塞进了目标文件中。Gentoo 和 Debian 开始在 unstable 版本中含有后门。</li><li>Hans Jansen 同时在发邮件催促 Debian 升级 xz 到 v5.6.1<h4 id="暴露"><a href="#暴露" class="headerlink" title="暴露"></a>暴露</h4></li><li>2024-03-29: 一个叫 Andres Freund 的开发者在分析一个 sshd 可疑的 500ms 延迟时，发现了隐藏在 xz 的恶意后门。如果不是偶然的发现，估计现在世界上无数的服务器处于肉鸡状态，这位微软的员工如英雄一般拯救了世界。</li></ul><hr><h2 id="攻击者是中国人？"><a href="#攻击者是中国人？" class="headerlink" title="攻击者是中国人？"></a>攻击者是中国人？</h2><p>从主要攻击者的名称看似乎是中国人，但 Git 昵称和时区这种东西很容易伪造，有人分析过开发者的代码提交时间，分析得出实际可能是欧洲人/以色列人冒充。</p><p>但不可否认，肯定会有不少国外的开发者会默认这就是中国人所为，我也看到了一些开发者开始带节奏，开始找各种和 Jia Tan 有过互动的中国程序员。</p><p>我倾向于相信这不是中国攻击者，感觉其 commit 信息里面的英文中没找到中式表达。比较确定的是，从这些马甲之间的密切配合来看，这像是一个有密谋的组织团体。</p><h2 id="开源软件的脆弱性"><a href="#开源软件的脆弱性" class="headerlink" title="开源软件的脆弱性"></a>开源软件的脆弱性</h2><p>开源意味着透明，但并不意味着安全。</p><p>10 多年前我们经历了 OpenSSL 的心脏滴血，如今类似的事情再次发生。甚至这次事件的性质更严重，心脏滴血漏洞本身是因为代码的逻辑问题导致被恶意利用，而这次是攻击者通过供应链恶意植入后门。</p><p>有一种观点是开源软件被更多人 review，所以理论上来说安全漏洞更容易被发现。但实际上看来，被巧妙设计过的代码改动，很不容易被发现问题，比如这次事件中这个提交，我相信绝大部分开发者无法发现被恶意添加的 <code>.</code>:</p><p><img src="/images/ob_pasted-image-20240403114716.png" alt=""></p><p>这次后门被发现有很大的运气成分，多亏了 Andres Freund 的细心和刨根问底的精神，这也算是有足够多的眼睛盯着所以发现了问题吧。</p><h2 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h2><p>如果有一个开源贡献者的身份识别机制，就可能预防类似的事情。我看到有人举例 Linux Kernel 提交必须使用 Git 的 Sign-off，但这个 Sign-off 更多的是在解决法律上的问题，Sign-off 本来就是因为法律诉讼而引入的。而且，在最坏情况下，一个开发者可能被社工或者入侵而导致身份被冒用，所以 Sign-off 并不意味着身份识别。</p><p>有的人提到通过支付来进行 KYC(Know Your Customer)，这必然是不可能的，因为开源本来就是一个黑客文化的产物，大量的开发者会刻意选择使用匿名身份提交代码。</p><p>我们来看看 Bitcoin，如果论项目值钱程度，比特币的代码应该能排得上号。但比特币是支持 Permissionless and Pseudonymous development 的，甚至这是保证比特币去中心化的两个很重要的手段，中本聪的身份仍然是一个迷。中本聪选择匿名对比特币本身来说也至关重要，<code>No one controls Bitcoin</code> 是其价值根本。</p><p>那比特币如何保证不会被植入后门，比如这种供应链攻击？</p><ul><li>Reproducible builds，这是个极大地缓解供应链风险的办法，不同的人编译相同的源代码必然得到相同的二进制文件，binary file 不能存在于源码库中。Bitcoin 使用 Guix container 从源码编译所有的东西，<a href="https://github.com/bitcoin/bitcoin/pull/15277">contrib: Enable building in Guix containers</a>，这个过程可以在任何 Linux 发行版上重现。在这个过程中，几乎所有的一切都从源码编译，所以会存在一个鸡生蛋蛋生鸡的问题，为了解决这个问题必然会需要一些 binary files，但最好是将这个范围限制到最小，<a href="https://guix.gnu.org/manual/en/html_node/Preparing-to-Use-the-Bootstrap-Binaries.html">Preparing to Use the Bootstrap Binaries</a>。</li><li>Don’t forget to verify yourself！</li></ul><p>另外比特币的安全在于 PoW，其设计本来就假设了少部分节点可能是恶意节点，除非黑客控制住了大部分节点才能造成破坏，而要达成这点在的概率可以认为就是零</p><h2 id="开源的可持续性"><a href="#开源的可持续性" class="headerlink" title="开源的可持续性"></a>开源的可持续性</h2><p>从这个安全事件我们可以继续探讨开源的可持续性这个问题。这个事件中 xz 的维护者 Lesse Collin 看起来已经是处于疲于应付的地步。从<a href="https://github.com/xz-mirror/xz/graphs/contributors">贡献者统计</a>可以看到这么多年几乎就是他一个人在给项目提交代码，Jia Tan 通过两年的潜伏就成为了贡献者第二的开发者：</p><p><img src="/images/ob_pasted-image-20240403140505.png" alt=""></p><p>长时间维护一个被大量使用的开源项目是个巨大的负担，对维护者而言不仅仅是时间的投入，有时候也是精神上的折磨，即使开发者当初的有多好的愿景，但谁也无法保证常年的持续投入。关于这点可以阅读这篇文章，<a href="https://kettanaito.com/blog/the-dark-side-of-open-source">The Dark Side of Open Source</a>。</p><p>Lesse Collin 在这次事件中被利用了这个弱点，他在这封邮件里解释到自己作为项目主导者的困境：</p><p><img src="/images/ob_pasted-image-20240403014036.png" alt=""></p><p>写到这里我想起自己也曾经催过一个库的作者，是不是考虑让更多人来维护项目 <a href="https://github.com/GREsau/schemars/issues/272">Maintenance status · Issue</a> 😅。</p><p>也许未来可能有一套机制，能够让基础开源软件的维护者得到经济激励，但这条路如何演化出来我还没看出来，如果真的出来或许与加密货币有一定关联。</p><p>可怕的是，现在还有很多人没有意识到开源贡献者困境，那些价值几千上万亿的公司也是在期望开源的开发者能够像雇员似的响应他们的 High Priority：</p><p><img src="/images/ob_pasted-image-20240403013012.png" alt=""></p><p>这个世界上还是有无数的默默耕耘的开源代码维护者，比如 SQLite，全球大概有上万亿的 SQLite 数据实例跑在服务器上、手机上、浏览器里，但这个软件其实只由 3 个程序员维护了 20 多年；几乎所有工程师都使用的工具 curl，由 Daniel Stenberg 从 1998 维护到至今；vim 的作者 Bram Moolenaar 从 1991 年维护项目到自己去世，总共整整 32 年。</p><p>实际上没有人知道，多少被广泛使用的基础组件和代码是由各种默默无闻、分毫未取的开发者在用自己的业余时间维护着。</p><p><img src="/images/ob_pasted-image-20240403135349.png" alt=""></p><p>从这个角度看，人类数字基础设施这艘巨轮其实建立在非常脆弱的基础上，说不定哪天一个地方就裂开了。我现在养成了一个习惯，升级从来不追新，任何安装到自己电脑上的二进制都小心翼翼。</p><p>这个世界上有无数的恶魔，也会有一些英雄和吹哨人，致敬 Andres Freund。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写写最近一周的大瓜 xz-backdoor，该事件可能成为开源供应链安全的一个分水岭，从技术角度看，这里面的社工和混淆也是精彩。&lt;/p&gt;
&lt;p&gt;简单介绍一下背景，xz 是一个开源的无损压缩工具，在出事之前可能很少有人注意到这个压缩库使用如此之广，几乎任何一个 Unix-Li
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="安全" scheme="http://catcoding.me/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>从明天起，做一个 Rust 程序员</title>
    <link href="http://catcoding.me/p/rust-bootcamp/"/>
    <id>http://catcoding.me/p/rust-bootcamp/</id>
    <published>2024-03-18T16:28:13.000Z</published>
    <updated>2024-11-06T04:08:02.391Z</updated>
    
    <content type="html"><![CDATA[<p>3 月是怀念海子的月份：</p><blockquote><p>从明天起，做一个 Rust 程序员，喂马、劈柴，周游世界。</p></blockquote><p>10 年前我开始写第一行 Rust 程序，到如今全职远程做 Rust 开源项目，也许我真能去过喂马劈柴周游世界了😆。但回想自己的学习旅程，其中有各种曲折有几度放弃的时候，如果你也想学习或者提高 Rust 方面的技能，我这篇文章里有一条更容易的路。</p><h2 id="为什么学习-Rust"><a href="#为什么学习-Rust" class="headerlink" title="为什么学习 Rust"></a>为什么学习 Rust</h2><p>Rust 1.0 发布已经快 10 年，所以并不是一门新编程语言了，从发展的角度来看 Rust 已经度过了生存期，并进入了迅速发展的阶段。从目前可见的业界方向来说，Rust 主要在以下几个方面取得了成功：</p><ul><li>在基础软件领域成为有力竞争者<ul><li>大量开源的 Rust <a href="https://github.com/sts10/rust-command-line-utilities">命令行工具</a>和开发库，如果你使用 Python，可以通过  <a href="https://pyo3.rs/v0.21.0-beta.0/">PyO3</a> 用 Rust 来写对性能要求更高的模块，还出现了 <a href="https://github.com/apache/opendal">opendal</a> 这样优秀的基础库</li><li>Cloudflare 使用 Rust 开发新的网关 <a href="https://blog.cloudflare.com/pingora-open-source">Pingora</a></li><li>开源数据库实现，比如 <a href="https://qdrant.tech/">Qdrant</a>、 <a href="https://risingwave.com/">RisingWave</a>、<a href="https://github.com/datafuselabs/databend">databend</a></li><li>AI 方面参考 <a href="https://www.arewelearningyet.com/">Are we learning yet</a>，虽然 Rust ML 生态系统还很年轻并处于试验阶段，但已经出现了一些雄心勃勃的项目和模块，Hugging Face 开源了 <a href="https://github.com/huggingface/candle">candle</a>机器学习框架</li></ul></li><li>前端的基础设施<ul><li>Rust 在前端领域发展迅速，Rust 是 WebAssembly 支持最好的编程语言，不少 Runtime 都是 Rust 实现的，比如 Wasmer</li><li>大量前端基础工具在使用 Rust 重新实现，比如 <a href="https://www.rspack.dev/">Rspack</a>、<a href="https://vercel.com/blog/turbopack">Turbopack</a>、前几天又出现了 <a href="https://github.com/rolldown/rolldown">rolldown</a>，<a href="https://leerob.io/blog/rust">Rust Is The Future of JavaScript Infrastructure</a>似乎已经成为共识</li></ul></li><li>操作系统<ul><li>Windows 开始使用 Rust 开发一些核心组件</li><li>Rust 开始进入 Linux 内核，使得使用 Rust 开发 Linux module 成为可能</li><li>Andriod 使用 Rust 开发更多组件，并有效减少了内存方面的漏洞，他们发布的 <a href="https://google.github.io/comprehensive-rust/">Comprehensive Rust</a>是一个很好的学习资料。Google 开始尝到 Rust 的好处，并开始投入更多资金和人力，近期 <a href="https://security.googleblog.com/2024/02/improving-interoperability-between-rust-and-c.html">Google 打算捐献 100 万美金给 Rust 基金会</a>着重解决 Rust 和 C++ 的互操作性</li></ul></li><li>区块链领域<ul><li>以我在这个领域工作一件多的经验来说，Rust 成为了区块链领域的标配，基本区块链相关的工作岗位 Rust 技能是一个极大的加分项</li><li>大量公链使用 Rust 来开发</li></ul></li><li>游戏开发，参考 <a href="https://arewegameyet.rs/">Are we game yet?</a>，目前已经有成熟的游戏开发框架 <a href="https://bevyengine.org/">Bevy Engine</a></li></ul><p>如果你对 Rust 的发展情况感兴趣，可以参考 <a href="https://blog.rust-lang.org/2024/02/19/2023-Rust-Annual-Survey-2023-results.html">2023 Annual Rust Survey Results</a>。在内卷的 IT 市场，作为程序员选择一门小众的编程语言是避免过度竞争的方式，我之前介绍过其他人的类似经验，我们称之为 <a href="https://catcoding.me/p/weekly-13/">The Niche Programmer</a>。Rust 还未成为主流编程语言，但潜力和发展空间很大，而门槛相对其他语言比较高，所以我认为从求职的角度来考虑是值得一试的。</p><p>之前提到 Google 投入更多的资金在 Rust 上面，钱进来后相关的职位就出来了 <a href="https://foundation.rust-lang.org/careers/">C++/Rust Interop Initiative Software Engineer Lead</a>。</p><h2 id="我学习-Rust-的体会"><a href="#我学习-Rust-的体会" class="headerlink" title="我学习 Rust 的体会"></a>我学习 Rust 的体会</h2><p>我 2014 年时践行每年学习一门新的编程语言，Rust 作为一门新的编程语言进入了我的视野。我开始使用  Rust 写些简单的个人学习项目，然后我继续做了 <a href="https://exercism.org/tracks/rust/exercises">Rust exercises</a> 。</p><p>后续几年我偶尔看看 Rust 相关的新闻和项目，时不时动手写点代码都会有点磕磕碰碰。直到四年前开始在 Github 上给一些 Rust 开源项目贡献，两年前开始给 Rust 编译器做贡献，一年前开始全职从事 Rust 区块链相关的工作。</p><p>从技术角度来说，Rust 非常有趣，这里面包含了近些年程序设计方面的一些良好实践。全职写 Rust 程序这一年多是我开发体验最好的阶段，当然有时候我们需要和编译器斗智斗勇、做类型体操，但很多问题在开发阶段给规避掉了。</p><p>Rust 的最大问题还是在于学习门槛相对较高，因为在 Rust 中程序员接触最多的  <code>=</code> 语义都变了。从我个人体验来说，在学会了 Rust 语法后会陷入一个瓶颈，如果日常工作中不使用 Rust，就没有多少机会去实践，另外不知道做一些什么项目。</p><p>我相信很多人同样如此，看了官方 tutorial 之后不知道如何下手，我想如果有一个经验丰富的老师带，会少走很多弯路，这就是我要介绍的极客时间训练营要解决的问题。</p><p><img src="/images/ob_pasted-image-20240316231547.png" alt=""></p><h2 id="极客时间-Rust-训练营"><a href="#极客时间-Rust-训练营" class="headerlink" title="极客时间 Rust 训练营"></a>极客时间 Rust 训练营</h2><p>说起来我与这个训练营还有些渊源。</p><p>当极客时间在筹划这个 Rust 训练营的时候，策划人员找到过我问我是否有意愿当这个课程的讲师。我还稍微犹豫了一下，因为我之前也想过如何在 Rust 领域做更多的分享，我很羡慕优秀的技术分享者比如 <a href="https://www.youtube.com/@jonhoo">Jon Gjengset</a>能够非常自如地通过视频分享 Rust 方面的技术。当老师当然是个机会能从沟通和表达方面提高这方面的能力。</p><p>后来考虑到自己时间方面安排不过来，我有全职工作、有业余的 Rust 社区工作、还有三个小孩，所以我应该真没时间去录制课程了，而且他们已经找到了我认为最合适的讲师：</p><p><img src="/images/ob_pasted-image-20240316223445.png" alt=""></p><p>我看了这个项目的大纲，陈天老师希望可以教大家怎么用 Rust 比较简单的语法和技巧，来完成 80% 的日常工作，主要是通过各种实践项目来学习，这也是我最推崇的 Learn by doing 的方式。</p><p>有很多主题我都没怎么接触过，比如构建一个 ChatGPT 的应用、比如跨平台 GUI 之类的，所以我对这个课程很感兴趣，然后我和策划说能不能做这个项目的助教，后来沟通下来发现当助教也需要不少时间的，所以就没机会参与到具体的教学里面了。</p><p><img src="/images/ob_pasted-image-20240316231751.png" alt=""></p><p>总之，这个项目对于想学习 Rust 或者已经有一定 Rust 经验，但想获得更多实践经历的人是非常合适的。在和极客时间的相关人员沟通的过程中，我发现他们做事情很用心，这个训练营的课程质量我认为是有保证的。</p><p>这个训练营一共是 15 周的课程安排，其中每周都会有明确的项目安排，课后还有助教答疑。关于训练营的更多信息请参考：<a href="https://u.geekbang.org/subject/rust">极客时间训练营-Rust 训练营</a></p><p><img src="/images/ob_rust-boot-20240318164451.png" alt=""></p><h2 id="我与陈天老师的小故事"><a href="#我与陈天老师的小故事" class="headerlink" title="我与陈天老师的小故事"></a>我与陈天老师的小故事</h2><p>我最早知道陈天是他写的公众号《程序人生》，他是那种技术和文笔都非常棒的程序员，非常难得。我还看过他的 B 站上的技术讲解视频，他的演讲和分享都很流畅。陈天是极客时间《陈天 · Rust 编程第一课》专栏作者，已有 2.3w 人学过，广受好评。技术能力、演讲表达、对技术的热情这些都是讲师最重要的素质要求，所以陈天是这个训练营最好的讲师人选。</p><p>再分享一个小故事，我一年多前跳槽的时候还有些犹豫，因为自己的职业规划方面有些困惑，所以想找些人聊聊。当时我突然想到陈天之前从事过区块链方面的创业，后来从里面退出来了，所以我就想向他咨询一下。我没有他的联系方式，但灵机一动我想到了从 Git 的提交记录里面找 Email，然后抱着试一试的想法给他发了个邮件说明了自己的情况和困惑。没想到他很快给我回复了，并很详细地告诉我他对于区块链的想法，还有如何判断自己是否适合一个公司，通过各种途径了解公司的相关产品来作为决策的依据等等。</p><p>我作为一个陌生人，陈天老师都会乐于给与指导和帮助，可见为人真的很好。还没能有幸和陈天老师现实中有所交流，我本来想用当助教的机会和陈天老师多学习，但时间方面安排不过来了。希望大家能在老师的的训练营学到知识、经验、还有探索技术的乐趣！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;3 月是怀念海子的月份：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从明天起，做一个 Rust 程序员，喂马、劈柴，周游世界。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;10 年前我开始写第一行 Rust 程序，到如今全职远程做 Rust 开源项目，也许我真能去过喂马劈柴周游
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>我喜欢的 shell 工具</title>
    <link href="http://catcoding.me/p/handy-sh-tools/"/>
    <id>http://catcoding.me/p/handy-sh-tools/</id>
    <published>2024-03-16T23:52:40.000Z</published>
    <updated>2024-11-06T04:08:02.383Z</updated>
    
    <content type="html"><![CDATA[<p>分享一些日常经常使用的命令行小工具，我认为这些小东西能提高我的工作效率。</p><h2 id="percol"><a href="#percol" class="headerlink" title="percol"></a>percol</h2><p><a href="https://github.com/mooz/percol?tab=readme-ov-file#zsh-history-search">mooz/percol</a> 这个工具是典型的 Unix 风格工具，它唯一做的事情就是通过管道接收输入，提供一个模糊搜索和 UI，用户选择后再把结果返回给后面的管道继续执行。</p><p>比如我这个 <code>gt</code> 的 alias 是我日常使用非常多的一个命令，做的事情就是 check out 一个 git 分支，因为我的本地通常有很多的分支，所以使用这个命令来模糊查找，然后选中就非常方便了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">gt</span><span class="token operator">=</span><span class="token string">"git branch| percol | awk '&#123; print \<span class="token variable">$1</span> &#125;' | xargs git checkout "</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似的下面这个命令是 kill 掉某个进程，我们可以通过模糊搜索来找进程：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">pk</span><span class="token operator">=</span><span class="token string">"ps eaux | percol | awk '&#123; print \<span class="token variable">$2</span> &#125;' | xargs kill -9 "</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>如果你仔细总结，日常开发任何需要选择的地方都可以使用这个小工具来达到更高的效率，比如我工作的目录下有很多测试文件，测试其中一个文件的命令是 <code>just ts file-path</code>，我需要找到其中一个来测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./tests/ui/ <span class="token parameter variable">-name</span> <span class="token punctuation">\</span>*.rs  <span class="token operator">|</span> percol <span class="token operator">|</span> <span class="token function">xargs</span> just ts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>percol</code> 可以嵌入到很多配置里面，比如在 <code>tmux.conf</code> 里面加入这个配置，这样可以模糊查找 tmux 的 session 和 window：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">bind</span> B split-window <span class="token string">"tmux lsw | percol --initial-index <span class="token variable"><span class="token variable">$(</span>tmux lsw <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/active.$/ &#123;print NR-1&#125;'</span><span class="token variable">)</span></span> | cut -d':' -f 1 | tr -d '<span class="token entity" title="\n">\n</span>' | xargs -0 tmux select-window -t"</span><span class="token builtin class-name">bind</span> b split-window <span class="token string">"tmux ls | percol --initial-index <span class="token variable"><span class="token variable">$(</span>tmux <span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token punctuation">\</span>"/^<span class="token punctuation">$(</span>tmux display-message <span class="token parameter variable">-p</span> <span class="token string">'#&#123;session_name&#125;'</span><span class="token punctuation">)</span>:/ <span class="token punctuation">&#123;</span>print NR-1<span class="token punctuation">&#125;</span><span class="token punctuation">\</span>"<span class="token variable">)</span></span> | cut -d':' -f 1 | tr -d '<span class="token entity" title="\n">\n</span>' | xargs -0 tmux switch-client -t"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="atuin"><a href="#atuin" class="headerlink" title="atuin"></a>atuin</h2><p><a href="https://github.com/atuinsh/atuin">atuinsh</a> 是一个记录 shell 历史的小工具，不同于普通的记录 shell history 的工具，atuin 会把数据记录在一个 SQLite 的数据库文件中，这样可以支持更丰富的查询功能。</p><p>另外 atuin 也支持不同机器之间的同步，当然这需要加密通信。我目前还没使用这种场景，只是把 <code>Ctrl-R</code> 绑定到了 atuin。</p><p>atuin 也是一个 Rust 实现的工具。</p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>tmux 我之前听很多人推荐过，但是我一直没怎么尝试，直到某天我需要通过网页打开跳板机登录到服务器上，网络不稳定的情况下我经常需要重新登录，这时候我尝试了一下 tmux 发现真是太好用了。</p><p>tmux 的教程很多，比如 <a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程 - 阮一峰的网络日志</a>。我的 <code>tmux.conf</code>配置很简单：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> <span class="token parameter variable">-g</span> @plugin <span class="token string">'tmux-plugins/tpm'</span><span class="token builtin class-name">set</span> <span class="token parameter variable">-g</span> @plugin <span class="token string">'tmux-plugins/tmux-sensible'</span><span class="token builtin class-name">set</span> <span class="token parameter variable">-g</span> @plugin <span class="token string">'tmux-plugins/tmux-resurrect'</span><span class="token builtin class-name">set</span> <span class="token parameter variable">-g</span> @plugin <span class="token string">'tmux-plugins/tmux-continuum'</span>unbind-key C-bset-option <span class="token parameter variable">-g</span> prefix C-Spacebind-key C-Space send-prefixset-option <span class="token parameter variable">-s</span> set-titles onset-option <span class="token parameter variable">-g</span> set-titles-string <span class="token string">"#W/#T"</span>run <span class="token string">'~/.tmux/plugins/tpm/tpm'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装 <code>tmux-resurrect</code> 和 <code>tmux-continuum</code>，这样即使我重启了机器，打开 tmux 后我的 session 仍然和之前一样。</p><p>最近也有个 Rust 写的 <a href="https://github.com/zellij-org/zellij">zellij</a>，但我认为这种软件使用更老的会更方便，比如公司的远程服务器必然有 tmux，但不一定有 zellij。</p><h2 id="just"><a href="#just" class="headerlink" title="just"></a>just</h2><p><a href="https://github.com/casey/just">casey/just: 🤖 Just a command runner</a> 是我喜欢的另外一个 Rust 写的工具，我的日常工作中严重依赖这个工具，比如我的 rustc-dev 项目中配置渐渐积累了这么多的配置：<a href="https://gist.github.com/chenyukang/1483cbbf75a4bd5ae2930415329cb682">rustc-justfile</a></p><p><code>just</code> 有些像 Makefile，但使用起来又比 Makefile 的语法简单和直观，我通常是来把一些常用的命令写入 justfile，然后留下经常需要调整的参数，比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">err FILE N:        rustup toolchain <span class="token function">link</span> dev2 ./build/aarch64-apple-darwin/stage1/        <span class="token assign-left variable">RUSTC_ICE</span><span class="token operator">=</span>/tmp rustc +dev2 <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>FILE<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token parameter variable">-Z</span> treat-err-as-bug<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>N<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样我执行 <code>just err tests/ui/consts/const-eval/infinite_loop.rs 1</code> 的时候就相当于执行配置的一系列命令。</p><p>另外我也会把一些频繁需要修改的参数放到最后一个位置，比如本来我需要执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CKB_TEST_ARGS</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>SPEC<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token function">make</span> integration<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 justfile 里面配置：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test-one SPEC:        <span class="token assign-left variable">CKB_TEST_ARGS</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>SPEC<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token function">make</span> integration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>执行 <code>just test-one SPEC</code>  来测试不同的用例就会方便点。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/bootandy/dust">bootandy/dust: A more intuitive version of du in rust</a> 一个更直观的 du</li><li><a href="https://github.com/aristocratos/btop">aristocratos/btop: A monitor of resources</a> 和 htop 类似，但是 UI 更好看些</li><li><a href="https://github.com/Orange-OpenSource/hurl?tab=readme-ov-file">hurl: Hurl, run and test HTTP requests with plain text.</a> 类似 Curl，但是更方便</li></ul><hr><p>你有什么喜欢的 Shell 工具，希望也能分享给我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分享一些日常经常使用的命令行小工具，我认为这些小东西能提高我的工作效率。&lt;/p&gt;
&lt;h2 id=&quot;percol&quot;&gt;&lt;a href=&quot;#percol&quot; class=&quot;headerlink&quot; title=&quot;percol&quot;&gt;&lt;/a&gt;percol&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="工具" scheme="http://catcoding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>中外程序员差异</title>
    <link href="http://catcoding.me/p/diff/"/>
    <id>http://catcoding.me/p/diff/</id>
    <published>2024-02-24T21:58:03.000Z</published>
    <updated>2024-11-06T04:08:02.383Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到这个<a href="https://twitter.com/Piglei/status/1761051133135687853">推特</a>，我理解作者的心情非常复杂，因为我前三年写过一段时间技术类的英文文章，也发现英文技术社区还有那种认真讨论的氛围，而在中文技术圈里，这种氛围已经几乎绝迹。</p><p>这几年因为我在外企和开源上的工作经历，接触了很多来自各个国家的程序员，今天想写写我发现的一些国内外程序员间的差异，我相信经常混迹开源社区的人会有些类似感受。</p><h2 id="讲究细节"><a href="#讲究细节" class="headerlink" title="讲究细节"></a>讲究细节</h2><p>这点是我感受最深的，我自认为已经算是一个对细节比较在乎的人了，但我接触到一些国外的程序员，他们对细节的把握让人佩服。</p><p>最近的一个例子是我在写这篇<a href="https://github.com/nervosnetwork/docs.nervos.org/pull/206">英文文档</a> 的时候遇到的，其中的 Reviewer jordanmack 对我文档里面的所有内容逐字逐句都过了一遍，发现不懂的地方一定要弄明白。这里面有的是中英文表达差异造成的理解偏差，也有他对这个功能的逻辑上的质疑，甚至可以细节到我在文中给出的 json 例子里的数字范围和自洽性。我们在 Github 上来回讨论了很久，然后继续在 Discord 上讨论，而在这个过程中我也确实发现了些代码上需要调整的地方，最后他给我的文章几乎全部<a href="https://github.com/chenyukang/docs.nervos.org/pull/3">润色了一遍</a>。</p><p>jordanmack 不算是全职的程序员，但他也有一些程序员背景。在我做开源的经历中，PR 中被挑细节的时候太多了，一度我已经不再认为自己是个对细节很把握的人了。后来我总结了一下，有时候我是在赶时间，觉得某些 corner case 就暂且跳过吧，但大多会在代码 Review 中被提出来的。</p><p>然后经历多了也就看淡了，不光是我，任何人的 PR 都可能引发大量的讨论，比如到底是使用 <a href="https://github.com/rust-lang/rust/pull/75065">µs 还是 us</a>。也许在很多人看来这是个小问题，但却引起了大量的讨论，细看其中还有些引经据典和长篇大论。随便挑一个 RFC，也都可以看到<a href="https://github.com/rust-lang/rfcs/pull/3573">大量的讨论</a>。</p><p>所以我的感受是，国外程序员中在意细节的比例更大。那么问题是，他们为什么能看这么细？固然其中一个很重要的原因是他们确实有时间，才能静下心来看和写。</p><p>在国内公司我也碰到过对细节的把握，但很多用在了我最讨厌的形式主义上。在微软的时候，我见过各种不够漂亮的 PPT，有的时候翻来一段 onenote 就开始讲，因为都没人关注这些。</p><h2 id="文字表达"><a href="#文字表达" class="headerlink" title="文字表达"></a>文字表达</h2><p>文字表达能力是开源社区里一个非常重要的，因为但凡一个大的改动都需要和其他人广泛讨论和协作。</p><p>不少国外的程序员有文字表达的习惯，就是即使看很小的一点问题也会通过文字表达出来。这是很多国内程序员所没有的习惯，因为我们大多比较含蓄，认为多做比说强，说多容易错，说多容易暴露自己。</p><p>可能和教育和网络环境也有一定关系，如果不是刻意维持文字表达的习惯，很多人高中毕业后就没有写过几篇长文，对很多事情也没有自己的看法。</p><p>另外他们习惯使用 Email 来沟通，但中国开发人员大多习惯使用 IM 沟通。这两者还是有区别的，IM 沟通会让人不自觉地回复得更快，有的模糊想法随口就就表达了。而 Email 沟通更容易让人把事情写清楚，也更容易写得更长和有条理。</p><p>这种细微的差异长久了之后就可看出中英文技术社区的巨大差别。另外，中文网络的环境中戾气更重一些，人们对自我推销很反感，容易揣测你的意图。</p><h2 id="个人目标"><a href="#个人目标" class="headerlink" title="个人目标"></a>个人目标</h2><p>很多欧美大公司里有不少只做 Individual Contributor 而不做管理的人，在这些公司里，管理和技术是两条并行线，薪资和职级挂钩，也就是说纯 IC 的岗位可能收入比管理岗位更高，因为职级更高。</p><p>管理人员和技术人员大多是上下级关系，但下属对管理人员没有绝对的单向服从关系。当然大多数情况下，管理更容易升职上去，因为纯做技术岗位不容易通过杆杠来放大自己，管理就是一种很有效的杠杆。但这种纯粹的并行晋级路线是非常重要的，可以让技术人员有更多的选择权，甚至如果对自己的管理者不满意直接给差评和换组就是了。</p><p>所以在国外程序员中，如果一个人做了多年开发，很可能就是他确实喜欢做技术和更擅长做技术。而中国职场中，管理和技术岗的差别太大了，或者说绝大部分人到了一定年龄，如果你不混个管理的 title，好像就已经落后了，甚至没有职场安全感。</p><p>另外有些人是喜欢混到管理岗之后，纯粹为了获取更高的薪水，或者是为了把不喜欢做的事情推给别人。当然，这其中也有很大一部分中国文化里的官本位的影响，还有一部分原因是太看中钱了。</p><p>我接触过一些年龄在 40 岁多的国外程序员，他们还是对技术有很大热情。如果喜欢做技术，而又能通过做技术挣钱，这没有什么失败的，这与年龄没关系，反而这是一种很好的度过自己短暂一生的方式。</p><p>只是在国内要做到这点并不容易，很多岗位做的事情本来就不够有深度，时间更久也无法积累起来足够的壁垒，业务上的开发年轻人上手很快，而需要深入做下去的岗位不够，所以年龄大了就容易失业。</p><h2 id="业余时间"><a href="#业余时间" class="headerlink" title="业余时间"></a>业余时间</h2><p>国外程序员的业余时间真是非常多，如果你经常混 Github 就会发现，每当到了 12 月份就很多出来很多 aoc 字样的项目，这是他们在做<a href="https://adventofcode.com/">Advent of Code 2023</a>。</p><p>Advent of Code 就是整个 12 月份每天出一道题目，都是些编程谜题，有点类似 leetcode，但题目描述更长。你可以用任何语言来实现，反正要的结果就是答案。可以发现这些 aoc 项目基本都是欧美的程序员在做，因为他们大多在 12 月份有几乎一个月的假期，我在微软工作的时候，很多人也是 12 月份开始基本不见人影。</p><p>创造性的前提是不用为生存问题发愁，欧洲那些搞哲学、做研究的，大多都是家底丰厚，闲得多了自然就能搞事。如果有大把的业余时间，用来发展工作外的开源项目可就太好了。其实很多著名的开源项目只有吃饱饭没事做的时候才能搞出来，我之前在知乎问题 <a href="https://www.zhihu.com/question/502884696/answer/2296787480">为什么中国程序员不如外国程序员有创造性</a> 中写到：</p><blockquote><p>荷兰人<a href="https://www.zhihu.com/search?q=%E8%9F%92%E8%9B%87&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2296787480%7D">蟒蛇</a>大叔想着哇塞圣诞假期这么长，找点事做，结果出了 Python。<br>日本人松本行弘，经济危机时闲得发慌，搞出了 Ruby。<br>芬兰人<a href="https://www.zhihu.com/search?q=%E6%9D%8E%E7%BA%B3%E6%96%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2296787480%7D">李纳斯</a>，大三不用为了找工作背八股和考研，冬眠似地宅家里写代码，搞出了 Linux。</p></blockquote><p>在 Rust 社区中的贡献人员里，除了美国，第二多的是欧洲，他们也不是为了挣钱，完全就是感兴趣做做而已，我看到好几个大学年轻人做的事情已经非常深入了，当然其中花费的时间也是很多，他们几乎一直在线。</p><hr><p>这些总结比较粗略，另外也可能有幸存者偏差因素。这个话题很大，深入下去探讨会包含很多方面。</p><p>我也不是在抱怨，年龄大了之后发现多看看历史相关的书还挺好，让自己更容易理解所处的环境为什么是这样的，比如《中国国民性演变史》这本书值得推荐。另外《美国种族简史》这本书也值得一看，多了解了解其他人的特点和长处，努力让自己不要局限于国界，另外做到程序员中的 80% 以上水平，保持英文能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看到这个&lt;a href=&quot;https://twitter.com/Piglei/status/1761051133135687853&quot;&gt;推特&lt;/a&gt;，我理解作者的心情非常复杂，因为我前三年写过一段时间技术类的英文文章，也发现英文技术社区还有那种认真讨论的氛围，而在中文技
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="程序员" scheme="http://catcoding.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>Copilot，最好的编程助手</title>
    <link href="http://catcoding.me/p/copilot-for-programming/"/>
    <id>http://catcoding.me/p/copilot-for-programming/</id>
    <published>2024-01-21T14:43:34.000Z</published>
    <updated>2024-11-06T04:08:02.383Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午我解决一个小问题的时候，在 Copilot 的帮助下快速给出了修复，这个工具似乎有些超过期望了，所以突然想写篇文章分享这个目前我最愿意付费的 AI 工具。</p><p><sub>Copilot 价格是每个月 10 美金，但我至今还没付费过，感谢微软支持开源，从测试阶段就邀请我试用，到现在还一直在免费使用。Github 应该有些政策，比如如果你持续给一些 star 数比较多的开源项目做贡献，就可以免费使用 Copilot</sub>：</p><p><img src="/images/ob_pasted-image-20240120212918.png" alt=""></p><p>我会给出日常碰到过的一些具体的实际案例截图，以方便你更直观地感受到这个工具准确度。</p><h3 id="Manual-类查询"><a href="#Manual-类查询" class="headerlink" title="Manual 类查询"></a>Manual 类查询</h3><p>我们在编程过程中经常会碰到一些命令的参数记不太清楚，这种问题很适合问 Copilot。这比自己去 Google 的感受好很多，因为他几乎能完全理解用户说的自然语言，而且给出的答案简介明了：</p><p><img src="/images/ob_pasted-image-20240120224637.png" alt=""><br>比 Google 更好的地方在于上下文的交谈，比如我继续基于上面的问题说我的想法，他就能继续给出反馈，比如我说大概有个类似 <code>--exact</code> 的参数，Copilot 会继续给出使用案例。</p><p>Copilot 非常善于回答对这种 manual 类的问题，因为这是有标准答案的，并且我作为用户对这些是有判断的，只是我们细节上记不清楚了。</p><p>还有一次我发现跑测试的时候挂了，分析下来是这个命令行失败了（但既然 CI 是过的，所以必然只是在 MacOs 下失败了)：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">diff</span> <span class="token parameter variable">-u</span> --strip-trailing-cr <span class="token parameter variable">-r</span> <span class="token parameter variable">-q</span> A_file.txt A_file.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是在 diff 同一个文件，所以必然应该返回 0，但在 MacOS 下这个命令会报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">✗ <span class="token function">diff</span> <span class="token parameter variable">-u</span> --strip-trailing-cr  <span class="token parameter variable">-r</span> <span class="token parameter variable">-q</span> ./x.py ./x.pyerror: conflicting output <span class="token function">format</span> options.blah blah 一大堆错误 blah blah 一大堆错误 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我知道这里面肯定是有参数冲突了，但我具体不知道是哪两个冲突了，所以这时候我问 Copilot：<br><img src="/images/ob_pasted-image-20240120230403.png" alt=""></p><p>可以看到这个解释非常清楚，并且帮我找到了问题的根源，所以我就能很快地发 PR 修复这个问题，并且我 PR 里的描述基本都是从 Copilot 里来的：<br><a href="https://github.com/rust-lang/rust/pull/109036">Fix diff option conflict in UI test #109036</a></p><h2 id="给出示例代码"><a href="#给出示例代码" class="headerlink" title="给出示例代码"></a>给出示例代码</h2><p>我们在写代码的时候，经常会出现固定的 Pattern，不同的语言对固定的 Pattern 有一些相对固定的代码样式。我很喜欢找 Example 类的代码，然后在这个基础上再思考或者修改：</p><p><img src="/images/ob_pasted-image-20240120230905.png" alt=""></p><p>对这种情况我们需要给 Copilot 足够的信息，他给出的 Rust 代码通常是可直接编译通过的，但当然这些示例代码需要进行仔细的修改，但这也比我自己翻 Doc 会快很多。</p><h2 id="辅助排查问题"><a href="#辅助排查问题" class="headerlink" title="辅助排查问题"></a>辅助排查问题</h2><p>VSCode 上的 Copliot 更新很快，肉眼可见地体验越来越好，现在我们可以选择一段代码，然后就选择的代码来进行提问。</p><p>有时候我会选中一个函数，然后问这段函数能不能重构得更简单一些，或者我们能不能用其他方式实现。</p><p>今天让我有欲望写下这篇分享的文章是因为这个问题：<br><a href="https://github.com/nervosnetwork/ckb/issues/4309">Missing request extension: Extension of type</a></p><p>这是一个有非常明确的报错的繁琐 issue，应该就是 Server 端限制了 HTTP 的请求类型，客户端通过 curl 发 GET 请求的时候报错了，只是这个报错信息看起来很不友好，而且和老版本行为不同。所以我就选中代码中对应的函数，然后问这里为什么会有这个错：</p><p><img src="/images/ob_pasted-image-20240120232057.png" alt=""><br>其实我对 Copilot 解决这个问题不怎么报有信心，只是好奇先试了试，没想到 Copilot 真的能理解我的代码，并且指出了问题所在。注意看它加的注释就是我代码中缺少的逻辑 (之前的代码只是在 <code>enable_websocket</code> 的条件下才加载了 stream_config 这个 Extension)：</p><p><img src="/images/ob_pasted-image-20240120232121.png" alt=""></p><p>加上它建议的代码之后，那个错误信息没了，但是现在发 GET 请求是另外一个问题：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">Connection header did not include &#39;upgrade&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这看起来是服务端期望客户使用 Websocket，但是客户端只是在通过 Curl 发一个 GET 请求，并没有按照这个期望来。所以我继续问 Copilot：</p><p><img src="/images/ob_pasted-image-20240120232647.png" alt=""></p><p>他给的回复里的代码并没有直接修复问题，但里面的<br><code>you can separate the handlers for POST and GET requests</code><br>提示了我应该尝试对 HTTP endpoint 和 Websocket endpoint 的 handler 进行分开，所以我一下想到了修复方案：</p><p><img src="/images/ob_pasted-image-20240120232901.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如今使用 Copilot 已经成为我的一个编程习惯，就如同之前我严重依赖 Google 一样，但这个工具明显比搜索引擎高级了一个维度，当然现在我还是依赖搜索，但使用比率明显下降了不少，搜索引擎更像是成了一个书签的角色了。</p><p>我之前认为 Copliot 这种工具甚至是这辈程序员所不能体验到的东西，在我第一次尝试到 ChatGPT 居然可以理解一个函数，并且找出函数中的问题时，就感觉新的编程时代来临了。</p><p>前段时间 Redis 的创始人在文章 <a href="http://antirez.com/news/140">LLMs and Programming in the first days of 2024</a> 中写到：</p><blockquote><p>随着时间的推移，我们见证了框架、编程语言、各种库的大量涌现。这种复杂性通常是不必要的，甚至无法自圆其说，但事实就是如此。在这样的情况下，一个无所不知的“白痴”成了宝贵的助手。</p></blockquote><blockquote><p>这是一个事实：现今的编程大多是在微调同样的内容，只是形式略有变化。这种工作并不需要太高的推理能力。</p></blockquote><p>Copilot 已经可以在一些具体的编码问题上给到我们很多帮助，甚至你把这个当作一个包含万物的文档查询工具都非常有效。</p><p>当然没有银弹，Copilot 并不能解决编程中的所有问题，比如理解大规模的程序，通过深入分析去找出 bug，或者做设计问题中的各种折中和取舍，这些都是不能取代人类的，这也是我认为编程中的乐趣还没有完全消失。</p><p>我会把繁琐和细节的问题抛给 Copilot，然后更开心地做重要和有趣的部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天下午我解决一个小问题的时候，在 Copilot 的帮助下快速给出了修复，这个工具似乎有些超过期望了，所以突然想写篇文章分享这个目前我最愿意付费的 AI 工具。&lt;/p&gt;
&lt;p&gt;&lt;sub&gt;Copilot 价格是每个月 10 美金，但我至今还没付费过，感谢微软支持开源，从测试
      
    
    </summary>
    
    
      <category term="工具" scheme="http://catcoding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="AI" scheme="http://catcoding.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>我的 2023</title>
    <link href="http://catcoding.me/p/2023-summary/"/>
    <id>http://catcoding.me/p/2023-summary/</id>
    <published>2023-12-30T22:36:00.000Z</published>
    <updated>2024-11-06T04:08:02.379Z</updated>
    
    <content type="html"><![CDATA[<p>2023 年很快就要结束了，赶紧抓住这个冲动总结一下。今年对我来说有几个大的转变，从几个方面谈起：</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>生活上最大的变化是我又有了一个儿子，所以我现在是三个孩子的父亲了。</p><p>同龄人中几乎没有生三胎的，有些人问我为什么这么想不开，自己找罪受。我只能说是命运的馈赠吧，我从小生活在一个大家庭里，加上我和老婆都算是喜欢小孩的人，三胎顺其自然地接受了，这个孩子也促使了我们更早地离开了苏州。</p><p>孩子 8 月底出生，前两个月请到了一个靠谱的月嫂，所以生活方面还不算痛苦。最近女儿生病才开始感受到三个孩子带来的巨大挑战，看来我们是低估了其难度。</p><p>我的大女儿开始在深圳上一年级，没想到现在的一年级都这么卷，基本上每天都有语数外作业，一个月一次的考试。我们力不从心已经放弃了一些家庭作业，比如数学之类的无聊作业我们就不怎么做，我认为每个小孩的大脑发育有自己的节奏，小学数学这种东西到了年龄自己会懂，小学阶段重要的是培养学习习惯和兴趣，强压给孩子只会让她产生对数学的恐惧。陪小孩做作业真是一件极其需要耐心的事情，我现在还在努力尝试从孩子的角度考虑问题。</p><p>三个孩子带来的另外一件事情就是冲突，大女儿心情好的时候会带着小的玩，心情不好的时候就会和妹妹争东西。如何在这些孩子中平衡，在吵闹中克服情绪去解决问题，这些都是在磨炼心性。</p><p>纪伯伦在《论孩子》中写到：<em>你的孩子，其实不是你的孩子，他们藉助你来到这个世界，却非因你而来，他们属于你做梦也无法达到的明天。</em></p><p>有孩子之前我觉得养育孩子重要的是把他们当朋友，但真的等孩子三岁后有了更多自主意识之后，作为父母就会面临更多困难，什么时候该管教孩子，什么时候该放任他们。有时候我也忍不住发火，而后又觉得自己是个失败的父亲，心里多默念『还只是个孩子』几遍，如何做一个好父亲这必然是我今后一直需要学习的。</p><p>生活中的另一个变化是今年身体状态更好了，可能是因为深圳的暖和天气更适合我，加上在家办公出去本职工作外，没感受到什么职场上的琐事和压力，另外在家里办公相关的设备更适合自己，所以整体身体上没有大的问题。</p><p>但从心理方面，我能感受到和以前的更大差别，主要是彻底接受了中年这个年龄阶段。这是一点点积累起来的，那些曾经我看着长大的晚辈们都到了谈婚论嫁的年龄，或者偶然想起一些人和事心里一算已经是十多二十年前了，或是我发现自己某些方面更像印象中的父亲了。</p><p>我的生活看起来极其单调，不是坐在屏幕前写程序就是在带娃和遛娃，和梦想与激情这些词汇毫不沾边。但我满足并感恩目前的状态，我几乎没有焦虑，物欲低所以也不觉得缺钱，做着自己喜欢的工作和事情，有足够多的时间陪家人，这就很好了。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>2023 我全职远程做开源项目，很幸运在 Cryptape 这大半年里工作感受非常好，这大概是我工作这么多年来写程序最开心的一段时间。因为远程办公，今年我的人际圈子似乎更小了，日常微信沟通的都是些认识了 10 来年的朋友。</p><p>我的工作主要是做区块链 Layer 1 相关的事情，入职以后做的事情是交易池这块，后来又涉及到一些 RPC 相关的工作，还有些 Infra 类的工作。区块链这行涉及范围太多了，有网络、性能、分布式、密码学等各种，所以对于纯喜欢技术的人来说，这里面挑战太多，比 CRUD 之类的项目好玩得多。</p><p>我做的主要工作都是集中在 <a href="https://github.com/nervosnetwork/ckb">nervosnetwork/ckb</a>这个项目，这里可以看到我做的一些 <a href="https://github.com/nervosnetwork/ckb/pulls?q=is:pr+author:chenyukang+is:closed">Pull requests</a>。</p><p>另外现在日常工作中纯用 Rust，编程体验和之前完全不是一个层次，除了如何实现功能，我们也会在乎项目的长期可维护性和优雅程度。区块链 Layer 1 也算是一个复杂度高和对准确度要求很高的项目，Rust 是很适合的。我虽然这两年一直在写 Rust 代码和做开源，但之前还真没有用 Rust 在实际工作中，特别是异步这块我之前甚少涉及。同事中有对 Rust 理解很深入的人，沟通也很顺畅，所以我特别喜欢这个工作氛围。</p><p>在工作过程中我看了更多 Bitcoin 相关的代码，越发觉得这真是一个伟大的发明，这像是个黑客用技术发起的社会性实验，在 beta 阶段就能如此深刻地影响了世界。关于 Bitcoin 推荐看这一系列文章 <a href="https://www.btcstudy.org/search/?w=%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E8%BF%87%E5%8E%BB">比特币的过去、现在和未来</a>。</p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p><img src="/images/ob_pasted-image-20231229200920.png" alt=""></p><p>今年继续在为 Rust compiler 做贡献，能回想到的一些事情是：</p><ul><li>参与了一个播客的录制 <a href="https://rusttalk.github.io/podcast/007/">于康的 Rust 贡献之旅 – RustTalk</a>。</li><li>参加了第三界 Rust Conf，做了一个主题为  <a href="https://www.bilibili.com/video/BV11X4y1q7Lm/?spm_id_from=333.337.search-card.all.click">Learning by Contributing to Rust Compiler</a> 的演讲。</li><li>成功申请 Rust Foundation 2023 Follows 的资助，算是一个开源副业。</li><li>今年大概完成 70 来个 PR，大多数时候还是做一些小改进，很多时间花在了这个 <a href="https://github.com/rust-lang/rust/pull/117867">New attribute macros format for diagnostic structs</a> 上。</li><li>机缘巧合和 compiler team 的 davidtwco 在深圳吃了个饭面基了一次，线上和更多社区成员沟通更多了，同时深感英语口语需要进一步提高。</li></ul><p>因为在 Cryptape 的工作涉及到其他一些 Rust 项目，所以参与到了一些，比如我们在改造交易池的过程中用到了 <code>multi_index_map</code> 这个数据结构，顺带完善了一些不足 <a href="https://github.com/lun3x/multi_index_map/pull/23">Non-unique index support, capacity operations, performance improvement</a> 。</p><p>作为技术人，能全职使用自己喜欢的编程语言工作是一个很大的幸运，希望能继续在 Rust 开源这条路上走得更远。</p><h2 id="阅读和写作"><a href="#阅读和写作" class="headerlink" title="阅读和写作"></a>阅读和写作</h2><p>2023 看书的时间也少了很多，回顾了一下很多书没有看完，但这些书看完后值得分享：</p><ul><li>《硅谷钢铁侠：埃隆·马斯克的冒险人生》，这就是那些改变世界的人吧</li><li>《失明症漫记》，似乎是重新回顾一遍疫情的场景<ul><li>如果我们亵渎生活的尊严，我们也就扭曲了理智；而人的尊严每天都会受到我们世界中权势者的侮辱；普遍的谎言已经替代了多元的真理；人一旦失去来自其他成员的尊重，他也就不再尊重自己。</li></ul></li><li>《作个闲人：苏东坡的治愈主义》，这书我估计我年轻的时候看不进去，现在看就觉得很好：<ul><li>人生如逆旅，我亦是行人</li><li>可以寓意于物，而不可以留意于物</li><li>一张琴，一壶酒，一溪云</li></ul></li><li>《走出戈壁》优秀的人在逆境中也能成长起来。</li><li>《了不起的盖茨比》也许是因为我先看了电影，所以再看书就满脑子小李子那样子，也许有的作品就不应该看电影。</li><li>《被讨厌的勇气》，一切烦恼都来自人际关系，让干涉你生活的人去见鬼，解决了一些我的日常困惑。</li><li>《哲学家们都干了些什么》，你思考过的很多问题，前人必然已经思考过了。</li><li>《夜晚的潜水艇》，这就是文笔好。我喜欢里面的《裁云记》<ul><li>值得人沉迷一生的事太多了。像你说的，每个洞穴都充满诱惑，难以取舍。我年轻时也在分岔处犹豫过。后来我才明白，不是所有洞口都陈列在那里，任人选择；有的埋伏在暗处：我一脚踏空，就一头栽了下来，到现在也没有落到底。</li></ul></li><li>《美国种族简史》</li><li>《高山下的花环》</li><li>《凤凰项目，一个 IT 运维的传奇故事》</li></ul><p>同样在写作上的时间就更少了，总结下来居然是 13 篇博客，勉强达到月更的节奏。</p><p>写作这件事情似乎停下来之后就容易长时间停顿。带孩子太耗精力算是一个借口，但我其实很是可以把一些日常的琐碎时间利用好来做这件事情的，只是确实犯懒了。</p><p>希望借这次写年终总结的劲头，把写作这件事情捡起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2023 年很快就要结束了，赶紧抓住这个冲动总结一下。今年对我来说有几个大的转变，从几个方面谈起：&lt;/p&gt;
&lt;h2 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h2&gt;&lt;p&gt;生活上最大的变化是我又有了
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Andriod 使用 Obsidian 的客户端</title>
    <link href="http://catcoding.me/p/obsidian-andriod-client-sync-git/"/>
    <id>http://catcoding.me/p/obsidian-andriod-client-sync-git/</id>
    <published>2023-09-19T09:16:22.000Z</published>
    <updated>2024-11-06T04:08:02.387Z</updated>
    
    <content type="html"><![CDATA[<p>上周末试着在 Andriod 上配置好了 Obsidian 的客户端，没想到还挺好用。<sub>如果你已经买了 Obsidian 的 sync 服务，并且一切用起来都挺好的，那就不用看我这篇介绍了。</sub></p><p>我折腾这个的主要的需求是使用私有仓库的 Git repo 来同步日记。为什么不买 <code>Obsidian sync</code>，我认为 Github 更符合我的使用习惯，并且我选择使用 Obisidian 的一个原因就是我不想把笔记数据同步到其他的第三方平台上，相对来说 Github 是我更信任的基础设施，毕竟我已经使用 Github 这么多年了。</p><h2 id="Andriod-客户端"><a href="#Andriod-客户端" class="headerlink" title="Andriod 客户端"></a>Andriod 客户端</h2><p>Obsidian 的安卓客户端好像没有在国内各个安卓软件市场上，你需要用过 Google play 来安装。</p><h2 id="Termux"><a href="#Termux" class="headerlink" title="Termux"></a>Termux</h2><p><a href="https://github.com/termux/termux-app#installation">termux/termux-app</a>  是一个 Andriod 上的终端模拟器，也是一个开源软件。基本上你可以把 Andriod 当作一个简化版本的 Linux 服务器来使用，<a href="https://www.sqlsec.com/2018/05/termux.html#Termux-%E7%AE%80%E4%BB%8B">Termux 高级终端安装使用配置教程</a> 是一个很详细的介绍文章。</p><p>注意目前 termux 已经不能在 Google Play 上安装了，你需要去 <a href="https://github.com/termux/termux-app/releases">Releases · termux/termux-app</a> 下 apk 安装包来手动安装。</p><p>termux 安装好之后就可以在 Andriod 手机上跑一个 Shell，打卡进去之后运行来创建一个叫作 <code>storage</code> 的目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">termux-setup-storage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来安装一些后面需要用到的依赖：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkg <span class="token function">install</span> <span class="token function">git</span>pkg <span class="token function">install</span> openssl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>用 <code>ssh-keygen</code> 来生成一对公钥和私钥，把公钥配置到自己的 Github 账户上，然后 clone 你的 Obsidian vault repo：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> storage/share<span class="token function">git</span> config <span class="token parameter variable">--global</span> credential.helper store<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"&lt;your_email>"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"&lt;The name you want on your commits>"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> pull.rebase <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>确保能在 Termux 上正确提交改动到 Github 上。如果有一些文件是不想同步到远程的，可以加入到<code>.git/info/exclude</code> 里，比如把 <code>.obsidian/workspace-mobile.json</code> 忽略了。</p><p>打开 Obsidian 的客户端，找到刚才 Git clone 的目录，打开作为 vault 即可使用。</p><h2 id="定时备份"><a href="#定时备份" class="headerlink" title="定时备份"></a>定时备份</h2><p>先安装 Termux 上的 cron 服务：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkg <span class="token function">install</span> cronie termux-services<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>然后退出 Termux 重新打开，运行：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sv-enable crond<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>运行 <code>crontab -e</code> 来创建一个定时备份的 job：</p><pre class="line-numbers language-none"><code class="language-none">*&#x2F;2 * * * * ~&#x2F;sync_repo.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每两分钟自动备份一次，我的 <code>sync_repo.sh</code> 是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">cd</span>  /data/data/com.termux/files/home/storage/shared/ob<span class="token function">git</span> <span class="token function">add</span> <span class="token parameter variable">-A</span> <span class="token operator">&amp;&amp;</span> <span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">"android backup: <span class="token variable"><span class="token variable">`</span><span class="token function">date</span> +<span class="token string">'%Y-%m-%d %H-%M-%S'</span><span class="token variable">`</span></span>"</span><span class="token function">git</span> pull<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> rebase <span class="token parameter variable">--continue</span><span class="token function">git</span> push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的同步脚本很粗暴，如果冲突了我会把冲突一起提交进去，但这也是合理的，因为我需要让自动同步尽量成功，至于冲突可以在笔记本上解决。如果 Termux 进程被杀了，自动备份将无法自动运行。但在我的日常使用过程中，这倒不是一个大问题。</p><hr><p>参考：</p><ul><li><a href="https://forum.obsidian.md/t/guide-using-git-to-sync-your-obsidian-vault-on-android-devices/41887">Using Git to sync your Obsidian vault on Android devices - Share &amp; showcase - Obsidian Forum</a></li><li><a href="https://gist.github.com/Makeshift/43c7ecb3f1c28a623ea4386552712114">Tutorial for automatically syncing an Obsidian vault with Git on an Android device</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周末试着在 Andriod 上配置好了 Obsidian 的客户端，没想到还挺好用。&lt;sub&gt;如果你已经买了 Obsidian 的 sync 服务，并且一切用起来都挺好的，那就不用看我这篇介绍了。&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;我折腾这个的主要的需求是使用私有仓库的 Git 
      
    
    </summary>
    
    
      <category term="Obsidian" scheme="http://catcoding.me/tags/Obsidian/"/>
    
      <category term="Git" scheme="http://catcoding.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>读《走出戈壁》</title>
    <link href="http://catcoding.me/p/out-of-the-gobi/"/>
    <id>http://catcoding.me/p/out-of-the-gobi/</id>
    <published>2023-09-13T23:55:58.000Z</published>
    <updated>2024-11-06T04:08:02.387Z</updated>
    
    <content type="html"><![CDATA[<p>最近读了单伟建的《走出戈壁》，作者是个著名的金融家、投资人。我对这位作者不熟悉，但看完后觉得非常好，所以推荐给大家。</p><p>这本书记录了作者从小时候的经历、年轻时的知青生活、美国求学的回忆，算是一部回忆录。原版是用英文写作的《Out of the Gobi: My Story of China and America》，但中文版据说不是直接翻译过来，而是很多部分重新用中文写出。我猜还有一些英文版的内容如果翻译过来，那这本书就不能出版了。</p><p>知青下乡的书我看过一些，最早的时候是偶然发现家里有一本叶辛写的《蹉跎岁月》，所以就看了起来。那个年代于我这种 80 后而言很陌生，但小说中人物的某些心理特征对那时候的我来说很熟悉，比如羞涩和自卑等。这本书我后来又陆陆续续看了几遍，里面也有些爱情心理的描述，算是我看得比较投入的第一本小说，所以至今仍然印象深刻。</p><p>王小波也写过不少关于知青岁月的文章，那个年代里每个人都背负时代的枷锁，出身和成分很大程度上决定了人的命运，大部分人因为十年的浩劫失去了接受教育的机会。</p><p>有些自传和回忆类的书读起来会有点自吹自擂的感觉，而这本书里作者用了一种看似云淡风轻、带着些许幽默的口吻写成，而细节很丰富，阅读中仍会让人感到戈壁凌冽的北风，那样的生活真是太苦了。</p><p>一群年轻人被放在了戈壁滩上，总得找事情去让他们去做做，完成自我的”改造“，日常生活就是饥肠辘辘地”修理地球“。里面有不少这类事情，让人很辛苦地去做完而结果看起来没什么意义，比如部队让大家去挖土豆，结果挖出来又没开车去收，大部分又烂在了地里；比如让大家去修土壕，然后无止境地半夜做演习，结果少部分人被埋死在了土壕里。</p><p>这样折腾几次之后，大部分人都会“看破红尘”，开始随大流地磨洋工，而作者的心态是”干什么事都要干好，否则闲着也是浪费时间，而且争强好胜，虽然身体瘦弱，但不甘人后，如此而已。“ </p><p>没什么英文资料可读，就反复看药品说明书里的英文单词。积极认真的工作态度，抓紧时间学习一切东西，因为这些他才能后来被推举成为工农兵大学生。一个让我印象深刻的是他处理人际关系的方法，当遭受到他人的算计时，并未过多抱怨他人，而是认识到这本就是人性中存在的恶，然后从自己的角度去尝试解决这些问题。他开始了一个广结人缘的计划，还能用一些看起来很隐蔽的方法，比如让父亲寄书过来学着当排球裁判，让更多其他连的人认识他。能站在旁观者的视角审视自己和周遭处境，并找到解决办法，这对于一个 20 岁左右的年轻人来说是非常难的。</p><p>作者在前两年的大学生推举中仍被刷下去了，大致是因为和领队的关系不够密切。这两次对作者来说是很大的打击，所以抗搓能力非常重要，即使非常难过也得在人面前保持平静：</p><ul><li>📌 漫无边际地走，一边走，一边放声大哭。</li><li>📌 那天晚上，我很晚才回到宿舍。我告诫自己，不能放弃，无论受到多大的挫折，都不能放弃，放弃就是对自己的犯罪。我必须坚持下去，继续努力，等待下一次机会。</li></ul><p>所以说，那个时代的大学生，不是纯考试的，但能通过群体推举去上大学生，绝对是非常不简单的人。经历过那个年代的苦之后，以后什么学习上的苦都是不足挂齿了。作者上大学之后，学习和成长的速度都是惊人的，10 年间从一个戈壁知青做到了藤校的副教授级别。他到了美国之后在两三周之内就能说服校方和教授，为自己定制了一个特殊的学习路径，并在两年内拿到硕士学位：</p><ul><li>📌 我承认，美国体制的灵活性对于我来说是如鱼得水。在国内的体制下，当初上大学有如登天，几乎没有自由选择的权利。</li><li>📌 在最心灰意冷的时候，我反复提醒自己，自我放纵就是对自己的犯罪。基于这个信念，我从未放弃，而是坚持不懈地努力，刻苦读书，才有了今日。</li></ul><p>其中的一个感人的故事，教授夫妇发现作者很想拿一个学位而且学习能力强，但是没有足够多的钱来应对学业开销，所以就谎称说有人匿名资助了他，其实就是教授夫妇自己资助了他。我猜想也许是因为作者赶上了新中国第一波留美学习的时机，不少人对他们是有好奇心态的，或者是“自助者天助之”。</p><p>还有一个小故事说明作者深谙体制里那套规则，并且做事很有智慧，他是通过基金会的一个留学考察项目去美国的，所以读硕士学位其实并不在计划内的：</p><blockquote><p>后来我明白了为什么亚基会的官员们不热心，他们担心如果为我破例的话会影响基金会与外贸学院的关系。安迪表示，他要给外贸学院的领导写一封信，征求北京的意见。</p><p>我说你不能这么写，他问我为什么。我说，如果你征求北京方面的意见，他们就要研究是否批准。只有两个可能——批准或者不予批准。批准了当然好，但是如果不予批准，我怎么办？安迪问我还有更好的办法吗？我说有，你就给北京发个贺电，说我学习成绩优异，校方决定给我奖学金，只需延期一个学期，就可以获得硕士学位，对于这样的成绩，亚基会向外贸学院表示祝贺，其他的都不必说。</p><p>安迪将信将疑地接受了我的建议，草拟了一封电报，赞扬了我，把我的成绩归功于外贸学院的领导知人善任，表示祝贺。两周后，安迪打来电话，说外贸学院回电了。“怎么说？”我焦急地问。他停顿了一下，说：“只有四个字——‘非常感谢’。”我心花怒放。</p><p>正如我所料，谁能拒绝别人的道贺呢？后来，外贸学院的领导还专门给我写了一封信，对于我在美国的学习成绩表示满意，鼓励我再接再厉，早日拿到学位。</p></blockquote><p>看这本书的过程中，我会想起自己最努力的初中时光。那是我第一次读寄宿，学校的物质条件也很贫乏，每次下完课去吃饭都得百米赛跑，不然自己的饭就会被瓜分掉。另一个深刻的印象是冷，热水也总是需要抢。生活虽然清苦，但那几年我开始感受到学习和思考的乐趣，上自习做到半夜也不觉得累，我当时觉得几何证明题目很有趣，第二天早上五六点又会爬起来去教室里早读。回想起来，我后来再也没那么专心和努力过了。</p><p>匮乏和苦难也许真能磨砺人，在那样的大环境下如何生存，在逆境中保持乐观、有所成长，这本书里所描写的是绝大部分人无法做到的。可以修改一下长者那句话：一个人的命运啊，当然要考虑到历史的进程，主要还是靠自我奋斗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近读了单伟建的《走出戈壁》，作者是个著名的金融家、投资人。我对这位作者不熟悉，但看完后觉得非常好，所以推荐给大家。&lt;/p&gt;
&lt;p&gt;这本书记录了作者从小时候的经历、年轻时的知青生活、美国求学的回忆，算是一部回忆录。原版是用英文写作的《Out of the Gobi: My 
      
    
    </summary>
    
    
      <category term="阅读" scheme="http://catcoding.me/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
