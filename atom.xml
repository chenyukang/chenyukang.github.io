<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyukang.github.io/"/>
  <updated>2021-12-07T07:59:58.480Z</updated>
  <id>http://chenyukang.github.io/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Obsidian 插件开发</title>
    <link href="http://chenyukang.github.io/2021/12/02/obsidian-plugin-dev.html"/>
    <id>http://chenyukang.github.io/2021/12/02/obsidian-plugin-dev.html</id>
    <published>2021-12-02T07:17:37.000Z</published>
    <updated>2021-12-07T07:59:58.480Z</updated>
    
    <content type="html"><![CDATA[<p>昨天花了点时间下学习 Obsidian 的插件开发。我想了一下目前自己有点不爽的是图片插入的时候，图片的名称中间有空格，这虽然也不是什么大问题，只是在 Linux 环境下显示的时候看起来特别别扭。而且这看起来也是一个很好的入门小插件，可以接触 Obsidian 里面的文件管理和编辑操作，我需要把图片在文件系统里的名称改掉，也要修改 markdown 里的路径。</p><p>所有代码都在这里了： <a href="https://github.com/chenyukang/obsidian-rename-image" target="_blank" rel="noopener">chenyukang/obsidian-rename-image (github.com)</a>。</p><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li>从 plugin sample repo 克隆一个仓库</li><li>修改其中的 manifest.json 文件，其中 plugin id 是最重要的。</li><li>修改主文件 main.ts，使用 <code>npm install</code> 安装依赖库</li><li>使用命令 <code>npm run dev</code>  编译出 main.js </li><li>在 Obsidian  的 vault 目录 .obsidian/plugins/ 创建一个插件名称的文件夹，拷贝 manifest.json  和 main.js 到该目录，有的插件可能还有 style.css 等文件。</li><li>在 settings 页面加载插件</li></ol><p>在开发过程中，可以通过 <code>Ctrl-Shift-i</code> 来打开调试页面，在代码中加入调试信息。</p><h3 id="API-相关"><a href="#API-相关" class="headerlink" title="API 相关"></a>API 相关</h3><p>在插件项目里执行了 <code>npm install</code> 之后，文件 <code>node_modules/obsidian/obsidian.d.ts</code> 就是 Obsidian 的 API ，里面有很详细的注释。</p><p>作为补充可以看看 <a href="https://liamca.in/Obsidian+API" target="_blank" rel="noopener">Obsidian API - Liam Cain</a>。API 分为这几个主要部分。</p><p><img src="/images/ob_pasted-image-20211201194355.png" alt="/images/ob_pasted-image-20211201194355.png"></p><p>其中文件编辑部分使用了这个<a href="https://codemirror.net/" target="_blank" rel="noopener">CodeMirror</a>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>之前有那么一会我会想，Obsidian 这样一个软件为什么不开源？如果开源我们是不是可以做更多的自由探索。通过折腾插件这么一段体验，我认为不开源问题也不大，其实通过插件我们其实可以在插件里面跑任何自己的代码。这里面的可扩展性对于绝大部分用户来说绰绰有余。</p><p>一个技巧是多看看已有的插件是如何实现的。打开 Settings 页面的 community plugins，选择某个感兴趣的插件看看里面的代码：<br><img src="/images/ob_pasted-image-20211203110506.png" alt="/images/ob_pasted-image-20211203110506.png"></p><p>Obsidian 模块化做得很好，而且 API 的粒度很细。在 VsCode 中写 TypeScript 插件体验比在 Emacs 中写 elisp 开发插件好很多，并且 JavaScript 的相关文档可太丰富了。</p><p>所以，真没必要抱着上古时代的软件不放 😁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天花了点时间下学习 Obsidian 的插件开发。我想了一下目前自己有点不爽的是图片插入的时候，图片的名称中间有空格，这虽然也不是什么大问题，只是在 Linux 环境下显示的时候看起来特别别扭。而且这看起来也是一个很好的入门小插件，可以接触 Obsidian 里面的文件管
      
    
    </summary>
    
    
      <category term="工具" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="obsidian" scheme="http://chenyukang.github.io/tags/obsidian/"/>
    
      <category term="TypeScript" scheme="http://chenyukang.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Sidecar 架构模式</title>
    <link href="http://chenyukang.github.io/2021/12/01/sidecar-design-pattern.html"/>
    <id>http://chenyukang.github.io/2021/12/01/sidecar-design-pattern.html</id>
    <published>2021-12-01T07:17:38.000Z</published>
    <updated>2021-12-07T07:59:58.480Z</updated>
    
    <content type="html"><![CDATA[<p>如果你最近经常看一些技术型的文章，可能会看到这个技术名词：Sidecar 模式。中文译名为：挎斗模式。这个名字为直译，挎斗就是这样的一种摩托车：</p><p><img src="/images/ob_2021-11-30-12-57-48.png" alt="/images/ob_2021-11-30-12-57-48.png"></p><p>如果理解了这种模式，就会明白这个名字其实取得特别好。Sidecar 模式就是指在原来的业务逻辑上再新加一个抽象层。这种模式很好的印证了那个计算机的名言：</p><blockquote><p> “计算机科学领域的任何问题都可以通过增加一个简介的中间层来解决。”</p><p>“Any problem in computer science can be solved by another layer of indirection.”</p></blockquote><p>如果一个抽象层不够，那来两个。这种模式也不是近些年新发明的，我们可以理解 Nginx 的反向代理其实也算一种 sidecar 模式。只是近些年，随着微服务和容器化在实践中越来越多，这种模式的使用范围也更广了。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在微服务架构中，如果应用多了就会形成一些共有的需求。特别是流量控制方面，包括限流、流量分发和监控、灰度等等。通常我们对一类需求可以实现一个抽象层，然后在这个抽象层上实现具体的业务逻辑。比如很多公司都有服务网关，然后使用各种语言的 SDK 来集成到应用中。</p><p><img src="/images/ob_pasted-image-20211130163700.png" alt="/images/ob_pasted-image-20211130163700.png"><br>这是通常我们会选择的一种方式，这过程中会有这样的一些问题需要考虑：</p><ol><li>SDK 的维护成本是很高</li><li>SDK 集成到代码中，其中一个组件发生故障就可能会影响到其他组件，SDK 和应用程序之间是保持着相互依赖的关系的。</li></ol><p>在应用层和基础服务没有解耦的情况下，我们对基础服务做改动会增加很多风险和复杂度。例如，我之前所在的部门整个电商的应用做灰度改造，所有应用都需要做对应的改动。</p><h2 id="sidecar-架构"><a href="#sidecar-架构" class="headerlink" title="sidecar 架构"></a>sidecar 架构</h2><p>那我们是否可以提供一个统一的抽象层来做这些基础的重复工作？将基础服务抽象、解耦到应用层都感知不到的程度？</p><p>这是现在的趋势，特别是现在很多架构都跑在容器这样的环境了，统一的抽象层能大大减少架构上的复杂度。 sidecar 模式在不改变主应用的情况下，会起来一个辅助应用，来辅助主应用做一些基础性的甚至是额外的工作。这个 sidecar 通常是和主应用部署在一起，所以在同样的运行环境下。这其中还有一些性能上的考虑，sidecar 如果和主程序网络通信上有延迟就会造成性能问题。例如在 K8s 下一个 pod 里的所有子应用共享一个 sidecar 服务。</p><p>这个辅助应用不一定属于应用程序的一部分，而只是与应用相连接。这就像是挎斗摩托车，每个摩托车都有自己独立的辅助部分，它随着主应用启动或停止。因为 sidecar 其实是一个独立的服务，我们可以在上面做很多东西，例如 sidecar 之间相互通信、或者通过统一的节点控制 sidecar ，从而达到 Service Mesh。</p><p><img src="/images/ob_sidecar-mode-20211130170923.png" alt="/images/ob_sidecar-mode-20211130170923.png"></p><p>这样的好处在于：</p><ol><li>应用层和基础服务层解耦</li><li>基础服务统一维护，SDK 统一集成，减少复杂度，减少应用服务中的重复部分</li><li>可以在不改变原有应用的情况下，为应用扩展新的功能</li></ol><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>我们可以来看看业界典型的使用 sidecar 模式的框架。</p><h3 id="DAPR"><a href="#DAPR" class="headerlink" title="DAPR"></a>DAPR</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/architecture/dapr-for-net-developers/dapr-at-20000-feet" target="_blank" rel="noopener">Dapr: Distributed Application Runtime</a> 是微软开源的一套分布式程序开发框架，其目标是：“Build distributed applications with any language, any framework, run anywhere”。既然任何编程语言，任何框架都要支持，sidercar 是一个必然的选择。DAPR 把很多常见的分布式程序的公共组件抽象出来成为’building blocks’，然后通过 gRPC 或者 HTTP 统一出接口。应用程序通过 sidecar 来访问。</p><p><img src="/images/ob_pasted-image-20211130172044.png" alt="/images/ob_pasted-image-20211130172044.png"><br>这样多了一层抽象之后，即使是某个 Component 做了一些改变，应用层也是无感知的。除了在容器化的环境下运行，用户也可以在非容器化环境以 sidecar 模式启动任何应用，例如我们启动一个图片接口服务 <code>image-api-service</code>，该服务会监听端口 8080，而 sidecar 会通过 3500 端口来代理该服务接受请求：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dapr run --app-id image-api \</span><br><span class="line">         --app-protocol http \</span><br><span class="line">         --app-port 8080 \</span><br><span class="line">         --dapr-http-port 3500 \</span><br><span class="line">         --components-path ../config \</span><br><span class="line">         --<span class="built_in">log</span>-level debug \</span><br><span class="line">         ./image-api-service</span><br></pre></td></tr></table></figure><p>其他服务组件可以通过 sidecar 去请求该服务：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dapr api format: http://localhost:&lt;daprPort&gt;/v1.0/invoke/&lt;appId&gt;/method/&lt;method-</span></span><br><span class="line">uri = <span class="string">"http://localhost:3500/v1.0/invoke/image-api/method/api/image"</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">"POST"</span>, uri, bytes.NewBuffer(image))</span><br></pre></td></tr></table></figure><h3 id="lstio"><a href="#lstio" class="headerlink" title="lstio"></a>lstio</h3><p><a href="https://istio.io/latest/zh/about/service-mesh/" target="_blank" rel="noopener">Istio 服务网格</a> 是一个开源的服务网格，提供了统一的方式来实现连接、监控、负载均衡等公共服务和流量管理。单个服务的所有传入和传出网络流量均通过 Sidecar 代理，完成微服务之间的流量管理、遥测数据收集以及策略的执行等。</p><p><img src="/images/ob_pasted-image-20211130173530.png" alt="/images/ob_pasted-image-20211130173530.png"></p><p>在 lstio 中，我们需要了解 Data Plane 和 Control Plane 两个概念——  </p><ul><li>Data Plane 的作用是处理网格内服务间的通信，并完成服务发现、负载均衡、流量管理、健康检查等功能；数据平面的作用是处理网格内服务之间的通信，并负责实现服务发现、负载平衡、流量管理、健康检查等功能；</li><li>Control Plane 的作用是管理和配置 Sidecar 来执行策略并收集遥测</li></ul><p>lstio 中使用了 Lyft 开源的 Envoy 来做流量代理，Envoy 和应用程序一起在一个独立的进程中运行，应用与 localhost 收发信息，对网络的拓扑结构无感知。</p><h2 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h2><ul><li>更适合在容器化的环境使用</li><li>简单系统就没有必要使用这种重型武器了</li><li>哪些部分可以放到 sidercar 里面需要慎重考虑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你最近经常看一些技术型的文章，可能会看到这个技术名词：Sidecar 模式。中文译名为：挎斗模式。这个名字为直译，挎斗就是这样的一种摩托车：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ob_2021-11-30-12-57-48.png&quot; alt=&quot;/image
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="架构" scheme="http://chenyukang.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>在 Github Action 使用 Git</title>
    <link href="http://chenyukang.github.io/2021/11/30/using-git-in-github-action.html"/>
    <id>http://chenyukang.github.io/2021/11/30/using-git-in-github-action.html</id>
    <published>2021-11-30T07:17:46.000Z</published>
    <updated>2021-12-07T07:59:58.484Z</updated>
    
    <content type="html"><![CDATA[<p>最近我把自己的一些自动化脚本移到了 Github Action。因为考虑到 Github Action 有下面几个优势：</p><ol><li><p>自动化脚本是代码的一部分 (Infrastructure as Code)，而不是限定在某个服务器上。这样长久来说更为通用，如果我迁移到其他服务器根本不用做什么修改，因为我们在写 Github Action 的脚本的时候就不假定在哪台服务器上运行。</p></li><li><p>配置更为方便，想要修改一下只需要提交配置文件就可以了，不用登录到服务器上。</p></li></ol><p>基于以上几点考虑，我花了一些时间来把之前的一些 Ruby、Shell 脚本变成 Github Action 配置。有的脚本做的事情是定时拉去某个 repo，如果有改动则会根据规则生成新的内容，然后自动提交到远程仓库。所以我需要在 Github Action 中使用 Git 提交数据。要达到这个目的得在 Github 中配置 Git 的权限和账户信息。有以下两种方式：</p><h2 id="使用-Github-Access-token"><a href="#使用-Github-Access-token" class="headerlink" title="使用 Github Access token"></a>使用 Github Access token</h2><p>首先需要在 Settings 页面生成一个 Access Token. 然后添加到要配置 Github Action 的仓库的 Settings 页面中，假设我的 token 取名为<code>PAT</code>，在 Action 中我们可以通过 <code>secrets.PAT</code> 获取和使用该 Token。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  sync-to-sites:</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Git</span> <span class="string">Clone</span> <span class="string">and</span> <span class="string">Global</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # Git setup</span></span><br><span class="line"><span class="string">          export GITHUB_USER=yukang</span></span><br><span class="line"><span class="string">          echo "GITHUB_USER=$GITHUB_USER" &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string">          echo "GITHUB_TOKEN=$<span class="template-variable">&#123;&#123; secrets.PAT &#125;&#125;</span>" &gt;&gt; $GITHUB_ENV</span></span><br><span class="line"><span class="string">          git config --global user.email "moorekang@gmail.com"</span></span><br><span class="line"><span class="string">          git config --global user.name $GITHUB_USER</span></span><br></pre></td></tr></table></figure><p>然后通过如下方式 clone 要修改的 repo 到跑 action 的服务器目录上。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">checkout</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">  uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line"><span class="attr">  with:</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="string">chenyukang/blog-source</span></span><br><span class="line"><span class="attr">    token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PAT</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">blog-source</span></span><br></pre></td></tr></table></figure><p>这种通过 Access Token 的方式 clone repo，用的是 HTTPS 的方式。通过 <code>git remote -v</code> 查看可以看到 remote 的地址。</p><h2 id="使用-SSH"><a href="#使用-SSH" class="headerlink" title="使用 SSH"></a>使用 SSH</h2><p>另外一种方式是通过 ssh key。我们首先在任何一个服务器生成一个 ssh key，把这个 ssh 的 public key 加入到 Github settings 里。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>然后把私钥拷贝到要配置 Action 的 repo 的 secrets 里。</p><p>通过如下方式在 action 中配置 ssh：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Install</span> <span class="string">SSH</span> <span class="string">Key</span></span><br><span class="line"><span class="attr">  uses:</span> <span class="string">shimataro/ssh-key-action@v2</span></span><br><span class="line"><span class="attr">  with:</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_KEY</span> <span class="string">&#125;&#125;</span> </span><br><span class="line"><span class="attr">    known_hosts:</span> <span class="string">'just-a-placeholder'</span></span><br></pre></td></tr></table></figure><p>这样之后就可以在 Action 的后续步骤中像在本地一样使用 SSH 的方式来 clone repo 和提交代码了。<br>通过 ssh key 的方式我们也可以在 Github Action 中通过远程的方式来在其他服务器上执行命令，这对于要部署到服务器上的脚本来说是非常有用。</p><p>具体可以参考这篇文章： <a href="https://zellwk.com/blog/github-actions-deploy/" target="_blank" rel="noopener">Deploying to a server via SSH and Rsync in a Github Action | Zell Liew (zellwk.com)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近我把自己的一些自动化脚本移到了 Github Action。因为考虑到 Github Action 有下面几个优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自动化脚本是代码的一部分 (Infrastructure as Code)，而不是限定在某个服务器上。这样长久来说更为通
      
    
    </summary>
    
    
      <category term="工具，Github" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CGithub/"/>
    
  </entry>
  
  <entry>
    <title>自动补全算法</title>
    <link href="http://chenyukang.github.io/2021/11/29/input-complement-algorithm.html"/>
    <id>http://chenyukang.github.io/2021/11/29/input-complement-algorithm.html</id>
    <published>2021-11-29T08:34:43.000Z</published>
    <updated>2021-12-07T07:59:58.476Z</updated>
    
    <content type="html"><![CDATA[<p>周末在和一个日本小伙一直讨论一个 Obsidian 的 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin" target="_blank" rel="noopener">补全插件</a>，经过一个周末的努力，最终这个插件完善了不少。</p><p>我主要想用这个插件来补全英文输入，这个插件目前没有自带的词典。我在互联网上搜索了一圈，最终在 Github 上找了这个 <a href="https://github.com/first20hours/google-10000-english" target="_blank" rel="noopener">Google 10000 English</a>，也就是最长使用的搜索单词。</p><p>实际上，前 7000 个英语单词覆盖了日常的 90% 使用场景。</p><h3 id="中文输入"><a href="#中文输入" class="headerlink" title="中文输入"></a>中文输入</h3><p>首先我碰到的问题是，输入中文的时候插件也在补全英文。然后我提了第一个 issue。作者很快就回复了，给了我一个开发版本尝试，很完美的修复了这个问题。<br><img src="/images/ob_pasted-image-20211128185804.png" alt="/images/ob_pasted-image-20211128185804.png"><br>然后在使用过程中发现另一个小问题，比如我的字典里面有 <code>apple</code>，但是如果我是在句子头部输入 <code>Ap</code> ，这个单词并没有出现在补全列表。我们当然可以把字典的单词都进行首字母大写的处理，但是这就会让字典翻倍。</p><p>我看了看源码，果然如自己猜想的那样，匹配的时候没有考虑首字母大写的问题。我花了一些时间做了一个 PR：<a href="https://github.com/chenyukang/obsidian-various-complements-plugin/commit/935d7de1633b9a7685349a97302a0e908e10b215" target="_blank" rel="noopener">fix issue #30, take care of uppercase </a>。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>在我做上个修复的时候，也顺便修复了一个性能上的问题，看这个补全插件的核心算法如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">function suggestWords(words: Word[], query: string, max: number): Word[] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(words)</span><br><span class="line">    .filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x.value !== query)</span><br><span class="line">    .map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (caseIncludesWithoutSpace(x.value, query)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">word</span>: x, <span class="attr">value</span>: x.value, <span class="attr">alias</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> matchedAlias = x.aliases?.find(<span class="function">(<span class="params">a</span>) =&gt;</span></span><br><span class="line">        caseIncludesWithoutSpace(a, query)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (matchedAlias) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">word</span>: x, <span class="attr">value</span>: matchedAlias, <span class="attr">alias</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">word</span>: x, <span class="attr">alias</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x.value !== <span class="literal">undefined</span>)</span><br><span class="line">    .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> aliasP = (<span class="built_in">Number</span>(a.alias) - <span class="built_in">Number</span>(b.alias)) * <span class="number">10000</span>;</span><br><span class="line">      <span class="keyword">const</span> startP =</span><br><span class="line">        (<span class="built_in">Number</span>(lowerStartsWith(b.value!, query)) -</span><br><span class="line">          <span class="built_in">Number</span>(lowerStartsWith(a.value!, query))) *</span><br><span class="line">        <span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">const</span> lengthP = a.value!.length - b.value!.length;</span><br><span class="line">      <span class="keyword">return</span> aliasP + startP + lengthP;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.word)</span><br><span class="line">    .slice(<span class="number">0</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中如果词典列表很长，这里的 <code>filter</code>, <code>map</code>, <code>filter</code> 会遍历列表三次，是很耗时的操作。我把第一个 filter 干掉了。然后在匹配逻辑里面增加了首字母大写的相关的 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/commit/2b3990af4b4e19198833e1deb0a8783fcd45a60e#diff-25a6634263c1b1f6fc4697a04e2b9904ea4b042a89af59dc93ec1f5d44848a26" target="_blank" rel="noopener">处理</a>。除了自定义的单词词典，这里补全的候选词来源包括当前文件内容、Obsidian 的内部链接。而链接需要进行部分匹配进行补全。</p><p>后续在使用过程中我又觉得补全有些慢，甚至会影响输入的体验，在 Obsidian 里面通过 <code>Ctrl+Shift+I</code> 可以打开调试面板，我们可以看到补全的耗时：</p><p><img src="/images/ob_pasted-image-20211128193253.png" alt="/images/ob_pasted-image-20211128193253.png"></p><p>这里的主要问题还是因为每次输入一个字母，算法都在遍历单词列表两边。优化思路有两条：</p><ol><li>使用类似桶排序的思路，把单词按照首字母进行分割，分成 26 个子列表，这样查找的时候就先根据首字母找到子列表，然后进行遍历搜索。</li><li>使用类似 Trie Tree 的数据结构进行前缀匹配。</li></ol><p>后来那个作者按照第一种思路进行了 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/commit/f6e047d479b57f3dd2171ce5eaa1c1f7692c91ad" target="_blank" rel="noopener">优化</a>，很快将补全时间优化到了 0~5 ms。果然粗暴的算法其实很多时候就够了。</p><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><p>在日常使用过程中，我又发现了还存在这个 <a href="https://github.com/tadashi-aikawa/obsidian-various-complements-plugin/issues/34" target="_blank" rel="noopener">问题</a>。如果我尝试去修改中文句子的某个部分，这个插件会补全当前句子，就像这样：</p><p><img src="/images/ob_pasted-image-20211128194301.png" alt="/images/ob_pasted-image-20211128194301.png"><br>这当然是完全没有意义的。我看了一下代码发现是没有进行中文分词，所以现在的补全把这个中文句子当作一个连续的字符串在补全。</p><p>我自己尝试这想做一个 PR，但是没找到合适的中文分割 JavaScript 库。Obsidian 不能使用 Node 的库（移动端方面的考虑），所以也就不能使用这个 <a href="https://github.com/yanyiwu/nodejieba/blob/master/README_EN.md" target="_blank" rel="noopener">NodeJieba</a>。虽然还没完成这个分词功能，不过我也在这个过程中学着写了点 TypeScript。</p><h3 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h3><p>这个看似简单的功能，如果要做到日常可用其实有很多细节需要完善。这个算法问题看起来不难，很适合用来进行面试。这是日常中很常见的一个需求场景，而且优化这个算法思路也可以很开放。</p><p>TypeScript 真强，虽然我只是简单用了一下，一些常见的 JavaScript 错误比如 enum 忘记补全之类的问题都能找出来。<a href="https://www.electronjs.org/" target="_blank" rel="noopener">Electron</a> 真猛，VSCode、Obsidian、Slack 这类工具都是 Electron 开发的。</p><p>开源软件的好处在于很多代码的作者对自己的成果有一种成就感，所以会想办法来完善，而用户也可以帮着来想办法。在这个过程中，不仅可以让其他人受益，自己也得到了一些学习和提高😘。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周末在和一个日本小伙一直讨论一个 Obsidian 的 &lt;a href=&quot;https://github.com/tadashi-aikawa/obsidian-various-complements-plugin&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://chenyukang.github.io/tags/Tools/"/>
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="Obsidian" scheme="http://chenyukang.github.io/tags/Obsidian/"/>
    
  </entry>
  
  <entry>
    <title>打造自己的工具 - Obweb</title>
    <link href="http://chenyukang.github.io/2021/11/28/intro-to-obweb.html"/>
    <id>http://chenyukang.github.io/2021/11/28/intro-to-obweb.html</id>
    <published>2021-11-28T07:00:04.000Z</published>
    <updated>2021-12-07T07:59:58.476Z</updated>
    
    <content type="html"><![CDATA[<p>在文章<a href="http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html">我的知识管理工具和经验</a>中我介绍了自己开发的 Obsidian 配合 Web 应用 <a href="https://github.com/chenyukang/obweb" target="_blank" rel="noopener">obweb</a>。</p><p>下面详细介绍一下自己对每个功能的使用场景，以及其中的一点技术细节。后端使用 <code>Rust</code> 开发的，因为后端逻辑并不复杂，所以使用什么语言区别不大。我最近在练手 <code>Rust</code>，所以就用了 <a href="https://github.com/seanmonstar/warp" target="_blank" rel="noopener">Warp</a> 这个框架来实现。</p><p>我是一个前端新手，顺便借这个项目在学习一些 JavaScript 和 Svelte 相关的技能。第一次实现的时候是纯 HTML 加 JQuery，后来又加上了 Svelte 。Svelte 这个前端框架对新手来说也不难，我是边看教程边照着做的。</p><p><img src="/images/ob_pasted-image-20211127144951.png" alt="/images/ob_pasted-image-20211127144951.png"></p><p>Obweb 是一个典型的前后端分离的 Web 应用，没什么技术上的难度。可忽略直男的 UI 设计(貌似根本无设计😂)，我们着重看看我日常用的这些功能。</p><h2 id="想法记录"><a href="#想法记录" class="headerlink" title="想法记录"></a>想法记录</h2><p>这是我做 Obweb 的初衷，我想在手机端把一些想法和灵感记录下来。之前一直使用 [[flomo]] 这款应用，这个应用功能很少，就是让你打开记录想法，但是会使用标签来把这些想法串联起立。随着我使用 Obsidian 的时间越来越多，我就想把这些数据同步到自己的 Obsidian 中。</p><p>这个界面很简单，就是一个输入框，可以加入标签或者 Link。但是这里面隐藏了一些逻辑：</p><ul><li>如果 Link 为空，这个记录则为一个每日的想法，会追加在每天的 Daily 文件后</li><li>如果 Link 是 Todo，则会在我的 Todo.md 在文件头部增加一个记录。 </li><li>如果 Link 是一个其他的文件名，如果数据中没有这个文件则会创建，否则就会在现有的文件后追加这条记录。这种使用场景是我在手机上看 Kindle，有的摘抄就会记录下来，最终每一本书阅读后摘抄就会在一个文件里面。这也是为什么这个 Link 除非手动清除，否则会一直记录在 localStorage 里面。因为一段时间内我看的都是一本书。如果要清除缓存则可以使用 <code>Reset</code> 按钮。</li></ul><p>可以在想法中加上图片，但是限制只能加一张。因为我习惯了使用这个记录页面之后，我也想在 PC 端使用。因此增加了从剪切板中存储图片的功能，以方便我在 PC 端想同步一些内容到手机上以备后续查看。</p><p><img src="/images/ob_pasted-image-20211127133255.png" alt="/images/ob_pasted-image-20211127133255.png"></p><h2 id="每日回顾"><a href="#每日回顾" class="headerlink" title="每日回顾"></a>每日回顾</h2><p>想法中记录的内容，可以使用 <code>Day</code> 来回顾，目前只有按照日期每日来回地切换。如果要大量地查阅内容我肯定使用 PC 端。这里也可以进行一些轻度编辑。</p><p><img src="/images/ob_pasted-image-20211127134715.png" alt="/images/ob_pasted-image-20211127134715.png"></p><h2 id="搜索和编辑"><a href="#搜索和编辑" class="headerlink" title="搜索和编辑"></a>搜索和编辑</h2><p>我在手机端使用场景主要记录想法，但也有一定的查阅需求。比如我在外面办事可能需要看公司的保险需要哪些材料，这些我都会截图或者记录下来。所以，搜索是刚需。</p><p>目前搜索使用的就是粗暴的关键词匹配，我感觉已经够用了。后续可能可以增加分词等复杂一些的逻辑。作为程序员，文件中的代码高亮肯定是需要支持的，使用 <code>highlight.js</code> 就好了。</p><p><img src="/images/ob_pasted-image-20211122123826.png" alt="/images/ob_pasted-image-20211122123826.png"></p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><p>Todo 也是一个 Markdown 格式的文件，而且这个文件只有记录了创建这个 todo 项的时间。我养成习惯每天早上都会看一看然后选择一些 todo 干掉。虽然目前很简陋，看起来就像是一个备忘录而已。对我来说也是足够了，我没有很多细小的事情需要赶 deadline。</p><p><img src="/images/ob_pasted-image-20211127135356.png" alt="/images/ob_pasted-image-20211127135356.png"></p><h2 id="RSS-阅读"><a href="#RSS-阅读" class="headerlink" title="RSS 阅读"></a>RSS 阅读</h2><p>我已经有一段时间没有使用 RSS 阅读器了，其中一个原因是我没找到合适的安卓客户端。可能 IOS 上能找到一些精美的 RSS 阅读器，越来越多的人对 RSS 阅读不感兴趣了，国内的很多人使用公众号或，知乎，或者很多空闲时间用来看抖音了。国外很多人继续使用 Newsletter 的形式来订阅，内容创作者也喜欢让你通过邮件订阅，因为邮件订阅是一种双向的关系，他也可以通过邮件联系你，这样后续就可以推广产品之类的。所以说 RSS 是反商业的模式，通过 Feed 订阅似乎成为怀旧行为。</p><p>互联网上还是有很多独立博客，他们不是为了商业利益，纯粹是为了自己的爱好和分享精神，坚持写一些高质量的内容。在没找到合适的工具的情况下，我自己实现了一个简单的 RSS 爬虫，和这个 RSS 阅读界面。爬虫部署在我的服务器上，每隔几十分钟就会遍历我的订阅列表，抓取内容推送到 Github 私人仓库。服务端的爬虫使用的数据库是 <code>SQLite</code> 来存储文章的其他一些元数据。</p><p>有的作者 RSS feed 里面只提供摘要。为了营造沉入式的阅读感受，我尝试把文章的内容都抓取过来，包括图片也会拷贝一份到我自己的服务器上。这样每一篇文章打开都是全文，而不是摘要。</p><p><img src="/images/ob_pasted-image-20211122123722.png" alt="/images/ob_pasted-image-20211122123722.png"></p><p>我最近发现一个新的使用场景，这种里面带有  Podcast 的语音内容，在开车时候打开听很方便。</p><p><img src="/images/ob_pasted-image-20211123171216.png" alt="/images/ob_pasted-image-20211123171216.png"></p><h2 id="后续的改进"><a href="#后续的改进" class="headerlink" title="后续的改进"></a>后续的改进</h2><p>因为现在使用 RSS 阅读的时间越来越多了，后面可能会继续优化 RSS 阅读的一些细节。另外前端代码现在比较乱，后面会继续学习一些前端技能，把代码优化得更优雅简洁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在文章&lt;a href=&quot;http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html&quot;&gt;我的知识管理工具和经验&lt;/a&gt;中我介绍了自己开发的 Obsidian 配合 Web 应
      
    
    </summary>
    
    
      <category term="工具，Obweb" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7%EF%BC%8CObweb/"/>
    
  </entry>
  
  <entry>
    <title>我的知识管理工具和经验</title>
    <link href="http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html"/>
    <id>http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html</id>
    <published>2021-11-23T00:21:58.000Z</published>
    <updated>2021-12-07T07:59:58.480Z</updated>
    
    <content type="html"><![CDATA[<p>知识管理是近些年出来的逼格称呼，通俗点说就是写笔记或者写作，讲究一点可以说成“打造第二大脑”，英文中可以诗意地称之为 “Digital Garden”。看看，同样一个事怎么说出来格局完全不同了。</p><p>近两年笔记软件这个领域出现了两个很重要的创新：</p><p>一个是双向链接，开山鼻祖是 <a href="https://roamresearch.com/" target="_blank" rel="noopener">Roam Research</a> ，一个是一切皆对象和可无限嵌套的设计，也就是 <a href="https://www.notion.so/" target="_blank" rel="noopener">Notion</a>。</p><p>因为这两个大方向上的微创新，现在笔记类软件和系统百发齐放，这是真是最好的时代了。</p><p>作为程序员我分享一下自己在这类工具上的使用经验、感受以及建议。</p><p>大概十多年前，还在学校的时候，博客文化刚兴起，所以很多记录类的东西我都写在博客里了。那些常见的博客系统我基本都用过，后来很多都倒闭了。当然 Wordpress 现在在非程序员中都非常流行。</p><p>后来很长一段时间我都是用 Evernote ，国内版本叫做印象笔记。用的人多了各种周边的工具也非常多，比如浏览器插件之类的。这类笔记软件也非常多。</p><p>三四年后我又渐渐不使用印象笔记了，因为我用了很多年 Emacs，所以偶然尝试了 org-mode。这东西结合 GTD 可玩的方式可太多了。 org-mode 日程管理，日志，文档都在本地，一切都是纯文本的 org 格式，我通过 Github 来做数据存储。一切都是文本并且本地化就可以自动化，我可以自己写一些脚本，自己定义各种模板等等。虽然是纯文本的格式，我也可以很方便地到导出成 PDF , 甚至是做演示。很多人是为了使用 org-mode 才一直用 Emacs，我也曾经认为自己找到了以后一直用的记录工具和方式。</p><p>在这段时间，我养成的一个很好的习惯是使用  Github 来存储自己的数据。Github 已经成为最基础的互联网设施，我信任这个平台胜过其他服务。Joe Armstrong 在去世前一年，把自己的文章迁移到 Github，感兴趣的可以看看这篇不错的文章 <a href="https://laike9m.com/blog/people-die-but-long-live-github,122/" target="_blank" rel="noopener">People Die, but Long Live GitHub</a>。</p><p>后来，我因为换工作的原因不怎么使用 Emacs了。最近一年工作内容变了，自己日常开发和业务时间使用 Windows 更多。业余时间基本是用的 WSL ，配合 VsCode 日常开发体验很棒。 而 Emacs 在 Windows 上使用体验很不好，我也没找到合适的移动端解决方案。虽然最近 WSL 也支持 Linux Gui 了，但我已经懒得折腾，因为我已经离不开 VS Code 。</p><p>我需要重新找一个笔记类工具，我的需求是：</p><ol><li>本地存储文件</li><li>足够的自定义</li><li>支持 Markdown</li><li>支持双向链接</li></ol><p>这个需求其实满足了绝大部分程序员用户，一个文件夹加 Typora 估计都差不多了，但是我觉得双链这个设计确实有一些价值，所以也变成刚需了。</p><p>在摸索的过程中我试过 Notion，Wolai，Logseq，Obsidian。</p><p>Notion 确实有耳目一新的感觉，而且 UI 的审美很好，用户做出来的笔记可以很美观整洁。而内嵌 Database 可以打造出来很多好玩的东西，甚至可以用来做站点。缺点是服务器在国外，不太稳定。</p><p>Wolai 提供 Notion 类似的块编辑以及大部分功能，而且很早就有双链接，服务器在国内所以速度上也很快。版本更新很快，有很多针对中文用户的细节优化。如果不想折腾用 Wolai 也挺好的。Wolai 和 Notion 是比较重的工具，已经超过了通常我们理解的笔记管理软件的范畴。</p><p>Logseq 是 Roam Research 的模仿品，但是提供本地存储的方式，也有桌面版软件。很多人赞赏 Roam Research ，不过我没有觉得这种方式完全适合我。 Roam Research 的正常方式是每天都在日志页面记录，然后写的过程中加上适合的链接，这样你的文档渐渐构成一个网络。如果你日常中经常用到的概念，自然就会经常被链接，那么就会是网络中的一个密集点。所以即使你不建文件目录，这种文档之间的关系也会自然而然形成，并且比目录这种单线的关系更符合直觉。</p><p><img src="/images/ob_pasted-image-20211120225233.png" alt="/images/ob_pasted-image-20211120225233.png"></p><p>最终我一直保持使用的是 Obsidian。Obsidian 支持本地存储数据的方式（也可选择付费远程同步）。我使用一个 Git 的插件自动同步到 Github。Obsidian 的客户端做得如此出色，而且扩张性极好，已经形成很成熟的插件生态。这是我的记录汇成的网状。</p><p><img src="/images/ob_pasted-image-20211120225329.png" alt="/images/ob_pasted-image-20211120225329.png"></p><p>在使用 Obsidian 一段时间后我又体验了 Flomo，这是一个不错的软件让我们迅速把日常的想法记录下来。我想如果 Flomo 的数据能够同步到 Obsidian 就好了。</p><p>看了一下 Flomo 的接口，我觉得干脆还不如自己动手重新实现来练练手。我就动手自己实现了一个 Web 单页应用 <a href="https://github.com/chenyukang/obweb" target="_blank" rel="noopener">obweb</a>，然后部署在自己的服务器上。这个应用提供一个简单的页面来记录日常的想法，文字或者图片都能迅速提交。数据提交后同步到 GitHub。这个 SPA 页面可以内嵌在微信浏览器，所以使用体验和一个小程序差不多。</p><p>而后我又增加了搜索的接口，这样我所有 Obsidian 的数据都可以在手机端检索和查看，而且我也能做一些简单的编辑。实际使用下来这真的比一个独立的手机应用更方便。</p><p>最近我又新增了一个 Rss 阅读的功能，后台会自动根据我的订阅列表抓取 Feed，甚至会尝试把网页和图片都下载下来，这样即使是一些”内网”不能直接访问的文章也可以在手机端无障碍阅读。</p><p>在这个过程中我学会了 svelte 这个前端框架和 Rust 写服务端接口这些东西。虽然我的 UI 设计和前端技能简直就是渣渣，但是这就是完全贴合我的使用习惯的软件，我可以做到所有细节的定制化。</p><p><img src="/images/ob_pasted-image-20211123190603.png" alt="/images/ob_pasted-image-20211123190603.png"></p><p>这是一种渐进式的开发体验，每隔一段时间我会在使用过程中摸索一个需求，然后我会稍微等一等，如果这个需求还是存在并且我考虑好了如何实现，我就会加上去。</p><p>折腾这么多年这类软件后，我的感受是工具的使用都是非常私人化的选择，作为程序员我们有能力使用自己的技术来定制化工具来提高效率。最近看到这篇文章 <a href="https://www.swyx.io/make-your-own-tools/" target="_blank" rel="noopener">You’re Allowed To Make Your Own Tools</a> 很好的阐述了这个观念。这就像是住房子一样，如果你自己是设计师，估计不会满足房地产商提供的统一装修，而是根据自己的喜好和习惯来重新设计。房子也不是越富丽堂皇就越好，简单但实用即可。</p><p>所以在文档和写作这块，数据本地纯文本的方式是对程序员更好的方式，你可以自己写程序来处理这些数据，而不是完全依靠软件或者第三方的功能。比如这篇文章就是我在陪小孩上课的过程中，用手机在 obweb 上敲出来，服务器上的脚本会自动转成 Hexo 文件，提交发布到我的博客。</p><p>最后，我们现在有很多华丽的工具来用，也要避免让自己变成一个纯粹信息的收藏者。’数字花园’不是一股脑地往后院搬东西就行，需要花时间精心打理和修剪。工具并不能本质地解决问题，难的是日复一日坚持记录自己的想法和理解，整理知识。柳比歇夫使用纸和笔记录了自己奇特的一生，并且完成大量研究工作。</p><p>记录的过程并不是学习本身，而是思考。通过记录这种形式，把自己的理解写下来促进思考，才能产生最大的价值。</p><hr><p>题外画:</p><p>一个有趣的事是，除了 Roam Research 和大厂的传统产品，目前兴起的这些笔记类软件和服务大多是中国人开发的，包括 Notion、Obsidian、Logseq 等。我们可能真的比较喜欢这类东西，“好记性不如烂笔头” 乃民族真传。</p><p>另一个事实，Roam Research，Logseq，以及另外一个开源的类似产品 <a href="https://www.athensresearch.org/" target="_blank" rel="noopener">Athens Research</a> 都使用了 Clojure 这门编程语言来实现。Clojure 作为一门 JVM 上的 Lisp，其热度还没进过前 30 吧。这门语言对于数据处理这样的项目是比较合适的，只是不太适合大团队使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识管理是近些年出来的逼格称呼，通俗点说就是写笔记或者写作，讲究一点可以说成“打造第二大脑”，英文中可以诗意地称之为 “Digital Garden”。看看，同样一个事怎么说出来格局完全不同了。&lt;/p&gt;
&lt;p&gt;近两年笔记软件这个领域出现了两个很重要的创新：&lt;/p&gt;
&lt;p&gt;一
      
    
    </summary>
    
    
      <category term="工具" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发" scheme="http://chenyukang.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>最好的学习是输出</title>
    <link href="http://chenyukang.github.io/2021/09/07/learning-by-contribute.html"/>
    <id>http://chenyukang.github.io/2021/09/07/learning-by-contribute.html</id>
    <published>2021-09-07T21:49:24.000Z</published>
    <updated>2021-12-07T07:59:58.480Z</updated>
    
    <content type="html"><![CDATA[<p>之前我设想如果有了足够多时间，会做这些事：到处逛逛，锻炼英文写作，​投入到开源社区中。最近一年有了一些空余时间来做这些。我通常是十点到公司，下午五点半左右到六点之间离开公司。晚上陪小孩，洗漱哄睡完毕之后大概是九点钟。所以每天早上、晚上，加上周末，我都有一段时间可以用来自己安排。</p><p>​这半年时间我参与了好几个开源项目，基本是顺着自己感兴趣的领域来的：</p><ol start="0"><li><p>3 月左右，微软有个 FHL(Fix/Hack/Learning) 活动，基本有两周左右时间可以做自己感兴趣的项目，或者是学习点什么技术。那段时间我在琢磨怎么下好五子棋，因为和老婆经常比赛赌输赢。所以我写了个程序来下五子棋 <a href="https://github.com/chenyukang/gomoku" target="_blank" rel="noopener">gomoku</a>，顺便学了一些技术相关的，比如 Rust，WebAssembly，Azure function，monte carlo，minimax 算法等。可能是我很久没从头到尾写个项目的原因，这个项目写得很来劲，顺便掉入 WebAssembly 的坑里。</p></li><li><p>接触到了 WebAssembly 发现有些意思, 所以看了很多相关的内容。然后我参与到了 wamser.io。这是一个 Rust 写的 WebAssembly Runtime，还包括各种语言的 SDK 之类的。我开始从一些简单的 <a href="https://github.com/wasmerio/wasmer/pulls?q=is%3Apr+author%3Achenyukang+is%3Aclosed" target="_blank" rel="noopener">PR 到一些 Bug 修复</a>。通过这些投入我大概也熟悉了这个项目的代码。这个项目 Star 数目虽然有1W+，但是其实日常维护者已经只有两位了，其背后是一个公司在支撑。这公司之前是在 YC 孵化的，但是据我观察是没找到合适的商业化途径。当年 Docker 是找不到合适的盈利方式，所以最终选择开源。不过短短几年，现在这些技术型创业公司，基本都是默认开始干开源的，比如那些开源数据库之类的项目。</p></li><li><p>帮 <a href="https://github.com/WasmEdge/WasmEdge" target="_blank" rel="noopener">WasmEdge</a> 做了一些和 <a href="https://dapr.io/" target="_blank" rel="noopener">Dapr</a> 的集成 Demo，花了大概两周的业余时间来学习 Dapr 和 WasmEdge 相关的技术，最终完成项目 <a href="https://github.com/second-state/dapr-wasm" target="_blank" rel="noopener">dapr-wasm</a>。这也是我第一次尝试收费帮人做开源，虽然不多但是也算是个不错的开头。既能赚钱又能学点新东西，何乐不为。</p></li><li><p>玩了一段时间 K8S 和 Linkerd 之后，我对容器相关技术又有一些兴趣。仍然记得 2014 年刚接触到 Docker 时的震撼，所以我想看看容器到底是怎么做的。后来找到了 Rust 实现的 Container Runtime <a href="https://github.com/containers/youki" target="_blank" rel="noopener">youki</a>。这个项目主要是一群日本年轻人在开发，项目发起人还是 96 年的。真是后生可畏! 我陆陆续续大概提交了十来个 PR，主要是改进一些测试脚本、参考 runc 来实现一些功能，通过容器的基准测试等。在 discord 偶尔和项目发起者聊聊天，交流一些中日的 IT 相关感受也挺有意思。贡献了<a href="https://github.com/containers/youki/pulls?q=is%3Apr+author%3Achenyukang+is%3Aclosed" target="_blank" rel="noopener">几个 PR</a> 之后，他邀请我成为项目的 maintainer。我觉得这是一个很好的锻炼、提高自己的机会，所以就欣然接受了。其实容器底层都是一些什么权限管理，namespace，cgroup，file system 等基于操作系统的抽象层做了隔离，跑起来就是进程而已。在开发容器的过程中，有时候会把自己的 Host OS 搞跪，所以最好是在 wsl 或者 VM 里面开发。</p></li><li><p>最近在使用 Rust 过程中，发现 lint 会重复报告某些提示。经过搜索发现已经有人提出了同样的问题。我曾经好几次尝试过看看 Rust 的源码，但一直没沉下心有所得。这个 Bug 看起来并不难排查，也许是一个很好的契机。我花了大概几个小时时间从理解 lint 相关的逻辑，到复现这个 Bug，找到代码里的问题，然后做出一个初步修复。这个过程中，感觉比较困难的是编译一次 Rust 代码库大概需要半个小时，跑测试则需要更久。另外通过 gdb 虽然可以调试代码，但是还是有某些限制。提交了 PR 之后才只是开始，后来又经过了一周多时间和子模块维护者讨论更细节的问题，来回 20 多 comments 才最终完成了<a href="https://github.com/rust-lang/rust/pull/88493" target="_blank" rel="noopener">修复</a>。</p></li></ol><p>从 2011 年开始使用 Github，这些年一直在 Github 上做一些自己的开源小项目。只有最近大半年才比较多地参与到一些大的开源项目。这个过程收获很多。</p><p>最好的学习方式是贡献和输出。不管是在公司、或者是在开源社区做出贡献才是技术的价值。看书、看资料能学会一些，但是只有实践才能提高自己的能力。比如我学 Rust，肯定不花时间去看 Rust quiz 之类的东西，因为日常开发中常用到的语言特性并不是那些细节。很多领域更重要或者更有价值的是领域知识，编程语言在使用过程中不懂再去看就行了。</p><p>有了足够的业余时间，以及纯粹的爱好，才静下心来持续投入到免费的开源中。996 肯定是不行的。做开源很多人都是在 “用爱发电”。很多开发者大多是有一份本职工作，做开源也算是眼望星空吧。但是确实因为热爱，所以代码质量反而比公司代码高。工作中看多了十多年的历史代码，看点优秀的开源代码有洗眼效果。</p><p>Github 现在开始在某些国家支持 <a href="https://github.com/sponsors" target="_blank" rel="noopener">Sponsor</a> 项目，可是中国不在试用范围内。我认为这是一个很好的趋势，做开源的程序员如果创造出来价值，应该得到一些资金上的支持。这使得有些程序员可以为了自己的项目，依赖这些资金全职投入到开发中，比如 <a href="https://github.com/sponsors/cart" target="_blank" rel="noopener">Bevy 的作者</a>，来不及等到筹集 7000 美金一个月的筹款就辞职投入了。</p><p>在投入到开源的过程中，除了自己能力的提升，也可以获得精神上的满足感。即使修复是一个小问题，其他人也会因为自己的投入而受益。而因为开源以及其带来的共同协作模式，程序员的学习、生产资料都极大丰富。这真是个好时代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前我设想如果有了足够多时间，会做这些事：到处逛逛，锻炼英文写作，​投入到开源社区中。最近一年有了一些空余时间来做这些。我通常是十点到公司，下午五点半左右到六点之间离开公司。晚上陪小孩，洗漱哄睡完毕之后大概是九点钟。所以每天早上、晚上，加上周末，我都有一段时间可以用来自己安
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="Rust" scheme="http://chenyukang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>案例分析-程序员如何站着赚钱</title>
    <link href="http://chenyukang.github.io/2020/10/27/programmer-out-of-normal-job.html"/>
    <id>http://chenyukang.github.io/2020/10/27/programmer-out-of-normal-job.html</id>
    <published>2020-10-27T21:57:00.000Z</published>
    <updated>2021-12-07T07:59:58.480Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://twitter.com/dvassallo" target="_blank" rel="noopener">Daniel Vassallo</a> 是我最近一年都在关注的一个推特用户，我几乎看了他发的所有 Twitter 和文章。</p><p>这位程序员去年离开了亚马逊的一份轻松而多金的工作。他在亚马逊干了 8 年，尽管不断获得晋升、薪酬、表彰和表扬等奖励，薪水从 7.5w 刀一路涨到 50w 刀，但他没有足够的动力再干一年。</p><p>至于为什么离开亚马逊，他写了一篇很好的文章来解释：<a href="https://danielvassallo.com/only-intrinsic-motivation-lasts/" target="_blank" rel="noopener">只有内在动力才能持续</a>.</p><p>主要原因是随着级别的提高，工作的自由度减少了，得平衡各方利益，说服其他人来完成特定的目标。这很正常，在大公司工作有很多固有的限制，关于如何做工作，做什么工作，设定什么目标，以及什么业务值得追求。很多时候会迫使我们去做不想做的事情，而想做的可能也无法施展。</p><p>总之，在公司赚钱肯定是比较稳定，收入也不错。只是时间、精神上谈不上自由。为大公司工作是一种稳定的状态，就像是围城一样。</p><p>如何站着把钱挣了？</p><h2 id="什么动力才能持久？"><a href="#什么动力才能持久？" class="headerlink" title="什么动力才能持久？"></a>什么动力才能持久？</h2><p>动力分为<em>外部动力</em>和<em>内部动力</em>：</p><p>外部动力可以称之为棒子或者萝卜。举例来说，缴税是棒子，虽然我们不想做，但是必须得完成。为了买一辆豪车，努力加班加点赚钱，这就是萝卜。两者都是外在因素迫使我们不断地有『动力』去执行。</p><p>内部动力是持久动力，就是自己心甘情愿去做，并且乐于其中。这位程序员的兴趣在于写代码，卖自己的作品。而互联网时代就是最好的舞台，个人可以专注于自己专业领域，完成自己的作品，并获取关注和收入。当然最重要的是作品的质量，以及推销的手法。</p><h2 id="找到自己的切入点"><a href="#找到自己的切入点" class="headerlink" title="找到自己的切入点"></a>找到自己的切入点</h2><p>通过自己的作品来赚钱，听起来很简单，但实现起来难度其实是巨大的。</p><p>辞职后开始做的一个项目叫做 <a href="https://userbase.com/" target="_blank" rel="noopener">Userbase</a>， 为静态网站增加持久化存储。另外开始和朋友做的是一本电子书：<a href="https://gumroad.com/l/aws-good-parts/dv" target="_blank" rel="noopener">The Good Parts of AWS</a>。售价25美金一份。10个月总共花费 3w 多美金推广，收入 25w 美金。</p><p><img src="/images/image-20201030073721363.png" alt="image-20201030073721363"></p><p>这本电子书包含一些经验性的东西，对基于 AWS 做技术架构的人挺有用的。对于在 AWS 上工作了10多年的人写出这样一本小册子肯定是不难的，但是难的是如何做推广。</p><p>这也是作者做得挺好的一点，在 Twitter 上经营固定的读者。他每天都会发一些作为 Indie 的一些感想，关于工作、生活、经济、创业方面的。14 个月时间从 150 的 follower 涨到了 49000 多。他经常会把一些自己项目的数据贴出来给大家分享，这样显得特别真实、真诚。这种推广套路营造出一种类似《楚门的世界》的观感效果，读者看着他从第一天辞职，然后不断经营自己的项目，就会有动力一直去关注后面的进展。</p><p>然后作者把自己最近一年左右的 Twitter 推广实践经验又录成了视频： <a href="https://gumroad.com/l/twitter-audience/dv" target="_blank" rel="noopener">Everyone Can Build a Twitter Audience</a>， 售价 50 美金。这一连贯手法真是越来越溜了。</p><p>当然，除了营销外之外能力是最重要的，这位同志的写作能力一流。可以从第一篇辞职撰文可以看出，用词、表达清晰有据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有人可能认为，这赚得看起来还没他自己上班多啊！</p><p>但是，为自己工作的自由度、成就感、安全感是完全不同的，而且这还只是一个开始。</p><p>很多人丢掉了自己的全职工作之后，完全不知道如何打造自己的另外一份收入，陷入等米下锅的状态。总结起来都是很简单的道理，只是做到的人很少：</p><ul><li>跳出自己的舒适区，向自己期望的生活方式改变</li><li>找到自己的兴趣点和优势，寻找自己能满足的实际需求</li><li>相信时间的复利效应，做有积累的事情</li><li>付费意识还是挺重要的，这点不可否认英文环境相对来说会更好一些</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://twitter.com/dvassallo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Daniel Vassallo&lt;/a&gt; 是我最近一年都在关注的一个推特用户，我几乎看了他发的所有 Twitter 和文章。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DHH - 关于软件开发的少数派</title>
    <link href="http://chenyukang.github.io/2020/10/10/dhh-on-software-dev.html"/>
    <id>http://chenyukang.github.io/2020/10/10/dhh-on-software-dev.html</id>
    <published>2020-10-10T22:50:38.000Z</published>
    <updated>2021-12-07T07:59:58.476Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/" target="_blank" rel="noopener">David Heinemeier Hansson, Software Contrarian</a> 是 Podcast 频道 corecursive 在 2020.2.1 发布的一个 DHH 关于软件开发相关的访谈。</p><p>DHH 不用介绍了，Rails 创始人。</p><p>可以说之前 Ruby 的流行很大程度上依赖于 Rails 的兴起。Rails 确实影响了很多后来的 Web 框架的设计和实现，并给软件开发带了一些全新的理念。</p><p>这期是我之前当作练习英语的材料来听的。DHH 的口音非常清晰，表达方式也是非常直接。因此这期听起来有一种类似 Rap 的快感。</p><p><img src="/images/2020_10_01_dhh-software-contrarian.org_20201009_220930.png" alt="file:img/2020_10_01_dhh-software-contrarian.org_20201009_220930.png"></p><h2 id="为什么-Rails-成功了"><a href="#为什么-Rails-成功了" class="headerlink" title="为什么 Rails 成功了"></a>为什么 Rails 成功了</h2><p>Rails 的出现改变了软件开发，至少在 2006 年，当 Java，C# 大行其道的年代。Rails 以其优异的开发效率震惊了不少开发者。Rails 的成功无非是在恰好的时机做了恰当的事情。</p><p>DHH 总结了从 Java、PHP 的开发经验。Java 阵营里都是聪明人，有很多好想法，但是他们却在一个糟糕的开发环境里工作，不容易让新人轻易上手。而 PHP 却很简单明了，你直接把一个文件拖入特定的文件夹，就可以生成对应的网页。Rails 的第三个元素就是 Ruby，Ruby 是极其容易安装，容易上手而直接的编程语言。DHH 当时正在写 Basecamp，所以一切都是从实际使用出发的，自己构建工具，然后再用这个工具构建 Basecamp。</p><p>而且 DHH 当时也是一个 Ruby 新手(那时的 Ruby 老手估计也没几个?)</p><p>新手的好处在于，他不知道 Ruby 的极限在哪里，哪里可能面临挑战。这样可以随着自己的性子，满足自己的期望来构建 Rails 了。在写 Rails 的过程中，DHH 更关注的是作为用户的感受是什么？编程就像是做菜一样，厨子需要关注的色香味俱全。</p><p>Ruby 最大的洞见是: 程序员不仅仅是程序员，同时也是人。</p><p>依据这个原则，在设计 Ruby 中最重要的事情和设计标准就是：编程语言使程序员更快乐。</p><h2 id="最开始如何开始接触-Ruby"><a href="#最开始如何开始接触-Ruby" class="headerlink" title="最开始如何开始接触 Ruby"></a>最开始如何开始接触 Ruby</h2><p>Ruby 是日本人 Matz 于 1995。但是直到 2003，这门编程语言仍然是非常小众而神秘的。DHH 也是那段时间在看到些 Martin Fowler 和 Dave Thomas 写的技术文章，他们俩个都选择了 Ruby 作为编程语言介绍一些概念。这引起了 DHH 的兴趣，所以开始关注 Ruby，并去参加了 Ruby 2004 Conf。</p><p>那届 Conf 大约也就 42 人吧….</p><p>但是随后几年的 Rails Conf 就开始有 2500 人了。</p><h2 id="关于编程语言的选择"><a href="#关于编程语言的选择" class="headerlink" title="关于编程语言的选择"></a>关于编程语言的选择</h2><p><strong>很多程序员因为喜欢上编程，就是刚好碰到了符合自己口味的编程语言，并激发对编程的巨大乐趣</strong>。所以，语言的选择说不重要也不对。如果你还没找到自己的最爱，继续尝试吧。</p><p>但并不意味着，在一个小众的编程语言过多投资可能会带来其他的回报。语言的流行有很多其他的因素。Rails 的初衷并不是完全用来满足自己的创造轮子的快感的，而是依据自己的实际项目出发的。</p><p>这给我们的不错启示：从实际的需求出发，使用新的工具造轮子。</p><h2 id="关于微服务的吐槽"><a href="#关于微服务的吐槽" class="headerlink" title="关于微服务的吐槽"></a>关于微服务的吐槽</h2><p>DHH 对微服务保持否定态度，认为业界这么流行微服务其实是有害的。</p><p>大多数情况下，一个人可以完全理解、部署的单一应用，比微服务更容易维护。</p><p>微服务的优势在于，如果团队足够地大，我们需要给开发者一些界限。</p><p>不要盲目地沿用大公司的套路，因为解决的问题不同！</p><h2 id="关于-TDD"><a href="#关于-TDD" class="headerlink" title="关于 TDD"></a>关于 TDD</h2><p>TDD 也是 Rails 社区很流行和推崇的，但是 DHH 其实对此并不太感冒。并不是 TDD 就能写出更好的，更健壮的软件。</p><p>事先写测试用例还是事后写并不重要，重要的是自动化测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Heinemeier Hanss
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络相关</title>
    <link href="http://chenyukang.github.io/2020/09/08/networking-notes.html"/>
    <id>http://chenyukang.github.io/2020/09/08/networking-notes.html</id>
    <published>2020-09-08T20:59:08.000Z</published>
    <updated>2021-12-07T07:59:58.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h1><p>分为递归解析和迭代解析</p><p><a href="https://blog.csdn.net/lycb_gz/article/details/11720247" target="_blank" rel="noopener">https://blog.csdn.net/lycb_gz/article/details/11720247</a></p><h1 id="APR-欺骗"><a href="#APR-欺骗" class="headerlink" title="APR 欺骗"></a>APR 欺骗</h1><p>ARP 欺骗是一种在局域网中常用的攻击手段，目的是让局域网中指定的（或全部）的目标机器的数据包都通过攻击者主机进行转发，是实现中间人攻击的常用手段，从而实现数据监听、篡改、重放、钓鱼等攻击方式。</p><h1 id="TCP-IP-报文长度和格式"><a href="#TCP-IP-报文长度和格式" class="headerlink" title="TCP/IP 报文长度和格式"></a>TCP/IP 报文长度和格式</h1><p>IP 头部信息：头部长度：通常 20 字节，有选项时更长，总共不超过 60 字节。IP 数据报长度：65535 字节。</p><p><img src="/images/networking.org_20190731_120051.png" width="70%" hegiht="70%" align="center"></p><p>TCP 协议，在传输层。特点：可靠性。通过连接管理（三握四挥），序列号，确认号，拥塞控制，重传控制来保证可靠性。头部长度：一般为 20 字节，选项最多 40 字节，限制 60 字节。</p><p><img src="/images/networking.org_20190731_120147.png" width="60%" hegiht="60%" align="center"></p><h1 id="TCP-最大报文长度-MSS"><a href="#TCP-最大报文长度-MSS" class="headerlink" title="TCP 最大报文长度 (MSS)"></a>TCP 最大报文长度 (MSS)</h1><p><a href="https://blog.csdn.net/codejoker/article/details/5437141" target="_blank" rel="noopener">https://blog.csdn.net/codejoker/article/details/5437141</a></p><p>TCP 提供的是一种面向连接的，可靠的字节流服务，TCP 提供可靠性的一种重要的方式就是 MSS。通过MSS，应用数据被分割成 TCP 认为最适合发送的数 据块，由 TCP 传递给 IP 的信息单位称为报文段或段(segment)。代表一个 TCP socket 的结构体 struct tcp_sock 中有多个成员用于确定应用数据被分割成最大为多大的数据块较为合适(最大报文段长度 MSS)。我们不难联想到，跟最大报文段长度最为相关的一个参数是网络设备接口的 MTU，以太网的 MTU 是 1500，基本 IP 首部长度为 20，TCP 首部是20，所 以 MSS 的值可达 1460(MSS 不包括协议首部，只包含应用数据)。</p><p>本地以太网中 MSS 为 1460 的说法并不正确，它还会动态变化，如果 IP 首部和 TCP 首部中出现选项，则 MSS 要相应的减小，一般 TCP 首部中会 有 12 字节的时间戳选项(外加两字节的填充选项)，这时的 MSS 就等于 1448。MSS 的主要作用是限制另一端主机发送的数据的长度，同时，主机本身也控制自己发送数据报的长度，这将使以较小 MTU 连接到一个网络上的主机避免分段。</p><h1 id="如果使用-TCP-希望传输一个复杂的对象应该怎么传输？"><a href="#如果使用-TCP-希望传输一个复杂的对象应该怎么传输？" class="headerlink" title="如果使用 TCP 希望传输一个复杂的对象应该怎么传输？"></a>如果使用 TCP 希望传输一个复杂的对象应该怎么传输？</h1><p>TCP 中的流是指流入进程或者从进程中流出的字节序列。所以向 Java/golang 等高级语言在进行 TCP通信是都需要将相应的实体序列化才能进行传输。</p><h1 id="TCP-IP-中如何解决粘包问题？如果一直传输数据怎么拆包"><a href="#TCP-IP-中如何解决粘包问题？如果一直传输数据怎么拆包" class="headerlink" title="TCP/IP 中如何解决粘包问题？如果一直传输数据怎么拆包?"></a>TCP/IP 中如何解决粘包问题？如果一直传输数据怎么拆包?</h1><p>应用层协议，不管是标准的还是自己定义的。“粘包”问题是伪问题。</p><p><a href="http://www.hchstudio.cn/article/2018/d5b3/" target="_blank" rel="noopener">http://www.hchstudio.cn/article/2018/d5b3/</a></p><p><a href="https://img.hchstudio.cn/TCP.gif" target="_blank" rel="noopener">https://img.hchstudio.cn/TCP.gif</a></p><h1 id="TCP-连接和断开的状态图"><a href="#TCP-连接和断开的状态图" class="headerlink" title="TCP 连接和断开的状态图"></a>TCP 连接和断开的状态图</h1><p>connect:</p><p><img src="/images/networking.org_20190802_115508.png" width="60%" hegiht="60%" align="center"></p><p>disconnect:</p><p><img src="/images/networking.org_20190802_115604.png" width="60%" hegiht="60%" align="center"></p><p>为什么 TCP 连接断开的时候要<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">进行四次握手</a>：</p><h1 id="TCP-四次挥手的-TIME-WAIT"><a href="#TCP-四次挥手的-TIME-WAIT" class="headerlink" title="TCP 四次挥手的 TIME_WAIT"></a>TCP 四次挥手的 TIME_WAIT</h1><p>时间段长为 2MSL（报文段最大生存时间）</p><ul><li>TIME_WAIT 存在的理由之一是尽可能护送最后的 ACK 达到对端，保证可靠地终止 TCP 链接。</li><li>假设 tcp 连接是： A(1.2.3.4:8888)——B(6.7.8.9:9999), 这就是一个 tcp 四元组。当 tcp 连接关闭后， 四元组释放。TIME_WAIT 存在的理由之二是新旧四元组互不干扰。</li></ul><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC（Remote Procedure Call）—远程过程调用 ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发分布式程序就像开发本地程序一样简单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS-域名解析&quot;&gt;&lt;a href=&quot;#DNS-域名解析&quot; class=&quot;headerlink&quot; title=&quot;DNS 域名解析&quot;&gt;&lt;/a&gt;DNS 域名解析&lt;/h1&gt;&lt;p&gt;分为递归解析和迭代解析&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.
      
    
    </summary>
    
    
  </entry>
  
</feed>
