<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员的喵</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://catcoding.me/"/>
  <updated>2023-08-12T15:00:30.121Z</updated>
  <id>http://catcoding.me/</id>
  
  <author>
    <name>yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>成功申请 Rust Foundation 2023 Fellows</title>
    <link href="http://catcoding.me/p/rust-foundation-fellows/"/>
    <id>http://catcoding.me/p/rust-foundation-fellows/</id>
    <published>2023-08-12T23:00:13.000Z</published>
    <updated>2023-08-12T15:00:30.121Z</updated>
    
    <content type="html"><![CDATA[<p>很高兴成功申请到 <a href="https://foundation.rust-lang.org/news/announcing-the-rust-foundation-s-2023-fellows/">Rust Foundation 2023 Fellows</a>，我认为自己投入到 Rust 之后运气很好，两次申请到开源上的资助，很幸运能够在 <a href="https://twitter.com/Cryptape">cryptape</a> 技术氛围这么好的环境里远程做开源项目。</p><p>也许是因为我践行了<a href="https://www.swyx.io/create-luck">创造运气</a>的方法：多做 + 多分享，所以顺便多分享一些其他想法。</p><p>三年前，我离职时不知道自己未来如何走技术路线，在国内很多职位都很卷，当时我对工作和环境都厌倦了，所以离职换了公司和城市。我在微软的岗位虽然是技术的，但做起来比较无聊，好在业余时间比较多。</p><p><a href="https://www.zhihu.com/question/502884696/answer/2296787480">闲暇能激发创造力</a>和保持动力，很感激前公司微软包容和良好的工作环境，在苏州的两年里我有时间和精力去找自己感兴趣的事情，我重拾了写作和开源，这让我的生活变得充实，又因为些巧合开始给 Rust 编译器做贡献，从中得到了很多乐趣和收获。</p><p>没想到后来逐渐走上了 Rust 开发这条路，再回想起来过程也算是漫长的了，从 2014 年开始接触 Rust 到如今完全以写 Rust 为生，从观望学习、业余投入、全职投入这个过程快 10 年了。回想起来我对编程语言的兴趣是从看 <a href="https://github.com/chenyukang/eopl">eopl</a>开始的，而再往前是因为 scheme，再往前是因为偶然用了 emacs，所以年纪越大越觉得这句话太对了：</p><blockquote><p>You can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. </p></blockquote><p>Rust 让我开启了一个正向循环，比较容易能在一些开源项目上做出贡献，能看到开源社区里面有很多其他和我类似经历的人。</p><p>Rust 社区里另一个吸引我的地方在于有很多乐于分享的技术人，我们可以从世界上这些优秀的工程师身上学习，比如最近我喜欢看 <a href="https://www.youtube.com/@jonhoo">Jon Gjengset</a>的频道，他一期直播就有 2、3 个小时，讲解得非常细致，涉及到的主题也非常宽泛，有分布式、Rust、算法、读博和生活上的体验等等。</p><p>当然长期做开源很难，只有真的热爱才能持久，而对喜欢做技术的人来说开源是可能会上瘾的。这一年多里，给 rustc 做贡献好像已经成了我的习惯，业余时间找个 issue 试着解决就像是玩一把游戏，所以我做的事情大多并不难，而只是需要时间和耐心。国外程序员的一大优势就是有空余时间，生活负担不大，并且有足够的耐心去做周期长的事情。</p><p>这些资助算是兴趣的副产物，这次 Fellow 项目的一个好处在于可以找 mentor 来指导自己，我还在尝试找打算做的具体领域。上次 Project Grant 让我尝试了些新鲜事，比如录制播客、在 Conf 上公开演讲，这些都是代码之外的一些体验：</p><ul><li><a href="https://rusttalk.github.io/podcast/007/">007. 于康的 Rust 贡献之旅 – RustTalk</a></li><li><a href="https://www.bilibili.com/video/BV11X4y1q7Lm/?spm_id_from=333.337.search-card.all.click">Learning by Contributing to Rust Compiler</a></li></ul><p>感觉上面的播客和演讲的内容大多差不多，打算以后会在博客里再写点技术细节相关的博文。</p><p>做得越多，越觉得自己还有好多东西需要学习，我算不上编程语言的专家，只是个业余的爱好者，希望能在接下来时间里有更大的成长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很高兴成功申请到 &lt;a href=&quot;https://foundation.rust-lang.org/news/announcing-the-rust-foundation-s-2023-fellows/&quot;&gt;Rust Foundation 2023 Fellows&lt;/a&gt;，
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>远程办公的体验</title>
    <link href="http://catcoding.me/p/remote-work/"/>
    <id>http://catcoding.me/p/remote-work/</id>
    <published>2023-08-06T11:15:47.000Z</published>
    <updated>2023-08-12T15:00:30.121Z</updated>
    
    <content type="html"><![CDATA[<p>我断断续续也有好几年的远程办公经历了，从疫情刚开始那会儿，我还在大疆工作，在家办公一个来月。2020 年下半年开始在微软，因为疫情那两年一直反反复复的，所以公司长期都是混合式办公，我通常每周会在家待两天，到了 2022 年大部分时间都是在家办公。目前在秘猿则是完全远程办公，我还从未去过公司办公室 :) 。</p><p>远程办公有好的方面，也有一些需要克服的困难，这篇文章我总结一下这方面的想法。</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>并不是所有团队都适合远程办公，因为有的岗位需要频繁交流，而面对面沟通肯定是会更高效的。就软件开发这行来说，如果公司要实施全远程办公，需要满足几个条件：</p><ul><li>有效的管理、分工和协助</li><li>员工有足够的自驱力</li><li>公司的 IT 支撑</li></ul><p>这些缺一不可，下面我稍微解释一下。什么是有效的管理，通常员工人数到了一定规模都会强调管理，然而很多公司做的是过程管理而不是结果管理，比如统计员工的加班时长，这是在衡量员工的上班过程，也许是因为没有更好的办法来衡量产出、或者是为了压榨员工，反正这就是一种管理上的失败。</p><p>远程工作本质来说就是放权，关注结果而非过程。就纯软件开发这行来说，工作结果是相对容易评价的，比如功能是否高质量地完成，方案和设计是否合理等，项目进度等等。</p><p>如果公司让员工远程办公，意味着相信员工能够自己管理好时间和进度，而公司也有合理地方式来验收结果。这要求员工有足够的自驱力，而且员工也对工作内容有足够的兴趣，如果一个人对工作内容没什么兴趣或者是排斥的，那远程的情况下就会更糟，因为人都是有惰性的。</p><p>远程最大的困难当然在于沟通，所以一个员工日常需要沟通交流的人数非常重要。通常一个小组就是日常协作的单元，15 个以内是相对可行的范围。对管理者而言可能是个更大的挑战，对 IC 来说日常沟通的人数通常是 4、5 个人以内。</p><p>另外公司的 IT 支撑很重要，如果工作中涉及到机密文件，而对应的 VPN 等工具不够完善，在家工作就会成为灾难。比如疫情开始那会儿，我的远程办公体验就非常不好，需要连入公司的网络才能访问某些文件，而且速度不稳定。微软的 IT 工具好用些，但连入生产环境和服务器之类的会非常麻烦，需要专门的另外一台笔记本来操作，用一台价值一万多的笔记本来专门连 VPN 确实很浪费，但这也可以理解，毕竟安全对于 ToB 的业务是更重要的事，只是日常带两台笔记本实在会很麻烦。秘猿的 IT 是专门为远程考虑过的，比如公司不提供办公设备，但会提供一些 IT 补助，员工可以用自己的设备来办公，代码都在 Github 上开源的，所以办公体验非常好。</p><h2 id="异步沟通"><a href="#异步沟通" class="headerlink" title="异步沟通"></a>异步沟通</h2><p>异步沟通需要时间去适应，也更适合我这样的偏向于文字交流的人。在不能得到及时反馈的情况下，就需要把一个事情尽量用简单直接的文字把事情写清楚，并且需要考虑到对方可能会缺失的信息。当然，实时的文字沟通也是很重要的，适当地交流工作之外的事情，可以和线下没见过的同事培养出默契和情感。</p><p>软件开发中要达成有效的异步沟通，写好文档尤为重要。这对很多开发人员来说是一个重要的挑战，相比而言程序员更想写代码而不是文字，但文字和图都是更大范围表达自己的工具，你可以写给同事看，也可能需要写给用户看。如果无法通过文字表达清楚，意味着还没想清楚，那用代码也无法表达清楚。</p><p>所以，有的公司在面试时会看看应聘者是否有 Blog，主要也是想看这个人有没有文字表达的习惯，以及能不能把事情写明白。</p><p>就工具方面，我觉得邮件是个很好的方式，但相对来说国外开发人员更适应邮件。Slack 和 Discord 也不错，但感觉  Discord 相对来说更实时些。文档协作工具比如 Notion、Office 365、飞书等都行，我认为只要能有协同编辑就好。</p><p>除了异步沟通之外，一些在线的会议也是非常有必要的，但不宜过长，而且最好在开始之前让参与的人都了解会议的主题和相关资料，这样会更有效率。</p><p>我认为自己完全适应了远程办公的阶段就是培养出用文字记录工作的时候，我每天在 Obsidian 上都会建一个当天的文本，按时间顺序记录自己做的什么事情，或者是参与的会中的一些要点。然后通过标签做一些标注，还有把 Todo 给汇总到固定的页面。我在开会之前都会用文字记录会上要谈的要点，也会把一些零散的感受记录下来。</p><h2 id="工作效率"><a href="#工作效率" class="headerlink" title="工作效率"></a>工作效率</h2><p>通常来说，一个人的有效办公时间是到不了 8 个小时的，所以在办公室里面一直耗着就是耗着，很多时候都在摸鱼耗时间，有的会议就是大家都在摸鱼。</p><p>远程办公可以更好地利用碎片时间，以我的感受来说，如果是办公室办公通常下班后我再也不怎么去思考工作上的事，因为上班和下班是有一个明显的界限的。但在远程办公模式下这个界限会很模糊，可能我这会儿在办公，一会儿下楼去取快递了，或者我需要去接孩子之类的。所以很多时候，虽然我不在屏幕前，但我也会脑海里在考虑些工作上的问题。我反而觉得这种情况下会有更多的想法冒出来，比如人在洗澡的过程中会迸发出新的想法，这是很多人都有的体验。</p><p>这也是我在做开源的过程中得到的一个体会，因为大项目的开发者会遍布各个时区，所以绝大部分时间都是异步沟通。如果我彻底理解了一个问题，我就可以离开屏幕，随后时不时地去考虑这个问题了，等有了想法再回到屏幕前继续。</p><p>当然，在和他人讨论的情况下也可能会冒出想法，但总体而言群体讨论主要是为了达成共识，而更多好的想法是个体产生的。</p><p>在家办公一个影响效率的因素是环境，调皮的孩子可能是一个工作上的干扰，但我觉得问题不大，这也需要和孩子协调好。有时候我晚上思维更清晰、效率更高，因为晚上没人打扰，自由安排的情况下我可以更多地利用高效率时间工作，所以我在远程办公的情况下效率倒更高点。</p><p>对于大公司而言，整体来说远程办公的总体效率估计还是有损耗的，这也是硅谷大公司想让员工回到办公室的一个原因。但很多人宁愿少拿一些钱也想继续远程办公，因为就个人来说可以节省很多不必要的时间成本，这对于有孩子的员工来说真是太重要了。</p><h2 id="心理问题"><a href="#心理问题" class="headerlink" title="心理问题"></a>心理问题</h2><p>我看到很多人说远程办公会很孤独，我对此感受不够强烈，大概是因为日常经常和家人在一起，而且我还有两个小孩。如果没有小孩我估计也会感到孤独，即使结婚后也是容易孤独的，而和小孩相处完全是另外一种模式，我想这也是人类生小孩的一个重要原因吧。</p><p>但远程工作之后，确实会有一种脱离感，就好像没有进入社会的正常节奏。</p><p>脱离感也来自社交圈更小了，和同事之间的沟通基本发生在线上，而除此之外认识其他人的机会也少。我能想到的一个办法就是约老朋友线下见见，或者主动约一些线上认识的人聊聊，也可以线下见。总体而言，年级越大好像越容易产生孤独感，不容易深交，平时交流的人也都是些认识了十年、二十年的人，我不知道其他人是不是有类似体验。我倒是发现自己全职远程后，真的见到线下朋友会更有交谈的欲望，这大概是憋出来的。</p><p>另一个感受是，我远程工作之后倒更不容易焦虑了。细想一下大概是我抛去了办公室的一些不良因素的干扰，比如同事之间的竞争等。不是说远程没有晋升的压力，但我觉得从心理上我不是那么在乎了，而更在乎的是如何做好工作和如何提升自己，因为远程的情况下好像自己和公司更为平等的一个状态。不把自己和公司绑定，从物理上做到了就更容易从心理上达成这点。</p><h2 id="如何找远程工作"><a href="#如何找远程工作" class="headerlink" title="如何找远程工作"></a>如何找远程工作</h2><p>最近确实能看到大量工作在流失，我身边失业的人越来越多，在这种情况下找远程工作只会更难，但这并不意味这没有机会。</p><p>我之前总结过一些工作，但我知道现在这个列表里很多公司都没在招人了：<br><a href="https://github.com/chenyukang/remote-jobs-cn">remote-jobs-cn: 国内远程办公职位</a></p><p>这里有一个更全的、看起来还在更新的列表：<br><a href="https://github.com/LinuxSuRen/remote-jobs-in-china">remote-jobs-in-china: 支持远程办公的中国公司</a></p><p>如果英语足够好，可以尝试找一些国外的远程机会，我在 Linkedin 看到还是有些的。区块链这行现在是熊市，所以工作机会也少了很多，但远程工作的比率相对大，大概是这个行业的人确实在践行分布式和无中心化，<a href="https://web3.career/">Web3 Jobs: Blockchain</a>  这个站点上会有相关工作。</p><p>我能想到的另一个途径是，尝试找一些招人的、自己感兴趣的开源项目 (背后有商业公司运作的，可支持远程的) – 这样的项目也挺多的，然后给项目做贡献和社区的人熟悉，逐渐成为远程员工。虽然过程会比较耗时，但这确实是个途径。</p><hr><p>远程办公还有很多其他好处，比如我现在可以把车的油耗保持在 6L 左右，因为我基本都在错峰出行，很多地方的人流量在工作日会少很多，包场看电影是很常见的。我们还可以做地理套利，比如去生活成本更小的地方生活。我看到公司有个数字游民计划，就是几个同事一起约好去一些未曾待过的城市和地方边工作边旅行，真是很羡慕这样的自由生活，可是我有两个小孩需要照顾😂。</p><p>总体而言，我已经习惯了远程办公，好像就再也回不去坐办公室的日子了，这是适合我的一种工作方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我断断续续也有好几年的远程办公经历了，从疫情刚开始那会儿，我还在大疆工作，在家办公一个来月。2020 年下半年开始在微软，因为疫情那两年一直反反复复的，所以公司长期都是混合式办公，我通常每周会在家待两天，到了 2022 年大部分时间都是在家办公。目前在秘猿则是完全远程办公，
      
    
    </summary>
    
    
      <category term="远程" scheme="http://catcoding.me/tags/%E8%BF%9C%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>升级我的 localhost</title>
    <link href="http://catcoding.me/p/upgrade-my-dev-tools/"/>
    <id>http://catcoding.me/p/upgrade-my-dev-tools/</id>
    <published>2023-05-30T23:17:08.000Z</published>
    <updated>2023-08-12T15:00:30.125Z</updated>
    
    <content type="html"><![CDATA[<p>因为开始了全职的远程办公，所以我想把自己的 <code>localhost</code> 打造得舒适一些，最近一直在断断续续升级工作相关的设备，对于整天生活在屏幕前的数字宅来说这犹如买新房和装修吧。</p><p>我对设备的要求并不是很高，但年级大了多少有点职业病，所以我打算这次尽量找些好设备来满足自己，主题就是“<strong>关爱中年程序员</strong>”。</p><hr><h2 id="Mac-及应用"><a href="#Mac-及应用" class="headerlink" title="Mac 及应用"></a>Mac 及应用</h2><p>我近两年都在使用 PC 笔记本当主力开发机，最近几个月重回了 Mac 的怀抱。即使苹果生态有我之前提到过的各种问题，但 M2 芯片的 Mac 性能和续航我都很满意。不过我也花了好些时间来找称手的工具和配置。</p><p>我买的 Mac 是 32 G + 12 Core + 1 TB 的中等配置，这个配置完全满足我日常需求，大概是因为我还没什么视频剪辑类的事要做，我的主要需求是编程、写文档、浏览网页这些普通事项，一周需要带出去两三次，因为我又不玩游戏，所以 Mac 还是挺适合我的。</p><p>14 寸的 Mac 外出办公稍微有点重，如果你已经有适合外出携带的笔记本，在家里放个 Mac Mini 也是很适合的选择，因为 Mac Mini 价格太美丽了，而且接口更丰富。新款的 Mac Air 看起来也很不错，也许 M3 是个入手的好时机。</p><p>我用了两个来月才完全重新适应 Mac，下面谈谈一些配置和应用：</p><p>首先系统默认语言使用英文，这样有个好处在于很多配置都可以用字母去搜索，应用的切换也完全不用中文，减少了切换输入法的动作。</p><p>我形成了一个使用习惯，那就是严重依赖各种 App 的 <strong>Command Palette</strong>，比如 <code>VsCode</code> 我把 <code>Ctrl+L</code> 绑定到 command palette，然后 Obsidian 和 Arc 也同样有 Command bar。使用 Command Palette 通过模糊搜索去跑命令是更统一的方式，因为快捷键太多了我根本记不住，而命令是一个个普通的英语单词，容易在心里念出来。</p><p>另外我会关闭所桌面和应用切换动画，这样操作起来会迅速很多。</p><h3 id="Contexts"><a href="#Contexts" class="headerlink" title="Contexts"></a>Contexts</h3><p>Mac 的应用切换简直惨不忍睹，而且这些年来都没有很好的改进。市面上有不少这类工具，足以看出很多人不适应系统原生的应用切换。特别是像我一样会用 VsCode 为不同的项目打开多个窗口，快速定位到窗口对我来说是一大刚需。</p><p>Contexts 这个应用是我想象中工具，完全贴合我的使用习惯和对细节的要求。安装后 <code>Cmd + Tab</code> 就替换了系统原有的应用切换，这是符合大多数人使用习惯的 Windows 风格的切换，另外我会把一个很重要的快捷键 <code>Ctrl+I</code> 绑定到 Contexts 里面的 search，这样我能快速通过部分关键词选中要跳转的应用。还有，Contexts 很贴心地有个自动学习用户使用习惯的 <code>Number-Switcher</code>，基本上我日常 <code>右Cmd+W</code> 跳转到 Wechat，<code>右Cmd+D</code> 跳转到 Discord 等等，真是提高效率的利器。</p><p>另外很多人推荐 <code>Raycast</code>，这款软件可以做很多自动化的功能，但目前我只是用 <code>Raycast</code> 来查找和启动应用。</p><h3 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h3><p>我使用 Arc 接近三个月了，目前已经成为了我的默认浏览器。我认为最有用的是 <code>command bar</code>，可以输入 command，extension command，tab url，我把 <code>Ctrl + L</code> 配置到 <code>command bar</code>，这样我基本不会去关注 tabs 了，也不会去收藏网页，一切都是用关键词搜索。</p><p>其中的 <code>Space</code> 功能我也很喜欢，比如公司用 Gmail，而自己也用私人 Gmail 账户，<code>Space</code> 就可以把不同场景的同样网站区分开来。</p><p>Chrome 的所有 Extension 在 Arc 上都可以使用，而且我也不会再为插件配置快捷键，常用的命令通过 <code>command bar</code> 触发。</p><p><code>Easel</code> 是 Arc 的另外一个好用功能，我们可以很直观地通过类似截图的动作就能组合成一个 Dashboard，比如我把邮件、Github PR、Meeting Schedule 组合成一个看板，能够一目了然地看到需要关注的信息。</p><h3 id="Input-Source-Pro"><a href="#Input-Source-Pro" class="headerlink" title="Input Source Pro"></a>Input Source Pro</h3><p>这个工具用来设置一些应用的默认输入法，为什么这个很重要呢？因为我特别烦切换输入法，这是一个很干扰心流的动作。</p><p>比如在 Terminal、Raycast、Contexts、VSCode 这些应用里面，95% 以上的概率我都只会用英文输入，所以配置这些应用的默认输入法就能很大程度上减少切换。</p><p>这类工具有好几个，我用得最舒服的就是 Input Source Pro，这个工具还在 Beta 阶段，目前免费。</p><h3 id="Karabiner"><a href="#Karabiner" class="headerlink" title="Karabiner"></a>Karabiner</h3><p>这是修改快捷键必备工具，我做了一些方向键的配置，另外配置 <code>Ctrl</code> 的键，因为这比 <code>Cmd</code> 好按：</p><pre class="line-numbers language-none"><code class="language-none">- Change left_command+hjkl to arrow keys- Change left_command+u&#x2F;i to page_up&#x2F;page_down- Ctrl+Z &#x3D;&gt; Cmd+Z (Undo)- Ctrl+T &#x3D;&gt; Cmd+T (New tab)- Ctrl+W &#x3D;&gt; Cmd+W (Close)- Ctrl+S &#x3D;&gt; Cmd+S (Save)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不管是 PC 还是 Mac，我必须做的配置是把 <code>Caps Lock</code> 映射为 <code>Ctrl</code>，因为我们很少使用 <code>Caps Lock</code>，而这个键位是非常适合小拇指去按的，如果你是键盘党，这样配置可以很大程度减少左小拇指的损伤。</p><h3 id="Rime-输入法"><a href="#Rime-输入法" class="headerlink" title="Rime 输入法"></a>Rime 输入法</h3><p>大半年前我改变自己的使用习惯，强制自己使用双拼输入，目前我已经完全适应，总体而言我认为双拼没有极大地提高我的输入效率，但确实减少了很多不必要的按键，另外我觉得敲字的节奏感会好些。</p><p>我之前看到很多人吹小狼毫，但几次打开那些文档我都没有折腾的欲望，大概是我对输入法也没有特殊的需求，系统默认或者搜狗之类的都行。</p><p>两个月前偶然在 Twitter 上看到一个人推荐 <a href="https://github.com/iDvel/rime-ice">Rime 雾凇拼音</a>，这次我试了试。虽最后还是花了点时间折腾，但我觉得这个投入是值得的。Rime 的输入体验是好过 Mac 原生的输入法，没有任何多余、花哨的功能，你不输入时不会感觉到它的存在，并且支持我喜欢的小鹤双拼。但这东西就是注定比较小众，配置个输入法需要用到很多 Yaml 文件估计会劝退很多人。</p><p>我另一个比较特别的配置是，不像大多数人那样通过按 <code>Shift</code> 来进行中英文切换，因为 <code>Shift</code> 是一个常用键，容易误切换输入法，另外一个原因是我希望有一个唯一的标识来识别目前的中英文状态，而 ShowEdge 就是这样一个工具，我在屏幕特定的边沿会配置一个小圆圈，如果是红色便是中文，如果是黑色便是英文。这样不会存在我开着 Rime 输入法，但是输入的是英文的情况。我使用 <code>Ctrl+J</code> 或者 <code>Caps Lock</code> 来切换输入法，因为 <code>J</code> 是右手最容易默认找到的按键。</p><h2 id="键盘和鼠标"><a href="#键盘和鼠标" class="headerlink" title="键盘和鼠标"></a>键盘和鼠标</h2><p>我以前也主要看重键盘的外貌和敲打手感，所以我买了个 HHKB，后来也买了宁芝等各种小尺寸的键盘。最近两年我越发觉得肩胛骨酸疼，特别是右肩胛骨，有时候晚上疼得我睡不好。</p><p>我稍微调查了一翻，感觉确实是因为自己长期的坐姿和使用键盘的习惯造成的。Mac 的键盘和各种小尺寸键盘，因为宽度不够，两个手都要往中间靠，这样肩胛骨就长期保持这个姿势容易出问题：</p><p><img src="/images/ob_pasted-image-20230520140925.png" alt=""></p><p>人体工程学这东西有的人说是智商税，但我还是试试吧，于是我购买了套<em>罗技的人体工程学鼠标键盘</em>。</p><p>这个罗技 K860 尺寸巨大，其固定的手托材质舒适，这键盘需要大概一周左右的时间去完全适应，毕竟很多人的指法也是不对的，这种双手分离式键盘需要大致正确的敲打指法。</p><p>唯一的缺点是数字小键盘，毕竟我们大部分人是不用数字小键盘的，这有点浪费空间。刚用的时候我觉得很难受，我需要伸长手去摸我的鼠标，所以很想退货。但巧的是我买的是个套装，里面还有个轨迹球鼠标。当我把这两个设备这样组合起来时，小键盘的问题解决了：</p><p><img src="/images/ob_pasted-image-20230520141916.png" alt=""></p><p>使用轨迹球也是个神奇的体验，刚开始觉得操作起来太慢，适应了之后觉得右手轻松不少，反正只需要移动大拇指就行。同时鼠标也可以使用键盘的手垫，而且如果移动键盘鼠标也可以跟着移动了，配合 <code>left_command+hjkl to arrow keys</code> 方向键那里我也不会去按的。</p><p>很多程序员不喜欢用鼠标，但我最近发现鼠标的前进和后退键其实非常有用，比如我看代码的时候，按住 cmd 键点击鼠标可以跳转到定义，然后按鼠标的后退键返回之前的位置，这比一直使用键盘会舒服很多。</p><p>Mac 的 Trackpad 手感和体验都是很好的，但因为 Trackpad 也是居中的，和小尺寸键盘同样用久了同样容易劳损</p><p>如果你用外接鼠标，还需要另一个小 App 来配置一下。因为我们通常适应了 Mac 默认的 Natural scrolling，但是鼠标用这个选项就会很诡异，所以我找到了 <code>Scroll reverser</code> 这个工具，可以单独设置滚动的控制方向：<br><img src="/images/ob_pasted-image-20230520130005.png" alt=""><br>我对这套设备非常满意，肩胛骨酸疼这个问题很大程度上得到了缓解。现在我偶尔外出使用原始的 Macbook 键盘和 Trackpad 时，我会极其难受，很难想象自己使用这个姿势这么多年，不出问题才怪。</p><p>但这临时的缓解也可能是只是因为换了姿势，彻底解决长期的问题，大概只能尽量少坐多运动，不要长期保持同样的姿势太久。</p><h2 id="Herman-miller"><a href="#Herman-miller" class="headerlink" title="Herman miller"></a>Herman miller</h2><p>我之前的椅子扶手快坏了，然后想着买个新的办公椅。按照这次升级的主题，直接选择了购买 Herman Miller 这把号称世界上最舒服的椅子。</p><p>我之前偶尔试过同事的这款椅子，确实很舒服，但我自己买的刚开始坐上去觉得有些偏硬，后来找了些视频资料发现是我的坐姿有点问题，这椅子适合正坐而不是半葛优躺那种坐姿，用了几周后确实能感受到差异了。二代的前倾功能很适合专注的时候使用，而这个功能在目前的椅子上相对少见。</p><p>由奢入俭难，再也回不去了，如果这把椅子帮我纠正了坐姿也算是值了：</p><p><img src="/images/ob_pasted-image-20230530230859.png" alt=""></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这期间我还新增了些其他设备，比如 4k 显示器、支架等等，加上多年前买的升降桌等就完全够用了。我推荐的另一个小设备是韶音的骨传导耳机，我经常带这个耳机半天一天的都不觉得难受，而且这个品牌的质量和售后我非常满意。</p><p>最近我还看了看桌面的布线之类的东西，毕竟作为数字宅男是无法拒绝一个类似这样的桌面美学：</p><p><img src="/images/ob_pasted-image-20230520143655.png" alt=""></p><p>什么东西但凡涉及到美学就会是个无底洞，然后我开始怀疑自己是不是要掉进另外一个坑，需要及时止住了，所以我买了个隐藏电线的盒子把桌面搞干净点就够了。</p><p><img src="/images/ob_pasted-image-20230529201841.png" alt=""></p><p>总之，我对现在这套办公设备非常满意，程序员要对自己的身体好一点，毕竟这些东西差不多占据了日常的大部分时间，所以值得投入些时间和金钱在上面。</p><p>如果你有什么好用的设备请推荐给我，虽然我现在也不一定会买，但我喜欢种草 😜</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为开始了全职的远程办公，所以我想把自己的 &lt;code&gt;localhost&lt;/code&gt; 打造得舒适一些，最近一直在断断续续升级工作相关的设备，对于整天生活在屏幕前的数字宅来说这犹如买新房和装修吧。&lt;/p&gt;
&lt;p&gt;我对设备的要求并不是很高，但年级大了多少有点职业病，所以我打
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习英语的新工具</title>
    <link href="http://catcoding.me/p/new_english_tools/"/>
    <id>http://catcoding.me/p/new_english_tools/</id>
    <published>2023-05-23T11:10:08.000Z</published>
    <updated>2023-08-12T15:00:30.121Z</updated>
    
    <content type="html"><![CDATA[<p>我之前写过文章强调英语的重要性，这些年我也一直还在注重提高英语能力。虽然我在外企工作了两年多，但其实日常表达中使用口语的时间不多，所以口语提升有限。</p><p>最近我发现了些新的学习英语的好工具，顺便分享一下自己的一些心得。</p><h2 id="Discord-英语小组"><a href="#Discord-英语小组" class="headerlink" title="Discord 英语小组"></a>Discord 英语小组</h2><p>Discord 是我新工作的日常即时沟通工具，Discord 的服务器上有很多英语练习小组，我习惯的是<a href="https://discord.gg/english">这个</a> ，在这里可以和全世界各个地方的语言学习者聊天，有三四人以上的房间，也可以两个人进行一对一聊。</p><p>这个方法是和一个读者交流时他告诉我的，他在短时间内提高了口语最后面试成功。我使用 Discord 练习口语已经有一个半月了，我觉得效果非常好。</p><p>可能是因为时区原因，里面大部分是亚洲和中欧国家的人，比如印度尼西亚、印度、泰国、土耳其、俄罗斯等，据我统计大学生居多，也有不少高中生。这些人虽然不是英语母语者，但大部分比中国普通的英语学习者要好。</p><p>你在 B 站可能也看到过一些人用 OME TV 之类的软件来练习英语，但如果你自己试过就知道这不适合练习英语，因为总会碰到奇奇怪怪的人，我就碰到过一个恶作剧少年，聊着聊着突然给我来了个恐怖的鬼脸，还有会碰到色情等。所以想在上面找到合适的人时间成本太大，而且也很难停下来进行一些较为深入的话题。</p><p>我之前也付费在 Cambly 上提高口语，但我现在觉得那种方式太正式，用 Discord 比较随性，默认不用看到对方，所有注意力集中在听和说上面，也没有犯错的心理压力，适合我这种有些社恐的人。有时候我一边爬山一边和人聊，目前能比较流畅地用英语沟通很多方面了。我们聊的大多是一些日常的话题，如果碰到些计算机相关的从业者和学生，也可以聊聊技术方面的事。</p><p>另一个好处是能够与来自不同国家和文化背景的人交流，从而获得不同的感受，更深入地了解这个世界。除了一些常见的国家，我还与来自蒙古、埃及、巴基斯坦、孟加拉国和也门这些小众国家的人聊过。</p><p>我印象比较深的是一个也门的初中生，她说她不能上学了，因为自己的国家在内战。我不知道也门这个国家原来还如此动乱，回来后通过搜索去了解一些背景。我还碰到过一个埃及人，他的工作是客服，他想要学习英语因为英语客服的工资更高，因为他有残疾几乎一个多月没怎么出门了，那天我们聊了很久。我碰到过俄罗斯年轻人，他说现在非常恨自己的政府，正在想一切办法逃离俄罗斯。还有碰到过一些纯粹的语言爱好者，他们能流利地说几种语言，模仿能力极强。</p><p>有的人聊得比较投机就会加个好友，以便保持联系。因为同是语言学习者，所以大部分人都比较有耐心，有时候表达不清楚了，有的人也会共享屏幕给人解释。如果在屏幕前，我喜欢打开 Google 实景，和对方聊聊他们生活的国家和城市。也许是我太久没出去了，对 Google 实景比较着迷。</p><p>我和大部分中国学生一样，即使英语的读写能力还行，但是口语一直很薄弱。语言这东西就是个日常技能，如果你掌握了基本的语法，就没那么条条框框，即使是发音不标准也不是什么大问题，正常和流畅的表达是需要很多自信心的，而如果没有练习就不会得到这种自信，如果你练习得足够多，在表达的时候就没有那个在脑子里翻译的过程。</p><p><a href="https://www.youtube.com/watch?v=rNLLWfbfNwQ">Building Your English Brain</a>这个课程很好，构建自信心的过程在于你能把简单的单词完全掌握，并且熟练使用，造句就是一个很好的锻炼方式，而和人聊天就是最自然的方式。</p><p>也许我的口音很难有大程度的提高了，但表达的自信和流畅度是相对容易提高的。</p><h2 id="Trancy-插件"><a href="#Trancy-插件" class="headerlink" title="Trancy 插件"></a>Trancy 插件</h2><p>Youtube 是最好的英语资料库，这里面可以找到很多不同层次的视频资料。 <a href="https://www.trancy.org/">Trancy for Chrome | Master a new language in an enjoyable way</a> 这个插件可以让你进入几种不同模式去学习英语，比如跟读、单词考查等等。</p><p>这是最近让我眼前一亮的插件，特别适合用影子跟读法去用 Youtube 的资料来锻炼口语：<br><img src="/images/ob_pasted-image-20230511113058.png" alt=""></p><p>这个插件还在不断更新中，现在我们可以模拟很多场景，跟读并且获得评分，如果有不认识的单词还会自动给标注出来。<br><img src="/images/ob_pasted-image-20230501192846.png" alt=""></p><h2 id="沉浸式翻译插件"><a href="#沉浸式翻译插件" class="headerlink" title="沉浸式翻译插件"></a>沉浸式翻译插件</h2><p>这种插件 <a href="https://github.com/immersive-translate/immersive-translate">immersive-translate</a> 适合看一些比较长的英文文章，我有时候也用来看 NewsHacker 之类的。但我不推荐一直打开这个插件，而只是在想要快速浏览文章获取信息的时候试试。因为如果你一直依赖这种翻译，就不容易培养出来阅读英文的习惯。</p><h2 id="各种-GPT-及-AI-工具"><a href="#各种-GPT-及-AI-工具" class="headerlink" title="各种 GPT 及 AI 工具"></a>各种 GPT 及 AI 工具</h2><p>ChatGPT 的翻译水平超过大部分翻译工具，我现在写稍长一些的英文都会让 ChatGPT 帮我润色一下。</p><p>之前我还试用过 AI 聊天软件 <a href="https://twitter.com/myshell_ai">myshell</a>，不过自从我用 Discord 和真人聊之后就觉得 AI 工具没什么意思了，还是和鲜活的人类聊天更有趣，即使人的发音没有 AI 那么清晰和流畅，但那种人与人之间的情绪感受和生活经历的分享，是 AI 所不能替代的。</p><hr><p>学习一门语言犹如打开一个世界，而发现一种新的学习方式也犹如打开一个世界。如果你有什么好的学习方式和工具，欢迎和我分享 🙌。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我之前写过文章强调英语的重要性，这些年我也一直还在注重提高英语能力。虽然我在外企工作了两年多，但其实日常表达中使用口语的时间不多，所以口语提升有限。&lt;/p&gt;
&lt;p&gt;最近我发现了些新的学习英语的好工具，顺便分享一下自己的一些心得。&lt;/p&gt;
&lt;h2 id=&quot;Discord-英语
      
    
    </summary>
    
    
      <category term="工具" scheme="http://catcoding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="英语" scheme="http://catcoding.me/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>新的旅程</title>
    <link href="http://catcoding.me/p/new-journey/"/>
    <id>http://catcoding.me/p/new-journey/</id>
    <published>2023-05-11T22:40:54.000Z</published>
    <updated>2023-08-12T15:00:30.121Z</updated>
    
    <content type="html"><![CDATA[<p>因为家庭原因，我决定回到深圳常住。2023 元旦前夕，我陆续把东西寄回深圳，元旦后我在晨曦中登上了往南的列车。我那时候还没确定会离职，但目前找到了合适的工作，所以就于四月份从微软离职了。</p><p>在苏州微软工作的两年多，我遇到了很好的团队和同事，真的要离开了也有些不舍得。微软很大，每个部门的工作氛围可能都会有些差别。苏州工作的两年间我学到的这些：</p><p><strong>技术</strong>，世界上很少有公司能用技术服务这么大体量和规模的企业用户，我记得上次看过一个详细的事故报告，写着影响的用户上十亿，写出这样一个 Bug 也是个难得体验了。微软的工作氛围很好，作为技术人待在里面很舒服。在一个大的组织里工作很多时间都是在沟通，如何推进项目，如何和同事达成共识，这些是非常重要的也是最难的。另一方面，在长达 20 年历史的项目上做维护和开发也是一份难得的经历，我入职那几个月基本都在看代码，极大地提高了我的在编程上的韧性。另一方面，在一个如此大的项目上工作总感觉是在戴着镣铐跳舞，大范围地修改代码是很难的，很多时候都顾不上代码的好坏，一切都以稳定性为重。</p><p><strong>包容</strong>，这微软的企业文化。公司里有各种背景的人，而 Leader 大多会遵循员工自己的一些想法。如果一个员工犯错了，很可能是组织和流程的问题，而不是这个人的问题，所以在做事故分析的时候，都在就事论事。也许也是因为自己年纪越来越大，我对很多人和事都更包容和平淡了。</p><p><strong>生活</strong>，苏州的生活很舒服，感觉比较清淡，晚上八九点街道上的人就比较少了。我住在苏州的工业园区，人口密度相比深圳小很多。周末经常去湖边和公园玩耍，在这两年间我开车去周围都逛了逛，我喜欢去太湖、独墅湖、阳澄湖、诚品书店这些地方，风景都很好。工作之外认识的人不多，但也有舍不得的朋友。有一次我在金鸡湖旁边看到一家三口在夕阳下露餐，他家的女孩和我大女儿差不多大的样子，养着两只小鸭子作为宠物。我正被这幅和谐画面吸引，没想到我女儿也被两只鸭子吸引过去了，然后我们一起散步玩耍并留下了联系方式，周末经常约着出来遛娃和闲聊。这两年间我的社交圈更小，但留给自己的时间多了，找一些自己想做的事情。平时我花了很多时间在二女儿的照顾上，和孩子玩耍是是一种最好的休息。</p><p>所以，这两年不管从生活还是工作的角度我都是满意的。2020 年我攒了很大的勇气离开工作了六年的公司和城市，如今我又花了很大的勇气改变。其中很重要的一点还是父母方面的考虑，我在另外一个城市待的这两年，和父母相见的次数不足十次。<a href="https://waitbutwhy.com/2015/12/the-tail-end.html">The Tail End</a> 这篇文章用残酷和直观的数据让人认同这点：<strong>Living in the same place as the people you love matters.</strong></p><p>抛去一些不能改变的家庭原因，我还想要什么其他改变？从另一个角度看待，人生是一个游戏，不能暂停，不能回滚，但必然有终点。在这些基本限制下，有的人会选择一直玩一种剧本，而有的人会选择多玩一些剧本。在我的履历中，我认为年轻的时候探索和尝试还不够，所以现在想趁还没老到不能折腾阶段，想改变就想试试，我还有好奇心。</p><p>另外关于如何过好这一生，对我有启发的观点是李自然的<a href="https://www.youtube.com/watch?v=RsehMAgqDW4">如何把一辈子活成 N 辈子</a>，这个视频值得看看。其中很重要的是需要做减法，走出舒适区，保持提高。这倒不是说要赚多少钱，而是既然我们大概无法控制长度，那我们如何从厚度去扩展。</p><p>成功就是不断地达到自己理想的生活状态，我的理想的生活状态是更自由，并且能有足够多的时间和精力陪家人，做技术和开源，所以全职远程是更适合自己。当我觉得未来可能离开微软的时候，就是抱着这样的期待开始留意一些工作机会。</p><p>可刚回深圳的那段时间，因为一些突发问题家人住院，所以这几个月我非常忙。父母年迈生病，孩子幼小，任何人到了这个阶段都不太容易吧。印象深刻的一次是我开车去给家人送饭，但因为实在太累，等红绿灯的时候想着迷眼一会儿，结果我居然睡着了，隔壁的司机下来敲我的车窗才突然惊醒，估计我就睡着了几十秒，但醒来后像是睡着了好久。</p><p>这阶段比较辛苦，幸好现阶段结果还好，深圳的医疗虽然比不上北上广之类的城市，但也有些资深的好医生在多地的跑，在常见的疾病上是能找到靠谱的医生。</p><p>另外今年工作机会不多，在我上面所列的期望条件下就更少了。我之前收集过一个<a href="https://github.com/chenyukang/remote-jobs-cn">远程工作列表</a>，很多公司今年基本不再招人。幸运的是我找到了一份自己挺满意的工作，就是在 Cryptape 做区块链和 Rust 相关的开发。我知道区块链这行现在鱼龙混杂，很多人现在也并不看好，我认为这里面有很多新东西可以尝试。秘猿也是国内很少的那种企业，在做一些新事物的探索，同时给了员工很大的自由度，公司里几乎全员远程工作，所有代码也都是开源的，通过我入职后的一个月感受来说内部氛围很好。</p><p>这次我花了比较久时间来做决定，特别是家人不太理解我人到中年为什么就变得更激进起来。作为大龄技术人，在国内换个靠谱的工作并不容易，但我还没到退休的年龄。我没那么大动力在一个公司里按照既定的职级路线去爬，但还有动力去写代码，提高自己的编程能力，在开源的世界里进步。</p><p>微软是个令人尊敬的良心企业，这个有接近 50 年历史的企业再一次抓住了历史的风口。在和组里告别的时候，我说现在也许不是一个离开公司的好时机，这感觉就像是火箭正要发射而我却要下来。若干年后，再回顾起来看我的选择，是不是会显得我很愚蠢地偏离了大势。有可能，但更重要的是人要自洽，每个阶段追求自己理想中的生活就很好，我现在的生活状态和预期的几乎完全一样。</p><p>这段时间两鬓多了一些白发，觉得时间越过越快，所幸还未被生活击溃，我所遇到的困境并不特殊，而是大多数人这辈子都会面对的。</p><p>以上就是这半年里的一些改变的总结吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为家庭原因，我决定回到深圳常住。2023 元旦前夕，我陆续把东西寄回深圳，元旦后我在晨曦中登上了往南的列车。我那时候还没确定会离职，但目前找到了合适的工作，所以就于四月份从微软离职了。&lt;/p&gt;
&lt;p&gt;在苏州微软工作的两年多，我遇到了很好的团队和同事，真的要离开了也有些不舍
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="微软" scheme="http://catcoding.me/tags/%E5%BE%AE%E8%BD%AF/"/>
    
      <category term="远程" scheme="http://catcoding.me/tags/%E8%BF%9C%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>不想当作家的程序员写不出 Redis</title>
    <link href="http://catcoding.me/p/redis-antriez/"/>
    <id>http://catcoding.me/p/redis-antriez/</id>
    <published>2023-04-04T17:59:09.000Z</published>
    <updated>2023-08-12T15:00:30.121Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ob_pasted-image-20230205134219.png" alt=""></p><p>西西里岛，是位于意大利南部阳光而宁静的岛屿，正如电影《西西里岛的美丽传说》中演绎的那样，这里有着古老的历史和建筑，看起来和 IT 不沾边，却是 Redis 的作者 antirez 的居住地。</p><p>Redis 是互联网的一个基础设施，这个世界上大量的网站背后都有 Redis 的影子。相比于 Redis 的流行度，很多程序员并不了解 antirez 的故事。最近我看了他几乎所有的博文，和你分享一下我了解到的趣事以及我们能从这位 70 后的上一代程序员身上学到什么。</p><p>antirez 不是一个典型的意大利程序员，大部分当地人喜欢 boring-but-sure 的路径，IT 这行在当地算不得特别高薪的工作，大多数人不喜欢做过多探索，但 antirez 喜欢新东西和创造新东西。在一篇 10 年前的访谈中 antirez 谈到，住在意大利对程序员而言没有多大的影响，因为我们可以在互联网上经历有趣的一切：</p><blockquote><p>If your target is the world, being here is not a big limit for a programmer. The majority of interesting things are happening on the internet nowadays anyway.</p></blockquote><p>职业生涯初期，antirez 做过安全研究员，后来做过嵌入式、系统、Web 等领域的开发，他早年还发明了 Nmap 中的常用的扫描技术 <a href="https://en.wikipedia.org/wiki/Idle_scan">idle scan</a>。</p><p>2009 年，当时 antirez 在做一个网站实时统计，他认为现有数据库比如 MySQL 无法满足那种写入密集、查统计数据的需求，于是他着手解决这个问题。</p><p>antirez 使用 Tcl 快速撸了一个名为 <a href="https://gist.github.com/antirez/6ca04dd191bdb82aad9fb241013e88a8">LLOOGG Memory DB</a> 的模块，总共只有 300 行，但却解决了手里的问题并包含了 Redis 的核心设计，有 <code>protocol</code> 和 <code>list</code>，还有 6379 端口！</p><p>随后 antirez 重新用 C 语言实现了新的版本，投入生产环境良好运行了几周，随后发表在 Hacker News 上并由此得到了更多关注，越来越多的公司开始在生产环境运行 Redis。</p><p><sub>这里谈点题外话，Redis 最初在 Ruby 社区受到了关注，随后 Github、Instagram 等站点开始使用 Redis。Ruby 社区曾经是潮流的引领者，比如 Git 最初发表 Linus 也搞不懂为什么 Ruby 社区的人们这么喜欢这东西，后来就有了 Rails 写的 Github。虽然 Ruby 现在略显式微，但我们应该感谢 Ruby 社区的好品味给业界发现和创造了这么多好东西。</sub></p><p>如果只是用来做缓存，2003 年开始我们已经有了 memcached，比如我 2011 年刚工作那会儿 memcached 是更成熟通用的组件，我还仔细<a href="https://catcoding.me/p/memcached/">读过 memcached 的源码</a>，但为什么 Redis 能后来居上？</p><p><img src="/images/ob_pasted-image-20230331121122.png" alt=""></p><p>antirez 谈到主要有两点：</p><ul><li>对于密集写入的场景，特别是缓存相关的需求，Redis 可以节省成本，性能也很好</li><li>Redis 不只是缓存，而是一种不同形态的数据库，适合很多性能比正确性要求更高的场景</li></ul><blockquote><p>In the field of programming languages there is a motto: a programming language is worth learning if it is different enough from all you already know to change your mind, exposing you to new abstractions. Well I think Redis definitely is a really different database, and will change the way you think about your data.</p></blockquote><p>antirez 从一开始就把 Redis 当作一个数据库来看待，而不只是缓存组件，简而言之 memcached 能做的 Redis 也行，而 Redis 能做到的 memcached 不行。</p><p>Redis 天然支持各种常用的数据结构，比如 list、set、maps 等等，这些数据结构让 Redis 可以应对各种业务需求，可以说 Redis 开启了一个 KV 数据库的新时代。</p><p>这个故事和 SQLite 的由来相得益彰，SQLite 的第一个版本只是个 Tcl 扩展，Git 的第一个版本只有 1200 行，这似乎印证了软件设计中的一个道理：运行良好的复杂系统往往由简单设计演化而来，而一个从开头设计的复杂系统往往不行，通过打补丁的方式通常也无法解决：</p><blockquote><p>A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.” – John Gall</p></blockquote><p><sub>Redis 和 SQLite 都深受 Tcl 的影响，而 Tcl 是一门 1988 年发明有着 35 年历史的语言。Tcl 继承着 Unix 那种设计可组合、小巧的组件并保持简洁接口的设计风格，antirez 认为自己的程序理念深受 Tcl 的启发，特别是 Tcl 里 <code>All data types can be manipulated as strings</code> 和命令的风格延续到了 Redis 里。而 John Ousterhout 当年是为了解决 <a href="https://catcoding.me/p/3-years-in-eda/">EDA 开发</a> 中的一个需求发明了 Tcl，在互联网浪潮还未掀起的 80、90 年代里 EDA 真算是个技术领域里的一颗明珠，衍生出了很多技术分支。</sub></p><p>Redis 的源码可作为 C 系统编程的典范，还包含了很多经典的数据结构的实现，你可以读读这本 <a href="http://redisbook.com/index.html">Redis 设计与实现</a> 来领略一番。</p><p>随后 Redis 被 VMWare 赞助，后来又成立了专门的 Redis Labs。虽然 Redis 从一开始就是个热门的开源项目，但我们可以从提交数排名可以看出，在这近 10 年间主要是 antirez 一个人在做贡献和维护。</p><p><img src="/images/ob_screenshot-2023-03-30-at-09.29.44.png" alt=""></p><p>这是一个较为奇怪的现象，毕竟 Redis 是一个如此通用的组件，Github 上的关注度也很高，来自各种场景的需求会非常多。</p><p>但如果你仔细回顾 antirez 的风格，这就有了合理的解释。他认为对 Redis 来说，避免复杂度、保持稳定性是最重要的事，所以每天他面对众多的需求和 PR 时，大多数时候他都会说“No”，否则就会出现 <code>Less stable code base, more problems</code> 的恶性循环。</p><blockquote><p>The bugs you write in the first implementation are extremely hard to fix later. They don’t go away easily. Basically there’s this process where you say, okay, I want to change something, but I want the software to remain stable. So you start to think about it for weeks, the way you want to do it, without writing any code.</p></blockquote><p>每个新功能的引入必须要非常小心，Redis 的核心代码一直保持在万行的级别，并且在 4.0 版本之前都是单线程运行。</p><p><strong>设计才是最重要的，而编码和实现是简单的，因为这只是水到渠成的事</strong>。</p><blockquote><p>Instead, there’s this huge design process. But because of this design, sometimes we can write a new feature using half as many lines of code in a much more simple way, a much more stable way. You think and think and think and find that a couple of days ago, what sounded like the best design — it starts to sound pretty lame, actually, and you find another and another. At the end, you understand that probably that specific one was the best, and then you start doing the implementation.</p></blockquote><blockquote><p>This means, in turn, that people say, don’t worry, I can help you implement this. And you say, no. If you want to help me, you have to put more time into the design effort. Writing the code is the easy task. The hard task is understanding what to do and in what way to do it.</p></blockquote><p>我想，这也是我们作为程序员想要提升到更高层次必须意识到的一个方面，<strong>不要过多花时间关注在编码上，而应该是花时间在思考需求和问题、找到好的设计这些事情上</strong>。</p><p>长久维护一个项目也会感觉到无聊，为了让自己保持兴趣，antirez 会尝试在不同的领域切换，比如一段时间做数据结构，过几周就切换到 cluster 之类的。并且除了 Redis 之外，他还在做更多 <a href="http://antirez.com/news/86">side project</a>:</p><p>1) Load81, children programming environment.<br>2) Dump1090, software defined radio ADS-B decoder.<br>3) A Javascript ray tracer.<br>4) lua-cmsgpack, C implementation of msgpack for Lua.<br>5) linenoise line editing library. Used in Redis, but well, was not our top priority.<br>6) lamernews, Redis-based HN clone.<br>7) Gitan, a small Git web interface.<br>8) shapeme, images evolver using simulated annealing.<br>9) Disque, a distributed queue (work in progress right now).</p><p>作为程序员 side project 是一种探索也是一种精神休息的方式，并且程序员通常会在 side project 中显得更有创造力：</p><blockquote><p>Like a writer will do her best when writing that novel that, maybe, nobody will pay a single cent for, and not when doing copywriting work for a well known company, programmers are likely to spend more energies in their open source side projects than during office hours, while writing another piece of a project they feel stupid, boring, pointless.</p></blockquote><p>我粗看了一下这些项目，都是 C 实现的并且风格统一，README 都会写些自己的思考和设计选择。</p><p>antirez 喜欢写小的程序，这不只是因为可以控制复杂度，而是因为短小的程序自有其美 <a href="http://antirez.com/news/74">Fascinating little programs</a>，老一代程序员喜欢在严苛的限制下挑战自己的技艺，比如 <a href="http://antirez.com/news/108">Writing an editor in less than 1000 lines of code, just for fun</a>。</p><p>独立维护一个影响如此大的开源项目会有巨大的心理压力，虽然用户并没有直接付钱，但维护者有责任去修复出现的问题。这种压力不一定是技术上的，也有来自社会方面的压力，比如不断有人指责他不把代码和 API 里的 master/slaver 替换掉。</p><p>antirez 曾经在一篇采访中谈到想在家里组成一只小队伍来维护 Redis，后来又感叹到现在太难找靠谱的 C 程序员了，愿意做 system programming 的越来越少。</p><p>antirez 在这篇文章中 <a href="http://antirez.com/news/129">The struggles of an open source maintainer</a> 阐述了维护开源项目的难处，其中提到在 Redis 项目用户多了之后，自己需要一直处于在线状态。而他习惯的工作方式是工作一段时间然后彻底放空，他从来不习惯朝九晚五的定时工作制，甚至提到自己无法保持编程 40 分钟以上，他喜欢编码一会儿然后去带孩子或者运动一会儿再回来。</p><p>除了编程之外，antirez 对红酒和运动也很有兴趣，而他更有追求的是在写作这件事情上，可以为了写作放弃编程，这让我想到了王小波。</p><p>三年前，他发了一篇博文声明自己从 Redis 上退下来，因为他认为自己想做的是艺术家那样的创造性工作，编程也是自己表达方式的一种，而 Redis 发展到现在这个程度创意性事情更少，事务性的工作更多了，这不是自己所期望的：</p><blockquote><p>I write code in order to express myself, and I consider what I code an artifact, rather than just something useful to get things done. I would say that what I write is useful just as a side effect, but my first goal is to make something that is, in some way, beautiful. In essence, I would rather be remembered as a bad artist than a good programmer.</p></blockquote><p>Redis 交给了几个核心维护者，这些人已经和他在开源社区有多年的配合，所以对社区来说这是个很自然的选择。</p><p>在停下编程的这几年，他默默地完成了名为 <a href="http://antirez.com/news/136">Wohpe</a> 的科幻小说，这本小说是关于人工智能和气候变化等，原文用意大利语写成，但现在也有英文翻译版本。</p><blockquote><p>I now know for sure: it is no coincidence that for hundreds of years writing has been considered the highest art in which to try one’s hand. By writing you look for things, and if you insist enough you end up really finding them.</p></blockquote><p>写完小说后 antirez 还有些犹豫到底是回到编程还是继续从事其他写作，或者是边写作一边做些技术。直到前段时间，暂别了两年之后 antirez 终于通过 <a href="https://github.com/antirez/adventofcode2022">Advent of Code</a> 找回了编程的乐趣，他解决了 18 道题目，并且在过程中又折腾出来一门 stack-based 的编程语言。从 Twitter 上看，最近他在做一些 LoRa 设备上的小项目，也折腾 Flipper Zero 这样的极客设备。</p><p>总之，antirez 的博客非常值得一读，其中有一篇 <a href="http://antirez.com/news/61">英语是我 15 的伤痛</a> 让我很有共鸣，作为英语非母语的开发者，要融入到英语的环境中需要很多额外努力，而这是技术圈里大多数英文母语者根本不会在乎和谈论到的事。</p><p>他的博客里还有些好文章：</p><ul><li>编程中保持心流，编程中如果有新的想法和问题发现，你可以先记录下来以后再回顾，这叫作 <a href="http://antirez.com/news/51">Log driven programming</a>。</li><li>For me other people making money out of something I wrote is not something that I lost, it is something that I gained. <a href="http://antirez.com/news/48">Redis 使用 BSD</a>。</li><li>Arts are one of the few things worth life’s best efforts. Programming is art, if done in certain ways.</li><li>Life is too short to work like crazy for most of its part.</li><li><a href="http://antirez.com/news/112">The mythical 10x programmer</a></li><li><a href="http://antirez.com/news/135">Programming and Writing</a></li></ul><p>看了这么多 antirez 相关的文章后，最让我印象深刻的也是好奇心，并且在好奇心的驱使下不断去做有乐趣的事。</p><p>保持兴趣，不只是技术上，生活上的兴趣也很重要，红酒、CrossFit、写作，以及冰激凌，antirez 和 Redis 的第一位用户 (老同事) 一直合开着一个冰激凌店！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ob_pasted-image-20230205134219.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;西西里岛，是位于意大利南部阳光而宁静的岛屿，正如电影《西西里岛的美丽传说》中演绎的那样，这里有着古老的历史和建筑，看起来和 IT 不沾边
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="技术" scheme="http://catcoding.me/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Redis" scheme="http://catcoding.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>人类的终极工具</title>
    <link href="http://catcoding.me/p/chatgpt-tools/"/>
    <id>http://catcoding.me/p/chatgpt-tools/</id>
    <published>2023-03-20T00:19:09.000Z</published>
    <updated>2023-08-12T15:00:30.113Z</updated>
    
    <content type="html"><![CDATA[<p>乔布斯曾经说过：<strong>计算机就像自行车一样，它们是人类思维的自行车</strong>。计算机和自行车一样，能够帮助人们快速、高效地完成很多任务，是人类思维工具的一种。</p><p>随着 chatGPT 的出现，计算机这个工具彻底地进化了，它比人类懂得更多，能通过语言和人交流，懂得推理和归纳，帮你学习、创造，计算机也可以成为”人类思维的朋友“。</p><p>LLM 技术的破圈夹杂着兴奋和恐惧，很多行业都面临巨大的变化。</p><p>很明显的是 Google 危了。以我最近的使用感受来说，使用 Google 搜索的次数会越来越少，我只有在明确想查找些网页的时候才会去用 Google，而关于一个细节、主题的搜索和学习，我会先尝试用 chatGPT。</p><p>以我最近碰到的一个例子来说，我碰到一个单元测试用例跑失败了，从错误信息看是“conflicting output format options”，当我把这个场景描述出来后，chatGPT 给出了非常好的回复，而且我们可以通过继续追问的方式来学习更多：</p><p><img src="/images/ob_pasted-image-20230312074346.png" alt=""></p><p>当然也能通过 Google 来通过关键词搜索，但我知道这样会更麻烦，我需要从一堆沙子中去寻找有价值的东西，而且我不能和搜索引擎对话。</p><p>用 chatGPT 非常适合苏格拉底式的对话和探索式学习，比如我想了解一个主题：<br><img src="/images/ob_pasted-image-20230318063407.png" alt=""></p><p>接着我继续问：</p><ul><li>what is bound lifetimes in Rust</li><li>show me some example code for Rust’s  generic lifetime parameter</li><li>show me some example code for Rust’s higher-ranked lifetime</li><li>show me some example code for Rust’s higher-ranked lifetime in a trait</li><li>show me some example code for Rust’s  generic lifetime parameter in a struct</li><li>show me some example code for Rust’s  generic lifetime parameter mixed with high-rank lifetime</li><li>In Rust, can ConstGeneric work with lifetime parameter?</li></ul><p><img src="/images/ob_pasted-image-20230318063554.png" alt=""></p><p>chatGPT 给出的回答都非常好，能让我就想关主题不断地探索。当然 GPT-4 就更恐怖，我一个朋友最近在上经济学的课程，每周的 quiz 基本都被 GPT 给秒杀。</p><p>我最近写了个几十行的 Python 小程序 <a href="https://github.com/chenyukang/talkGPT">chenyukang/talkGPT</a>，通过  <a href="https://github.com/Uberi/speech_recognition">SpeechRecognition</a> 和 OpenAI 的接口来进行英语口语对话，可以基本运行成功 (OpenAI 接口有时候比较慢)。后来我发现了其他公司做的这类产品 <a href="https://t.me/samantha_x64_bot">Telegram: Contact @samantha_x64_bot</a>，已经能非常流畅地和黑寡妇进行口语练习了：</p><p><img src="/images/ob_pasted-image-20230320002656.png" alt=""></p><p>所以，chatGPT 完全是另外一个维度的工具，积累了人类历史上的很多文字和知识，并且可以不断地进化。如果具备一些人类的核心能力，比如逻辑、推理和归纳，chatGPT 就是一个活了几百年的人，并且随着时间的推移不断地进化和自我更新。当 chatGPT 这种技术和波士顿动力的机器人结合起来，这个活了几百年的老人就有了身体。这是不是很恐怖？</p><p>当人类真的创造出来这样的工具，我们该如何改变自己的学习和工作方式？以后每个人都可以通过移动设备和这各种 GPT 交流，几乎所有的创作中机器生成的成分会越来越大。</p><p>这是巨变的开始，很多问题现在没有明确的答案：</p><p>学生在学校该学什么？也许所有背诵的东西都更不重要了，学生应该学习的是更多通识教育，如何自主学习和创新。</p><p>编程和写 Prompt 有本质的区别么？我以前认为有差别，但如果你把 chatGPT 看作一个编译器或者解释器，其实也没有多大差别。只是编程更为精细，这是更直接和计算机对话的原始方式。而 Prompt 几乎就是自然语言，你可以通过特定的 Prompt 完成特定领域的任务，Prompt Engineer 的需求确实会存在。现在我们常用的编程语言对于未来而言可能是一种汇编语言。</p><p>通过 chatGPT 创造和辅助创造的作品是否有版权？我不知道，似乎法律还没跟上这块。以后必然会出现大量的机器生产的内容，纯手工打造会变得稀缺，但如何区分出来是否纯手工打造，或者这将变得不重要。事实上这篇文章里就有部分 chatGPT 帮我生成的 😁。</p><p>书籍会变得更不重要？人们会更没耐心去从头到尾地看书，也许我们可以通过发布思维和知识库这样的东西来分发知识了，比如刘润把自己的所有书籍和文章汇总成为一个主题知识库，我们可以与之对话，比如有人汇总了 <a href="https://paul-graham-gpt.vercel.app/">Paul Graham GPT</a>。</p><p>我们如何面对这样的新工具？最重要还是把它定位为工具，用来提高效率和创造价值，正如 <a href="https://twitter.com/ID_AA_Carmack/status/1637087219591659520">John Carmack</a> 在回答是否担心 AI 替代程序员时所说：</p><blockquote><p>Software is just a tool to help accomplish something for people - many programmers never understood that. Keep your eyes on the delivered value, and don’t over focus on the specifics of the tools.</p></blockquote><p>赶紧学起来？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;乔布斯曾经说过：&lt;strong&gt;计算机就像自行车一样，它们是人类思维的自行车&lt;/strong&gt;。计算机和自行车一样，能够帮助人们快速、高效地完成很多任务，是人类思维工具的一种。&lt;/p&gt;
&lt;p&gt;随着 chatGPT 的出现，计算机这个工具彻底地进化了，它比人类懂得更多，能通过
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="人工智能" scheme="http://catcoding.me/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Rust 编译器源码概要</title>
    <link href="http://catcoding.me/p/rustc-source/"/>
    <id>http://catcoding.me/p/rustc-source/</id>
    <published>2023-03-13T00:24:08.000Z</published>
    <updated>2023-08-12T15:00:30.121Z</updated>
    
    <content type="html"><![CDATA[<p>一个 Rust 程序是如何从源文件编译为二进制文件的？</p><p>如果从头开始看 rustc 的源码会无从下手，我之前通过解决 issue 去读过部分模块的源码，就是 bottom-up 的方式，但我还未从整体上理解 rustc 的源码结构。</p><p>这篇文章主要是我在重看 <a href="https://rustc-dev-guide.rust-lang.org/getting-started.html">Rust Compiler Development Guide</a> 的一些随手记录，还有些自己的动手实验，旨在厘清编译器的大致脉络，理解每个阶段做了些什么，如果你想看更为完整的文档请参考官方的手册。</p><p>Rust 编译器分为这几个主要的阶段，回顾我目前做的工作大多集中在 <code>MIR</code> 之前，分阶段从前到后接触得越少 😊</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>编译器是典型的输入输出系统，每个阶段都有对应的入和出。我们经常可以看到 <code>lowering</code> 这个术语，这个 <code>lowering</code> 的对象可以是源程序、AST、IR，不断地把程序中的抽象由高变低的过程，到 <code>MIR</code> 就已经是类似 <code>LLVM IR</code>  这个级别了。</p><p><img src="/images/ob_pasted-image-20230303200344.png" alt=""></p><p><strong>Lexing</strong>: 把源程序解析为 token 流。</p><p><strong>Parsing</strong>: 把 token 流转换为 AST（Abstract Syntax Tree），这期间很做宏扩展、AST 验证、名称解析和早期 linting。</p><p><strong>HIR lowering</strong>: 将 AST 转换为高级中间表示 HIR（High-level IR），这是一种对编译器更友好的 AST 表示，其中也涉及很多诸如循环和 <code>async fn</code> 之类的脱糖。然后我们使用 HIR 进行类型推断（type inference）、特征求解（trait solving）和类型检查（type checking）。</p><p><strong>MIR lowering</strong>: 将 HIR 转换到 MIR（Middle-level IR），用于借用检查和其他重要的基于数据流的检查，例如检查未初始化的值。在此过程中还构建了更加脱糖的 THIR（Typed HIR），THIR 主要用于 pattern checking 检查。</p><p><strong>Code generation</strong>: 主要基于 LLVM 做代码生成，也支持 Cranelift。</p><h2 id="编译入口"><a href="#编译入口" class="headerlink" title="编译入口"></a>编译入口</h2><p>当我们运行编译命令 <code>rustc main.rs</code> 时，编译器首先会通过 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_driver_impl/src/lib.rs">rustc_driver</a> 这个最上层的组件来处理输入参数，然后调用更基础的组件来启动编译行为。</p><p>编译器的入口在于 <a href="https://github.com/rust-lang/rust/blob/5983a3a99ea631da9d7d1ce510a6761913f92a89/compiler/rustc/src/main.rs#L64">rustc_driver::main</a>，接着调用：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token class-name">RunCompiler</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> callbacks<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>真正的跑编译流程的过程在于 <a href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_driver_impl/src/lib.rs#L232">run_compiler</a>，主要流程还是 <code>Parsing</code>，<code>Analysising</code>，<code>Linking</code>。我们看到很多调用是从一个叫做 <code>queries</code> 的东西开始的，比如：</p><ul><li><code>queries.parse()</code>，</li><li><code>queries.global_ctxt()?.enter(|tcx| tcx.analysis(()))</code></li></ul><p>这是 Rust 编译器的一个特点，正在从传统的 <code>pass-based</code> 方式转向 <code>demand-driven</code>，按需编译的主要思路是既然编译是典型的输入输出系统，同一个输入的输出是一样的，所以适合用缓存来减少重复计算。这是算法设计中 <code>Memoization</code> 的思路，详细的设计文档在 <a href="https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md">rustc-on-demand-and-incremental</a>。</p><p>好处主要在于增量编译时加快编译速度，结果就是用户更改的少量的代码，编译速度会更快。另外一个原因是这样方便并行编译。</p><p>但目前还有很多 <code>phase</code> 并没有完全实现这种按需处理的方式，目前只有 <code>HIR</code> 到 <code>LLVM IR</code> 之间的步骤是查询的。我们可以在这里看到默认的 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_interface/src/passes.rs#L626">query provider</a>:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token constant">DEFAULT_QUERY_PROVIDERS</span><span class="token punctuation">:</span> <span class="token class-name">LazyLock</span><span class="token operator">&lt;</span><span class="token class-name">Providers</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">LazyLock</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> providers <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Providers</span><span class="token punctuation">::</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    providers<span class="token punctuation">.</span>analysis <span class="token operator">=</span> analysis<span class="token punctuation">;</span>    providers<span class="token punctuation">.</span>hir_crate <span class="token operator">=</span> <span class="token namespace">rustc_ast_lowering<span class="token punctuation">::</span></span>lower_to_hir<span class="token punctuation">;</span>    providers<span class="token punctuation">.</span>output_filenames <span class="token operator">=</span> output_filenames<span class="token punctuation">;</span>    providers<span class="token punctuation">.</span>resolver_for_lowering <span class="token operator">=</span> resolver_for_lowering<span class="token punctuation">;</span>    <span class="token namespace">proc_macro_decls<span class="token punctuation">::</span></span><span class="token function">provide</span><span class="token punctuation">(</span>providers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">...</span><span class="token punctuation">.</span>    <span class="token namespace">rustc_codegen_ssa<span class="token punctuation">::</span></span><span class="token function">provide</span><span class="token punctuation">(</span>providers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>providers<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这些 <code>provider</code> 是按照 <code>crate</code> 这个维度来组织的，我在日常开发中经常碰到的一个问题是，如果我切换了 <code>compiler</code> 的代码分支，然后直接进行增量编译，最终链接的时候报错，这大概是因为某些 <code>crate</code> 的代码变了，而缓存的结果是老的，重新 <code>clean</code> 后编译就好了，以后再排查一下具体原因。</p><p><code>query</code> 引入的另外一个问题是导致错误堆栈特别长，在调试过程中经常碰到几百行的堆栈信息，我打算在这个 <a href="https://github.com/rust-lang/rust/issues/107910">Issue</a> 里尝试解决。</p><h2 id="Lexing"><a href="#Lexing" class="headerlink" title="Lexing"></a>Lexing</h2><p>Lexing 的过程和其他编译器类似，我们可以理解为给定字符串的源文件，输出一个 token 的数组。对应的代码在 <a href="https://github.com/rust-lang/rust/blob/5983a3a99ea631da9d7d1ce510a6761913f92a89/compiler/rustc_lexer/src/lib.rs#L326">compiler/rustc_lexer</a>，这个 <code>advance_token</code> 就是读取下一个 token。</p><p>但是 Rust lexing 过程中的特殊点在于输出为一个称之为 token 流的东西，<code>advance_token</code> 被一个叫做 <code>tokentrees.rs</code> 的模块调用，处理后的结果是 <code>TokenStream</code>，其实也就是一组 Token，只是定义为一个树形的结构：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">TokenStream</span><span class="token punctuation">(</span><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token class-name">Lrc</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">TokenTree</span><span class="token operator">>></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其定义为：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">TokenTree</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/// A single token.</span>    <span class="token class-name">Token</span><span class="token punctuation">(</span><span class="token class-name">Token</span><span class="token punctuation">,</span> <span class="token class-name">Spacing</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">/// A delimited sequence of token trees.</span>    <span class="token class-name">Delimited</span><span class="token punctuation">(</span><span class="token class-name">DelimSpan</span><span class="token punctuation">,</span> <span class="token class-name">Delimiter</span><span class="token punctuation">,</span> <span class="token class-name">TokenStream</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>至于为什么返回的是这个树形结构，可以参考这里 <a href="https://stackoverflow.com/questions/40302026/what-does-the-tt-metavariable-type-mean-in-rust-macros">What does the tt metavariable type mean in Rust macros</a> 和 <a href="https://danielkeep.github.io/tlborm/book/mbe-syn-source-analysis.html">TokenTrees</a> 简而言之就是为了处理宏。</p><p>为了看看这个 Lexing 的过程，我们可以写个简单的程序来看看中间结果：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a = &#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这里 <a href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_parse/src/lexer/mod.rs#L65">parse_token_trees</a>修改代码来把 <code>TokenTree</code> 打印出来：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token keyword">ref</span> token_trees<span class="token punctuation">)</span> <span class="token operator">=</span> token_trees <span class="token punctuation">&#123;</span>    <span class="token macro property">debug!</span><span class="token punctuation">(</span><span class="token string">"token_trees: &#123;:#?&#125;"</span><span class="token punctuation">,</span> token_trees<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过环境变量来把编译器运行过程中的中间结果打印出来，重定向到一个文件，运行命令：<br><pre class="line-numbers language-none"><code class="language-none">RUSTC_LOG&#x3D;debug rustc main.rs &gt; &#x2F;tmp&#x2F;r.log 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>我们可以看到这个程序的 <code>TokenTree</code> 是这样的：</p><p><img src="/images/ob_pasted-image-20230302081527.png" alt=""></p><p>也就是通过分隔符 <code>(...)</code> 、<code>&#123;...&#125;</code>、<code>[...]</code> 把 Token 分组，我最近对这个模块做了一些<a href="https://github.com/rust-lang/rust/pull/108297">改进和重构</a>，任何分隔符不匹配的问题会报错然后终止编译，主要原因是分隔符的不匹配会让 Parser 构造出完全错误的 <code>AST</code>，这样诊断信息就会非常多，而大多数对开发者没有用。</p><h2 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h2><p>Rust 使用的手写的递归下降（自上而下）方法进行语法分析，解析是按语义构造组织的，可以在 <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse/src/parser">rust/compiler/rustc_parse/src/parser</a> 目录看到以下文件：</p><ul><li><code>expr.rs</code></li><li><code>pat.rs</code></li><li><code>ty.rs</code></li><li><code>stmt.rs</code></li></ul><p>我们可以使用以下命令来把整个程序的 <code>AST</code> 打印出来，这对于编译器开发阶段比较有帮助：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">rustc .&#x2F;p&#x2F;main.rs -Zunpretty&#x3D;ast-tree &gt; tree.log 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，读这部代码结合 <a href="https://doc.rust-lang.org/reference/">Rust Reference</a> 会容易很多，因为 parser 很多时候就是 reference 的直译，看懂了 reference 就容易看懂 parsing。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>为什么 Rust 不用那些高级的 parsing 工具而采用手写的方式，我认为一个原因在于手写能给出更好的诊断信息，可以看到 <code>parser</code> 中很多代码在尝试从错误中恢复，比如用户写了下面这个程序：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">const</span> <span class="token constant">FOO</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当 Parser 处理到 <code>&#123;</code> 这个位置，这里看起来用户想写的是一个数组，但把 <code>[</code> 写成了 <code>&#123;</code>，<code>Parser</code> 中的这段代码会先把当前的状态存储为一个 <code>snapshot</code>，然后尝试 <code>1, 2, 3</code> 是否能 parse 成一个数组元素，如果是则能给出一个更为优化的诊断信息，如果不能则恢复到保存的 <code>snapshot</code>：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">maybe_suggest_brackets_instead_of_braces</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token class-name">Span</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">P</span><span class="token operator">&lt;</span><span class="token class-name">Expr</span><span class="token operator">>></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> snapshot <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">create_snapshot_for_diagnostic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">match</span> snapshot<span class="token punctuation">.</span><span class="token function">parse_array_or_repeat_expr</span><span class="token punctuation">(</span><span class="token class-name">Delimiter</span><span class="token punctuation">::</span><span class="token class-name">Brace</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// emit better error here</span>            <span class="token punctuation">...</span>                        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">restore_snapshot</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">mk_expr_err</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>span<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">None</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Parser</code> 中很多代码都在处理类似这种逻辑。错误处理也是一个很大的话题，在 <code>parsing</code> 这个阶段能做的都是明显的语法层面的处理。</p><h3 id="宏展开"><a href="#宏展开" class="headerlink" title="宏展开"></a>宏展开</h3><p>在 <code>Parsing</code> 的过程中会遇到宏，但宏处理需要在 <code>AST</code> 构建之后，所以在这个过程中所有的宏会通过占位符来特殊标识。</p><p>相对 <code>Parsing</code>，宏展开是一个更为复杂的过程，<code>AST</code> 有了之后会 <code>driver</code> 会通过一下调用路径来逐个 crate 展开宏：</p><pre><code>resolver_for_lowering -&gt; configure_and_expand -&gt; expand_crate -&gt; fully_expand_fragment</code></pre><p><a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_expand/src/expand.rs#L409"><code>fully_expand_fragment</code></a> 这个函数是宏展开的主要算法，首先找到 AST 中的占位符，维护一个队列，然后不断地去展开直到所有的宏占位符都处理完毕，再统一加到 AST 中去，这是因为宏代码中也可能包含宏？如果某次迭代没有展开一个宏说明有语法问题。</p><h3 id="Name-resolution"><a href="#Name-resolution" class="headerlink" title="Name resolution"></a>Name resolution</h3><p><code>Name resolution</code> 就是解析 <code>AST</code> 中的所有名字，包括变量名、函数名、类型名、生命周期的命名等等。<br>在宏展开的过程中，我们只处理了 <code>import</code>，而并没有关注所有的名字解析，所有的命名需要等到宏展开处理了之后专门来解析名字，这也是这部分代码很多函数的名字叫做 <code>late_*</code>，很多逻辑在一个叫作 <code>late.rs</code> 的文件里。但我们并没有看到一个 <code>early.rs</code> 的文件，因为被拆分成了三个文件：<code>build_reduced_graph.rs</code>, <code>macros.rs</code> 和 <code>imports.rs</code>。</p><p>我们来写个程序包含一个明显的变量 <code>a</code> 未定义：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>编译器在编译的过程中肯定会报错，使用以下命令来把第一个错误信息当作一个 <code>bug</code>，这样我们就可以获得这个报错的调用堆栈，这是调试编译器一个很有用的小技巧：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rustc ./p/main.rs <span class="token parameter variable">-Z</span> treat-err-as-bug<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过查看堆栈我们可以看到错误是在这里出现的，因此我们找到了 <code>name resolving</code> 的入口在<a href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_resolve/src/lib.rs#L1483">resolve_crate</a>：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Entry point to crate resolution.</span> <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">resolve_crate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> krate<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Crate</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_crate"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"finalize_imports"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">finalize_imports</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token class-name">EffectiveVisibilitiesVisitor</span><span class="token punctuation">::</span><span class="token function">compute_effective_visibilities</span><span class="token punctuation">(</span>sel          <span class="token punctuation">...</span>          <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"late_resolve_crate"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">late_resolve_crate</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_main"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">resolve_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_check_unused"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">check_unused</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_report_errors"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">report_errors</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx             <span class="token punctuation">.</span>sess             <span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_postprocess"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">crate_loader</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>c<span class="token closure-punctuation punctuation">|</span></span> c<span class="token punctuation">.</span><span class="token function">postprocess</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Make sure we don't mutate the cstore from here on.</span>     <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span><span class="token function">untracked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cstore<span class="token punctuation">.</span><span class="token function">leak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>self.late_resolve_crate(krate)</code> 就是按照 <code>crate</code> 逐个去解析里面的 <code>name</code>，而 <code>self.resolve_main()</code> 是找整个程序中是否存在 <code>main</code>。<code>LateResolutionVisitor</code> 就是用来递归地遍历 <code>AST</code> 里的元素，比如 <code>resolve_local</code>，<code>resolve_params</code> 等等。</p><p>这里有一个很重要的概念叫做 <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_resolve/late/struct.Rib.html#"><code>rib</code></a>，我估计是 <code>Rust internal block</code> 的简称🤔，这里有<a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_resolve/late/enum.RibKind.html">各种类型的 <code>rib</code></a>，一个 <code>rib</code> 就是定义了一个命名空间和其对应的 <code>binding</code>:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Rib</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">R</span> <span class="token operator">=</span> <span class="token class-name">Res</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> bindings<span class="token punctuation">:</span> <span class="token class-name">IdentMap</span><span class="token operator">&lt;</span><span class="token class-name">R</span><span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> kind<span class="token punctuation">:</span> <span class="token class-name">RibKind</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比如我们写代码中的一个大括号就会引入一个新的 <code>rib</code>，同样的一个函数或者模块的定义会引入对应的 <code>rib</code>。对于代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那如何能找到在 <code>println!</code> 的时候所用的变量 <code>a</code> 呢？因为变量是可以被覆盖的，可以想象这是一个按 scope 从里往外找的过程，从代码上也可以验证这个猜想，<a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_resolve/src/ident.rs#L279">resolve_ident_in_lexical_scope</a> 函数就是这样实现的。</p><p>在名字解析的过程中，Rust 分别为 types、values、macros 保存了不同的命名空间，因此下面这样的代码虽然看起比较诡异但却是合法的 Rust 代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">type</span> <span class="token type-definition class-name">x</span> <span class="token operator">=</span> <span class="token keyword">u32</span><span class="token punctuation">;</span><span class="token keyword">let</span> x<span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> y<span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// See? x is still a type here.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>名字解析是非常复杂的部分，光 <code>late.rs</code> 这个文件就有 4000 行代码了。之前我做过一个关于<a href="https://github.com/rust-lang/rust/pull/104864/files">名字解析的 PR</a>，当一个变量没在当前 <code>scope</code> 里找到的情况下尝试去 <code>inner scope</code> 找，如果找到则给出建议。这虽然是个不复杂的 PR，但我通过这个 PR 理解了这块的大致逻辑。</p><h3 id="Ast-validation"><a href="#Ast-validation" class="headerlink" title="Ast validation"></a>Ast validation</h3><p>这个阶段没做什么特别复杂的检查，比如这种：</p><ul><li>no more than <code>u16::MAX</code> parameters;</li><li>c-variadic functions are declared with at least one named argument;</li><li>c-variadic argument goes the last in the declaration;</li><li>documentation comments aren’t applied to function parameters;</li></ul><p><code>AstValidator</code> 实现了各种 <code>check_*</code> 函数，通过 <code>visitor pattern</code> 在 AST 里逐个检查对应的元素，在编译器中最常用的设计模式就是 <code>visitor pattern</code> ，所以在 <code>rust_ast</code> 里定义了这个 <a href="https://github.com/rust-lang/rust/blob/13471d3b2046cce78181dde6cfc146c09f55e29e/compiler/rustc_ast/src/visit.rs#L111">Visitor</a> 的 <code>trait</code>：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Visitor</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'ast</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token class-name">Sized</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_ident</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> _ident<span class="token punctuation">:</span> <span class="token class-name">Ident</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_foreign_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">ForeignItem</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk_foreign_item</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk_item</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_local</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> l<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Local</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk_local</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_block</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Block</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk_block</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的自定义 <code>Visitor</code> 只需要实现这个 <code>trait</code> 就行了：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token class-name">Visitor</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token keyword">for</span> <span class="token class-name">AstValidator</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_attribute</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> attr<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Attribute</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">validate_attr<span class="token punctuation">::</span></span><span class="token function">check_attr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>session<span class="token punctuation">.</span>parse_sess<span class="token punctuation">,</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_expr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> expr<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token class-name">Expr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">...</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HIR"><a href="#HIR" class="headerlink" title="HIR"></a>HIR</h2><p>HIR 是 rustc 中使用的主要 IR，是在解析、宏扩展和命名解析之后生成的。HIR 的许多部分与 Rust 表面语法非常相似，除了 Rust 的一些表达式形式已被脱糖。例如， <code>for</code> 循环被转换为 <code>loop</code> 并且不出现在 HIR 中，这使得 HIR 比普通 AST 更易于分析。</p><p>我们可以使用以下命令来展示一个程序的 <code>HIR</code> :</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rustc main.rs <span class="token parameter variable">-Z</span> <span class="token assign-left variable">unpretty</span><span class="token operator">=</span>hir-tree <span class="token operator">></span> tree.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以看到即使一个非常简单的程序，生产的 <code>hir</code> 也是非常长的，因为带了很多编译器里面分析使用的字段，另外 <code>HIR</code> 中也带有对应的代码行，也包括 <code>Span</code> 等这些信息，对生成诊断非常重要。<code>rustc_hir/src/intravisit.rs</code>  定义了一些方便在 <code>HIR</code> 上遍历的 <code>visitor</code>。</p><p>HIR 和 AST 基本是一一对应的，所以整个转换的过程就是遍历一遍 AST，代码在 <code>rustc_ast_lowering</code>。注意 HIR 里的 <code>HirId</code> 非常重要，这个 ID 是后续使用 HIR 时候经常会用到的，所以必须是唯一的。在 lowering 的过程中通过 <code>next_id</code>这个函数来生成唯一的 ID。</p><p>我曾经尝试做过一个比较大的 PR 来保证父节点的 HIR_ID 一定比子节点的小，但是做到后来发现代码中的递归经常需要先创建子节点，然后再创建父节点，这样 HIR_ID 就很难保证顺序，否则代码就改得很难看。如果你感兴趣可以看看能否继续做下去 <a href="https://github.com/rust-lang/rust/pull/103114/files">Assign HirIds in HIR traversal order</a>。</p><p>语法糖什么的都会在这时候处理掉。</p><h3 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h3><p>类型推断是自动检测表达式类型的过程，比如以下代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> things <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    things<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"thing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们并没有显示声明 things 的类型，但是因为后续代码中往 things 里写入了一个字符串，所以 things 的类型可以推断出是 <code>Vec&lt;&amp;str&gt;</code>。</p><p>Rust 使用的是一个改进版本的 <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner (HM)</a> 算法，该算法最先被实现在 ML 系的编程语言中，后来被广泛采用在各种函数式编程语言里。</p><p>这块我目前接触也比较少，记得之前做过一个 PR 尝试修复一个 type inference 的小问题，不过没做完  <a href="https://github.com/rust-lang/rust/pull/107567">Extend Infer ty for binary operators</a>，问题看起来也比较简单</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">myfunction</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> one <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment">// ok</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> two <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        <span class="token operator">!</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// cannot infer type</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> three <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        <span class="token operator">!</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// ok</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">one</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">two</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">three</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量 <code>two</code> 不能被推导出来是因为 <code>i</code> 没有类型，虽然我们知道 <code>a</code> 的类型是 <code>Vec&lt;bool&gt;</code> ，但不能保证 <code>a[i]</code>就是 <code>bool</code> 类型，如果你感兴趣可以试试看能否解决。</p><p>Type inference 有其局限性，2015 年 RFC <a href="https://rust-lang.github.io/rfcs/0803-type-ascription.html">0803-type-ascription</a> 提出来作为补充，但这个 RFC 实现了之后一直没有稳定，最终社区又提出把这个功能给去掉，而这个工作也涉及到大量的改动：<a href="https://github.com/rust-lang/rust/issues/101728">De-RFC 3307: Remove type ascription</a>。</p><h2 id="MIR"><a href="#MIR" class="headerlink" title="MIR"></a>MIR</h2><p>MIR 是比 HIR 更低层次的中间表示，从 HIR 构建。MIR 方便用于控制流分析和代码优化，其中也包括 Rust 特殊的 <strong>borrow checking</strong>。MIR 的关键特性：</p><p>MIR 的一些关键特性是：</p><ul><li>基于控制流图</li><li>没有嵌套表达式</li><li>MIR 中的所有类型都是完全显式的</li></ul><p>更深入了解可以读官方的这篇文章 <a href="https://blog.rust-lang.org/2016/04/19/MIR.html">Introducing MIR</a>。MIR 都是一些比较原子性的操作，离 LLVM 的 IR 比较近，所以很方便后面代码生成部分。另外为了方便做 borrow checking MIR 也会在插入一些 scope 的标签。</p><p>我们可以通过 <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=30074856e62e74e91f06abd19bd72ece">Rust Playground</a> 查看生成出来的 MIR，如何基于 MIR 做数据流分析可参考 <a href="https://rustc-dev-guide.rust-lang.org/mir/dataflow.html">MIR dataflow</a>，在 MIR 上做 <a href="https://rustc-dev-guide.rust-lang.org/borrow_check.html#major-phases-of-the-borrow-checker">borrow checking</a> 也会更精准，NLL(non-lexical lifetime) 就是这样解决的。</p><h2 id="Codegen-代码生成"><a href="#Codegen-代码生成" class="headerlink" title="Codegen 代码生成"></a>Codegen 代码生成</h2><p>一直到这里为止，编译都是在做数据转换，把代码变成中间层表示，然后抽象的等级越来越低，最后把 MIR 生成 LLVM IR，然后生成二进制文件。</p><p>Rust 后端可以是 LLVM、Cranelift 或者 GCC，这些都依赖于第三方库来实现，所以需要最大程度共享一些基础代码，Rust 编译器本身有自己的 LLVM 绑定包。</p><p>在这个阶段也做了如下这些事情：</p><ul><li>为范性类型替换成具体的类型</li><li>为具体类型生成代码称为单态化 (<em>monomorphization</em>)</li><li>MIR 转换为 codegen IR </li><li>调用 codegen 后端生成可执行文件</li></ul><p>代码生成的入口点是 <code>rustc_codegen_ssa::base::codegen_crate</code>。</p><hr><p>总的来说，我理解 Rust 是加了些便于做静态分析的语言特性，比如 lifetime 和 borrow checking 规则，编译器内部也集成了很多静态分析功能。</p><p>当然我们只是从很高的维度去快速过了一遍，里面还有些特殊的部分很复杂但我还没开始细看，比如 <code>trait solving</code> 。</p><p>后续继续更新 😁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个 Rust 程序是如何从源文件编译为二进制文件的？&lt;/p&gt;
&lt;p&gt;如果从头开始看 rustc 的源码会无从下手，我之前通过解决 issue 去读过部分模块的源码，就是 bottom-up 的方式，但我还未从整体上理解 rustc 的源码结构。&lt;/p&gt;
&lt;p&gt;这篇文章主要
      
    
    </summary>
    
    
      <category term="编程" scheme="http://catcoding.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
      <category term="编译器" scheme="http://catcoding.me/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>苹果：为了安全让 M2 吃灰</title>
    <link href="http://catcoding.me/p/apple-perf/"/>
    <id>http://catcoding.me/p/apple-perf/</id>
    <published>2023-03-06T23:20:08.000Z</published>
    <updated>2023-08-12T15:00:30.113Z</updated>
    
    <content type="html"><![CDATA[<p>苹果新的芯片性能真是不错，并且续航很可观，所以我最近买了个 M2 Pro。有几年没使用 Mac 系统了，所以日常使用还有些别扭，但最让我闹心是发现了苹果一个让人大跌眼镜的设计，而我几乎没找到关于这点的中文资料，所以写下来分享给你。</p><p>我日常会花时间在 Rust 编译器项目上，经常需要编译 rustc 和跑单元测试。单元测试大概是 1.4 w 个测试用例，测试框架会并行跑编译并执行后对比结果。我发现这台 Mac 跑测试一共需要 16 分钟，这是不可接受的，因为我之前使用 <code>WSL</code> 也不过 20-30 分钟左右。我用一台 32 c 64 g 的 Linux VM 跑同样的测试只需要 1.5 分钟。</p><p>我这台 Mac 选的配置一般，CPU 核数是 6 性能 + 4 效能，另外内存 32 G，这样算来也不可能有 10 倍的性能之差。在 <a href="https://github.com/rust-lang/rust">Rust 代码仓库</a>跑单元测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./x <span class="token builtin class-name">test</span> tests/ui --force-rerun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以通过 <code>htop</code> 看到明显没有充分利用所有的 CPU，上图是 Mac 的系统资源统计，下图是 Linux VM 的：</p><p><img src="/images/ob_pasted-image-20230308155722.png" alt=""></p><p><img src="/images/ob_pasted-image-20230305225021.png" alt=""></p><p>我实在想不通为什么会这样，因为我之前看到过 <a href="https://twitter.com/m_ou_se/status/1413589063735681028">Mara Bos</a> 发的 M1 Mac 的数据，她大概只需要 9 分钟跑完所有的单元测试。</p><p>然后我在 Rust 开发者论坛 rust-zulip 里发起一个<a href="https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/.E2.9C.94.20Is.20there.20any.20performance.20issue.20for.20MacOS.3F">帖子</a>，很快得到了一些开发者的回复。刚开始有人怀疑是 <code>mdworker_shared</code> 进程的问题，这个进程是为 Spotlight 做索引用的，因为跑测试会不断生成新的临时文件，从 <code>htop</code> 上看这个进程会占用不少 CPU。但我把 Spotlight 彻底关闭掉，性能确实有一点点提高，但这明显不是根本原因。</p><p>我怀疑是不是测试框架用的 <code>threads</code> 数目不对，看代码是通过这个 <a href="https://github.com/rust-lang/rust/blob/0fbfc3e76916521b509b63286296dd0762170d34/library/test/src/helpers/concurrency.rs#L11">get_concurrency</a> 获取的，我通过 <code>RUST_TEST_THREADS</code> 尝试把数目提高，但是也没卵用。</p><p>Eric Huss 用的是 M2 Max，他跑测试花费的时间是 9 分钟，这个结果显然也不能匹配上高贵的 Max 配置。</p><p>后来有人提到是不是因为 <code>SIP</code>，<strong>Huss 关闭 <code>SIP</code> 之后跑测试时间立马从 9 分钟减少到 1 分 36 秒 ! 这几乎是 5 倍多的提速。</strong> 另外，如果把 <code>SIP</code> 打开但把网络给关闭掉，同样能得到类似的提速。</p><p>这就是说跑单元测试的时候系统在不断地发送网络请求，这也解释了为什么我对比国外的用户跑测试所用的时间会更长，因为我走了 VPN 啊！我关闭 <code>SIP</code> 之后测试时间从 16 分钟提高到 153 秒，这可是 10x 的提速！</p><p>那么 <code>SIP</code> 是什么？</p><p>这东西全称 <a href="https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection">System Integrity Protection</a>，译为系统完整性保护：</p><blockquote><p>System Integrity Protection (SIP) in macOS protects the entire system by preventing the execution of unauthorized code. The system automatically authorizes apps that the user downloads from the App Store. The system also authorizes apps that a developer notarizes and distributes directly to users. The system prevents the launching of all other apps by default.</p><p>During development, it may be necessary for you to disable SIP temporarily to install and test your code. You don’t need to disable SIP to run and debug apps from Xcode, but you might need to disable it to install system extensions, such as DriverKit drivers.</p></blockquote><p>SIP 是 OS X El Capitan 时开始采用的一项安全技术，目的是为了限制 root 账户对系统的完全控制权，也叫 Rootless 保护机制。从文档看出，<strong>苹果自家的 <code>Xcode</code> 系统是做了特殊处理的</strong>，但第三方软件需要经过 <code>SIP</code> 的检查。</p><p>更多细节请参考这篇文章 <a href="https://sigpipe.macromates.com/2020/macos-catalina-slow-by-design/">macOS 10.15: Slow by Design</a>，<strong>简而言之 <code>SIP</code> 会在我们跑任软件之前，把你的执行文件做一个校验和，然后通过网络请求发送到让人敬畏的苹果服务器，就是为了检测是否是恶意软件！</strong></p><p>在我跑单元测试的时候，通过查看 Mac 的系统日志可以发现这么一条关键信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">log stream <span class="token operator">|</span> <span class="token function">grep</span> Xprotect<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/ob_pasted-image-20230306224206.png" alt=""></p><p><code>XprotectService</code> 这个就是在检查我跑测试用到的一个 <code>dylib</code> 文件。<code>Xprotect</code> 是一个病毒扫描器，它会检查可执行文件是否在已知恶意软件列表中。</p><p>这真是个让人无语的设计！</p><p>这不仅适用于从网络下载的文件，也适用于你自己编译的程序或者是写的一小段脚本。因此，即使你编写了一行 shell 脚本并在终端中运行它，可能也会有延迟，在 HackerNews 上看到<a href="https://news.ycombinator.com/item?id=23274033">一个中国开发者</a>发的可能有几秒的延迟：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">$'#!/bin/sh<span class="token entity" title="\n">\n</span>echo Hello'</span> <span class="token operator">></span> /tmp/test.sh <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> a+x /tmp/test.sh<span class="token function">time</span> /tmp/test.sh <span class="token operator">&amp;&amp;</span> <span class="token function">time</span> /tmp/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>PS：如果你运行过这个命令把 <code>Terminal</code> 加到可信列表，跑脚步就没这个问题了：<br><pre class="line-numbers language-console" data-language="console"><code class="language-console">sudo spctl developer-mode enable-terminal<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>更让人吐血的是，此问题已报告给了苹果，<strong>然而苹果回应说这是“设计使然”</strong>！而你也会看到更多人在网络上反馈同样的性能问题，比如：</p><p><a href="https://www.reddit.com/r/linux/comments/tj12vw/hugo_runs_twice_as_fast_in_asahi_linux_than_macos/">Hugo runs twice as fast in Asahi Linux than macOS on the same M1 Mac system</a></p><p>好了，如果你也会频繁跑大量的程序，可能也会受此影响。为什么我说”可能“，是因为这东西太复杂了，我还没搞清楚所有细节！官方文档关于 <code>SIP</code> 只有寥寥数语，如果你想了解更多关于 <code>SIP</code> 的资料，可以参考这篇博文 <a href="https://derflounder.wordpress.com/2015/10/01/system-integrity-protection-adding-another-layer-to-apples-security-model/">System Integrity Protection – Adding another layer to Apple’s security model</a>。</p><p>当我粗看这篇文章的时候，以为可以配置一下 <code>/System/Library/Sandbox/rootless.conf</code> 就可以忽略某些目录的文件，结果是我太幼稚了。我问 bjorn3 怎么回事，得到的回答是：</p><blockquote><p>The system file protection is only a small part of the protections against malware macOS has. Xprotect is a virus scanner which checks all executables against a liat of known malware. There is signature checking (AMFI) which also checks if the certificate the executable has been signed with has been revoked (using an internet service from apple). This also checks if the entitlements the executable declares are allowed or for example only allowed by apple signed executables (like the SIP bypass entitlement). There is also a check that the application is allowed to access certain protected directories like your documents or images directory. And there are a couple of other checks. These are performed independent of where the executable is stored.</p></blockquote><p>看起来就只有全关闭这条路了？如果你想关闭 <code>SIP</code>，还有那么点麻烦：</p><ol><li>重启 Mac，按住 Command + R 直到屏幕上出现苹果的标志和进度条，进入 Recovery 模式。(如果是新的 Mac 就在启动的时候长按住电源键)</li><li>在屏幕上方的工具栏找到并打开终端，输入命令 <code>csrutil disable</code> ；</li><li>关掉终端，重启 Mac；</li><li>重启以后可以在终端中查看状态确认。</li></ol><p>关闭也许会让你的 Mac 处于裸奔状态，我也不清楚有多大的安全隐患。开启 SIP 只需在上面第 2 步命令改为 <code>csrutil enable</code> 即可。</p><hr><p>我上一个 Mac 是 2012 年买的，一共用了六七年，那台 Mac 真是非常耐用，所有的硬件这些年都没出现问题。苹果的硬件一直领先业界几个段位，我上次买是因为 Retina 屏幕，这次买是因为苹果自家的芯片。</p><p>有人说 Mac 是最适合开发者的设备，但苹果关心开发者么？我在 Rust Zulip 问一个对 Mac 很熟的开发者，这都快七年了为什么苹果不修复这个明显的问题，他的回答是：</p><blockquote><p>从我作为一个局外人的观察来看，苹果公司不再像以前那样关心开发者了。他们曾经有一流的文档资料，但现在你要是能找到一点点文档就该知足了。</p></blockquote><p>也许在苹果眼里只有使用 <code>Xcode</code> 的开发者才能称之为开发者！否则绝不会弄出这么个脑残设计，事实上很多开发者都没有意识到这是系统的默认行为，这么牛逼的芯片很多时候是在吃灰。</p><p>这不是 <code>Secure by Design</code>，而是 <code>Slow by Design</code>！</p><hr><p><strong>Update</strong>:<br>一个读者指出了更简单的办法，把你信任的工具加入到 Developer Tools:<br><img src="/images/ob_pasted-image-20230307105335.png" alt=""><br>注意必须通过 UI 设置，这条命令虽然提示设置成功了，但是其实没成功 😂：<br><img src="/images/ob_pasted-image-20230307110005.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;苹果新的芯片性能真是不错，并且续航很可观，所以我最近买了个 M2 Pro。有几年没使用 Mac 系统了，所以日常使用还有些别扭，但最让我闹心是发现了苹果一个让人大跌眼镜的设计，而我几乎没找到关于这点的中文资料，所以写下来分享给你。&lt;/p&gt;
&lt;p&gt;我日常会花时间在 Rust 
      
    
    </summary>
    
    
      <category term="工具" scheme="http://catcoding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Apple" scheme="http://catcoding.me/tags/Apple/"/>
    
      <category term="Mac" scheme="http://catcoding.me/tags/Mac/"/>
    
      <category term="安全" scheme="http://catcoding.me/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>为 Rust 做贡献的经验分享</title>
    <link href="http://catcoding.me/p/how-to-contribute-to-rust/"/>
    <id>http://catcoding.me/p/how-to-contribute-to-rust/</id>
    <published>2023-01-18T21:36:07.000Z</published>
    <updated>2023-08-12T15:00:30.117Z</updated>
    
    <content type="html"><![CDATA[<p>2022 年下半年我花了很多时间为 Rust 做贡献，最近一个阶段性的收获是我获得了 <a href="https://foundation.rust-lang.org/news/community-grants-program-awards-announcement-introducing-our-latest-project-grantees/">Rust Foundation 项目资助</a> 🙌。</p><p>这个收获完全是副产物，我在 8 月份开始做这些的时候不知道 Rust Foundation 有这类资助，在为 Rust compiler 做了 30 多个 PR 后我发现了这个资助项目，然后很快就发起了申请。我的项目计划是：</p><blockquote><p>To support contributions to the Rust compiler, and to continue to blog about the experience, sharing the learning experience, knowledge, and skills with others.</p></blockquote><p>所以除去写代码，最近几个月我会写一些 Rust 相关的技术文章。我之前写过一篇 <a href="https://catcoding.me/p/my-experience-learning-rust/">我如何学“会”了 Rust</a> ，分享了一些去年通过做开源项目来学习 Rust 的相关经验。</p><p>这篇主要集中在如何参与到 Rust compiler 相关的开发中来，但我觉得纯写技术文章会有些单调，而且很多资料都有官方文档，翻译为中文意义不大，所以这篇我主要写自己的感受和经验。</p><h2 id="我如何开始"><a href="#我如何开始" class="headerlink" title="我如何开始"></a>我如何开始</h2><p>我一直是通过为项目做贡献来学习 Rust，因为纯看书或者文档我觉得收获不大，大概是年纪大了看了就忘记了🐸。</p><p>很多事情都不是规划好的，我觉得生活充满了随机性，但我会努力和乐观些，并保持好奇心。好奇心对程序员很重要，这是源动力。</p><p>我的第一个 Rust compiler 的 PR 是在 2021 年 9 月做的 <a href="https://github.com/rust-lang/rust/pull/88493">Remove duplicated diagnostics</a> 。这是我在使用 Rust 的开发过程中发现的问题，一时兴起翻看 compiler 的代码想知道这个现象是如何产生的，毕竟这看起来很容易 debug。</p><p>事实证明我低估了上手的难度，这个问题我大概花了一周的业余时间，期间当然也花了不少时间去看文档，我还尝试使用 gdb 去一行行跟踪代码。最终的修复虽然也比较简单，但是代码 review 来回好多次。</p><p>做完第一个 PR 之后，我觉得很有成就感，但随即我就去搞其他的了。一直到 2022 年的 8 月，我偶然又看了几个 issue，感觉有一些 parser 和报错信息相关的问题比较容易解决，所以就又开始做了。过段时间刚好是微软的 hackthon，有两周左右时间可以用来学习感兴趣的东西，所以我的时间比较多地投入到上面，一直到现在都会规律性地给 Rust 做贡献。</p><p>我解决的问题比较零碎，很多都涉及 diagnostics，也有些涉及 Infra 之类的，还有些是纯粹编译器里的 bugfix，我喜欢解决一个个独立的 issue，这让我觉得每个新的问题都是一个小谜题，而做稍大一些的改动需要耗费更持久的精力。后续我会试着找一些固定的方向做。</p><h2 id="贡献流程"><a href="#贡献流程" class="headerlink" title="贡献流程"></a>贡献流程</h2><p>Rust 编译器的仓库里面包含了上万个测试用例，不管是解决 bug 还是做一些新功能开发，最好先写一些最小测试用例，然后不断修改代码、编译、测试，直到用例测试通过。</p><p>编译型语言最大的弊端是失去了 interactive programming 的乐趣，特别是 Rust 这种编译特别耗时的语言，不是很适合做探索式编程，我的办法是编译的时候就继续看代码，还有在关键的地方多加一些日志信息。</p><p>在这个过程中，最耗时的可能是代码 review 这个阶段，PR 发出来之后 rustbot 会从列表中随机挑选一个 maintainer 来 review 代码，但因为目前很多 maintainer 的 review list 积累过长，所以需要等待很久才能开始。目前社区正在讨论如何解决这个问题 <a href="https://internals.rust-lang.org/t/did-we-start-reviewing-prs-slower/18033">Did we start reviewing PRs slower?</a>，我的解决办法是 PR 发出之后就开始解决其他问题，如果有反馈再切回这个分支来修改。</p><p><img src="/images/ob_pasted-image-20230117125646.png" alt=""><br>对于比较大的开源项目，需要用大量时间去和其他人沟通和讨论，所以写作能力很重要。看文档、理解代码、调试代码、和其他人交流，这些是软件开发中的核心能力，在做开源工作时得到很好的提升，可以很快地迁移到其他项目上。</p><h2 id="如何选择-issue"><a href="#如何选择-issue" class="headerlink" title="如何选择 issue"></a>如何选择 issue</h2><p>大家可能会有个误解，认为要为编译器做贡献必须得对 Rust 很了解。我认为不是的，以我的经验和水平算也不上很资深的 Rust 开发人员，我并没有在实际工作和生产环境使用过 Rust，但对编译器做贡献并不需要对语言本身了如指掌。</p><p>如果涉及到语言本身的语义、语法的改动，则需要 RFC 的流程，经过社区大量的讨论，这些对于新手来说相对不容易，但编译器项目里面本身有很多用户发现的问题、流程改进、bugfix、重构、优化等需要做，所以新手最适合从解决 issue 开始。</p><p>当掌握了 Rust 的主要的语法，能看懂大部分代码的情况下就可以开始，新手需要通过一些简单的问题来上手，带着问题看代码更有效果。</p><p>但刚开始，你可能不知道自己能解决什么问题，可以从 <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AE-mentor">E-mentor</a>, <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AE-easy">E-easy</a>, <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AE-help-wanted">E-help-wanted</a> 这类标签去找一些相对简单的问题来解决。但如果找不到适合的，也可以随机找一些自己能看懂的问题，试着去解决。</p><p><a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AA-diagnostics">A-diagnostics</a> 的问题通常是完善或者修复 rustc 的报错信息，这类问题适合新手。Rust 编译器里面很多代码都是为了给用户提供尽量有用的报错信息，Rust 在这块的关注和投入超过绝大部分编程语言，正如 <a href="https://github.com/estebank">estebank</a>写道：</p><blockquote><p>We spent decades trying to invent a sufficiently smart compiler when we should have been inventing a sufficiently empathetic one.</p></blockquote><p>既然 Rust 学习曲线比较陡峭，我们应该让编译器善解人意。这类问题通常需要去理解 AST，推测用户的编程意图，给他们提供有用的帮助信息。</p><p>我们可以通过搜索关键字的方式来找到错误信息对应的代码，但并不是所有的这类问题都容易解决，有的时候需要在不同的阶段中去验证，比如我这个 PR <a href="https://github.com/rust-lang/rust/pull/101975">Suggest to use . instead of ::</a>，方法调用报错是在 <code>resolve</code> 阶段出现的，但是我们需要等到 <code>hir typeck</code> 阶段才能去复核是否能给出帮助信息。</p><p>有的 <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AI-ICE">ICE</a> 问题也比较容易解决，比如一些 corner case 没有处理的情况，通常有一个粗暴的解决方法，但从各种修复方案中权衡利弊也是门艺术。</p><h2 id="如何发现问题"><a href="#如何发现问题" class="headerlink" title="如何发现问题"></a>如何发现问题</h2><p>做编译器开发，一个重要的转变是从语言的使用者变成改进者，编程语言是工具，编译器也就是另外一个软件，这都是可以改进的。如果视角变了，就能发现很多问题。</p><p>有一天在 Twitter 上看到这个分享，我的疑问是为什么编译器会同时出现两个建议，第一个明显是只适合关心返回结果的情况：</p><p><img src="/images/ob_pasted-image-20230117005319.png" alt=""></p><p>所以我记录下来，随后发起一个 PR 对此做了修复 <a href="https://github.com/rust-lang/rust/pull/104875">Properly handle postfix inc/dec</a>。</p><p>发现问题的另一个来源是日常使用，比如我在日常使用 Rust 时发现如果我少输入了一个 ‘}’，编译器可能无法指出括号不匹配的位置，而且如果源文件很长可能会报出大量错误，这是因为大括号的不匹配没有得到适当的处理，导致 parser 出来的语法树是完全不对的，而编译器总是尝试去从错误中恢复。这种情况下除了指出缺少 ‘}’，给出其他信息都是无法帮助用户尽快修复问题的，所以我做了另一个 <a href="https://github.com/rust-lang/rust/pull/104012">PR 去解决这个问题</a>。</p><h2 id="一些小贴士"><a href="#一些小贴士" class="headerlink" title="一些小贴士"></a>一些小贴士</h2><p><a href="https://rustc-dev-guide.rust-lang.org/getting-started.html">Guide to Rustc Development</a> 这个文档需要经常看，这份文档相对源码可能有些地方不够新，但对了解编译器的各个主题概要非常有帮助。</p><p>Rust 有一个不那么完整的 <a href="https://doc.rust-lang.org/reference/">Reference</a>，如果你看不懂某部分代码，很可能是不知道相关的名词，这时候翻看这个 reference 就会很有帮助。</p><p>在 rustc 的开发过程中，<code>x.py</code> 是经常使用到的命令，我把自己常用的命令写成了一个 <a href="https://github.com/chenyukang/share/blob/main/justfile">justfile 配置文件</a>，这样做测试、查日志、rebase 之类的会比较方便。</p><p>在调试过程中，日志加上读代码比 gdb 一行行去跟踪更有用。通过阅读代码，在关键的步骤打印日志，通过运行时的日志去验证自己的猜想，这样我们可以在脑海中获得代码的主要流程和组织结构，而通过 gdb 跟踪容易迷失在具体的细节里。</p><p>使用 rust-analyzer 读 Rust 代码很容易，特别是 <code>show call hierarchy</code> 对理解函数调用特别有用。强类型系统对于写代码可能是一个负担，但对于阅读和理解代码绝对有很大的好处，类型就是文档。</p><p>在开发过程中如果遇到问题，可以去 <a href="https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp">t-compiler/help</a> 发帖求帮助，zulip 是 Rust 编译器开发人员使用的讨论工具，你也可以在上面通过用户名找具体的人讨论问题，通常大家都是很乐于帮助的。</p><p>另一个好的学习方法是去 review 其他人的 PR，刚开始看不懂没关系，可以看看大致思路。有的 issue 如果我感兴趣但没时间去解决我会点击订阅通知，这样 issue 如果被 close 我会收到邮件，我可能会去看看 PR。</p><p>国内开发人员在做开源的时候所会面临的一个问题是语言障碍，这只能通过长时间的不断练习能提高。如果想中文沟通，欢迎找我交流。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你对编译方面的开发不感兴趣，也可以试着去找其他领域，Rust 在 Infra、WebAssembly 和 Web 开发、嵌入式、游戏、安全等领域都在快速发展。另外，对 Rust 做贡献不限制于写代码，报出好的 issue、改善文档和翻译、加入讨论这些都属于社区贡献。</p><p>如果你只是想了解一些编译相关的知识，这些资料非常适合入门：</p><ul><li><a href="http://craftinginterpreters.com/">Crafting Interpreters</a></li><li><a href="https://github.com/rui314/9cc">9cc: A Small C Compiler</a> </li><li><a href="https://github.com/utam0k/r9cc">r9cc: Toy C compiler</a></li></ul><p>创造运气在于多做并且让更多人知道，做开源和分享对程序员来说是一个创造运气的事。希望我的分享对你有用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2022 年下半年我花了很多时间为 Rust 做贡献，最近一个阶段性的收获是我获得了 &lt;a href=&quot;https://foundation.rust-lang.org/news/community-grants-program-awards-announcement-in
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
</feed>
