<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员的喵</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://catcoding.me/"/>
  <updated>2023-03-12T16:24:30.500Z</updated>
  <id>http://catcoding.me/</id>
  
  <author>
    <name>yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 编译器源码概要</title>
    <link href="http://catcoding.me/p/rustc-source/"/>
    <id>http://catcoding.me/p/rustc-source/</id>
    <published>2023-03-13T00:24:08.000Z</published>
    <updated>2023-03-12T16:24:30.500Z</updated>
    
    <content type="html"><![CDATA[<p>一个 Rust 程序是如何从源文件编译为二进制文件的？</p><p>如果从头开始看 rustc 的源码会无从下手，我之前通过解决 issue 去读过部分模块的源码，就是 bottom-up 的方式，但我还未从整体上理解 rustc 的源码结构。</p><p>这篇文章主要是我在重看 <a href="https://rustc-dev-guide.rust-lang.org/getting-started.html">Rust Compiler Development Guide</a> 的一些随手记录，还有些自己的动手实验，旨在厘清编译器的大致脉络，理解每个阶段做了些什么，如果你想看更为完整的文档请参考官方的手册。</p><p>Rust 编译器分为这几个主要的阶段，回顾我目前做的工作大多集中在 <code>MIR</code> 之前，分阶段从前到后接触得越少 😊</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>编译器是典型的输入输出系统，每个阶段都有对应的入和出。我们经常可以看到 <code>lowering</code> 这个术语，这个 <code>lowering</code> 的对象可以是源程序、AST、IR，不断地把程序中的抽象由高变低的过程，到 <code>MIR</code> 就已经是类似 <code>LLVM IR</code>  这个级别了。</p><p><img src="/images/ob_pasted-image-20230303200344.png" alt=""></p><p><strong>Lexing</strong>: 把源程序解析为 token 流。</p><p><strong>Parsing</strong>: 把 token 流转换为 AST（Abstract Syntax Tree），这期间很做宏扩展、AST 验证、名称解析和早期 linting。</p><p><strong>HIR lowering</strong>: 将 AST 转换为高级中间表示 HIR（High-level IR），这是一种对编译器更友好的 AST 表示，其中也涉及很多诸如循环和 <code>async fn</code> 之类的脱糖。然后我们使用 HIR 进行类型推断（type inference）、特征求解（trait solving）和类型检查（type checking）。</p><p><strong>MIR lowering</strong>: 将 HIR 转换到 MIR（Middle-level IR），用于借用检查和其他重要的基于数据流的检查，例如检查未初始化的值。在此过程中还构建了更加脱糖的 THIR（Typed HIR），THIR 主要用于 pattern checking 检查。</p><p><strong>Code generation</strong>: 主要基于 LLVM 做代码生成，也支持 Cranelift。</p><h2 id="编译入口"><a href="#编译入口" class="headerlink" title="编译入口"></a>编译入口</h2><p>当我们运行编译命令 <code>rustc main.rs</code> 时，编译器首先会通过 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_driver_impl/src/lib.rs">rustc_driver</a> 这个最上层的组件来处理输入参数，然后调用更基础的组件来启动编译行为。</p><p>编译器的入口在于 <a href="https://github.com/rust-lang/rust/blob/5983a3a99ea631da9d7d1ce510a6761913f92a89/compiler/rustc/src/main.rs#L64">rustc_driver::main</a>，接着调用：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token class-name">RunCompiler</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> callbacks<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>真正的跑编译流程的过程在于 <a href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_driver_impl/src/lib.rs#L232">run_compiler</a>，主要流程还是 <code>Parsing</code>，<code>Analysising</code>，<code>Linking</code>。我们看到很多调用是从一个叫做 <code>queries</code> 的东西开始的，比如：</p><ul><li><code>queries.parse()</code>，</li><li><code>queries.global_ctxt()?.enter(|tcx| tcx.analysis(()))</code></li></ul><p>这是 Rust 编译器的一个特点，正在从传统的 <code>pass-based</code> 方式转向 <code>demand-driven</code>，按需编译的主要思路是既然编译是典型的输入输出系统，同一个输入的输出是一样的，所以适合用缓存来减少重复计算。这是算法设计中 <code>Memoization</code> 的思路，详细的设计文档在 <a href="https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md">rustc-on-demand-and-incremental</a>。</p><p>好处主要在于增量编译时加快编译速度，结果就是用户更改的少量的代码，编译速度会更快。另外一个原因是这样方便并行编译。</p><p>但目前还有很多 <code>phase</code> 并没有完全实现这种按需处理的方式，目前只有 <code>HIR</code> 到 <code>LLVM IR</code> 之间的步骤是查询的。我们可以在这里看到默认的 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_interface/src/passes.rs#L626">query provider</a>:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token constant">DEFAULT_QUERY_PROVIDERS</span><span class="token punctuation">:</span> <span class="token class-name">LazyLock</span><span class="token operator">&lt;</span><span class="token class-name">Providers</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">LazyLock</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> providers <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Providers</span><span class="token punctuation">::</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    providers<span class="token punctuation">.</span>analysis <span class="token operator">=</span> analysis<span class="token punctuation">;</span>    providers<span class="token punctuation">.</span>hir_crate <span class="token operator">=</span> <span class="token namespace">rustc_ast_lowering<span class="token punctuation">::</span></span>lower_to_hir<span class="token punctuation">;</span>    providers<span class="token punctuation">.</span>output_filenames <span class="token operator">=</span> output_filenames<span class="token punctuation">;</span>    providers<span class="token punctuation">.</span>resolver_for_lowering <span class="token operator">=</span> resolver_for_lowering<span class="token punctuation">;</span>    <span class="token namespace">proc_macro_decls<span class="token punctuation">::</span></span><span class="token function">provide</span><span class="token punctuation">(</span>providers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">...</span><span class="token punctuation">.</span>    <span class="token namespace">rustc_codegen_ssa<span class="token punctuation">::</span></span><span class="token function">provide</span><span class="token punctuation">(</span>providers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>providers<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这些 <code>provider</code> 是按照 <code>crate</code> 这个维度来组织的，我在日常开发中经常碰到的一个问题是，如果我切换了 <code>compiler</code> 的代码分支，然后直接进行增量编译，最终链接的时候报错，这大概是因为某些 <code>crate</code> 的代码变了，而缓存的结果是老的，重新 <code>clean</code> 后编译就好了，以后再排查一下具体原因。</p><p><code>query</code> 引入的另外一个问题是导致错误堆栈特别长，在调试过程中经常碰到几百行的堆栈信息，我打算在这个 <a href="https://github.com/rust-lang/rust/issues/107910">Issue</a> 里尝试解决。</p><h2 id="Lexing"><a href="#Lexing" class="headerlink" title="Lexing"></a>Lexing</h2><p>Lexing 的过程和其他编译器类似，我们可以理解为给定字符串的源文件，输出一个 token 的数组。对应的代码在 <a href="https://github.com/rust-lang/rust/blob/5983a3a99ea631da9d7d1ce510a6761913f92a89/compiler/rustc_lexer/src/lib.rs#L326">compiler/rustc_lexer</a>，这个 <code>advance_token</code> 就是读取下一个 token。</p><p>但是 Rust lexing 过程中的特殊点在于输出为一个称之为 token 流的东西，<code>advance_token</code> 被一个叫做 <code>tokentrees.rs</code> 的模块调用，处理后的结果是 <code>TokenStream</code>，其实也就是一组 Token，只是定义为一个树形的结构：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">TokenStream</span><span class="token punctuation">(</span><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token class-name">Lrc</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">TokenTree</span><span class="token operator">>></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其定义为：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">TokenTree</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/// A single token.</span>    <span class="token class-name">Token</span><span class="token punctuation">(</span><span class="token class-name">Token</span><span class="token punctuation">,</span> <span class="token class-name">Spacing</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">/// A delimited sequence of token trees.</span>    <span class="token class-name">Delimited</span><span class="token punctuation">(</span><span class="token class-name">DelimSpan</span><span class="token punctuation">,</span> <span class="token class-name">Delimiter</span><span class="token punctuation">,</span> <span class="token class-name">TokenStream</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>至于为什么返回的是这个树形结构，可以参考这里 <a href="https://stackoverflow.com/questions/40302026/what-does-the-tt-metavariable-type-mean-in-rust-macros">What does the tt metavariable type mean in Rust macros</a> 和 <a href="https://danielkeep.github.io/tlborm/book/mbe-syn-source-analysis.html">TokenTrees</a> 简而言之就是为了处理宏。</p><p>为了看看这个 Lexing 的过程，我们可以写个简单的程序来看看中间结果：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a = &#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这里 <a href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_parse/src/lexer/mod.rs#L65">parse_token_trees</a>修改代码来把 <code>TokenTree</code> 打印出来：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token keyword">ref</span> token_trees<span class="token punctuation">)</span> <span class="token operator">=</span> token_trees <span class="token punctuation">&#123;</span>    <span class="token macro property">debug!</span><span class="token punctuation">(</span><span class="token string">"token_trees: &#123;:#?&#125;"</span><span class="token punctuation">,</span> token_trees<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过环境变量来把编译器运行过程中的中间结果打印出来，重定向到一个文件，运行命令：<br><pre class="line-numbers language-none"><code class="language-none">RUSTC_LOG&#x3D;debug rustc main.rs &gt; &#x2F;tmp&#x2F;r.log 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>我们可以看到这个程序的 <code>TokenTree</code> 是这样的：</p><p><img src="/images/ob_pasted-image-20230302081527.png" alt=""></p><p>也就是通过分隔符 <code>(...)</code> 、<code>&#123;...&#125;</code>、<code>[...]</code> 把 Token 分组，我最近对这个模块做了一些<a href="https://github.com/rust-lang/rust/pull/108297">改进和重构</a>，任何分隔符不匹配的问题会报错然后终止编译，主要原因是分隔符的不匹配会让 Parser 构造出完全错误的 <code>AST</code>，这样诊断信息就会非常多，而大多数对开发者没有用。</p><h2 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h2><p>Rust 使用的手写的递归下降（自上而下）方法进行语法分析，解析是按语义构造组织的，可以在 <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse/src/parser">rust/compiler/rustc_parse/src/parser</a> 目录看到以下文件：</p><ul><li><code>expr.rs</code></li><li><code>pat.rs</code></li><li><code>ty.rs</code></li><li><code>stmt.rs</code></li></ul><p>我们可以使用以下命令来把整个程序的 <code>AST</code> 打印出来，这对于编译器开发阶段比较有帮助：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">rustc .&#x2F;p&#x2F;main.rs -Zunpretty&#x3D;ast-tree &gt; tree.log 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外，读这部代码结合 <a href="https://doc.rust-lang.org/reference/">Rust Reference</a> 会容易很多，因为 parser 很多时候就是 reference 的直译，看懂了 reference 就容易看懂 parsing。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>为什么 Rust 不用那些高级的 parsing 工具而采用手写的方式，我认为一个主要原因在于手写能给出更好的诊断信息，可以看到 <code>parser</code> 中很多代码在尝试从错误中恢复，比如用户写了下面这个程序：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">const</span> <span class="token constant">FOO</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当 Parser 处理到 <code>&#123;</code> 这个位置，这里看起来用户想写的是一个数组，但把 <code>[</code> 写成了 <code>&#123;</code>，<code>Parser</code> 中的这段代码会先把当前的状态存储为一个 <code>snapshot</code>，然后尝试 <code>1, 2, 3</code> 是否能 parse 成一个数组元素，如果是则能给出一个更为优化的诊断信息，如果不能则恢复到保存的 <code>snapshot</code>：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">maybe_suggest_brackets_instead_of_braces</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token class-name">Span</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">P</span><span class="token operator">&lt;</span><span class="token class-name">Expr</span><span class="token operator">>></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> snapshot <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">create_snapshot_for_diagnostic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">match</span> snapshot<span class="token punctuation">.</span><span class="token function">parse_array_or_repeat_expr</span><span class="token punctuation">(</span><span class="token class-name">Delimiter</span><span class="token punctuation">::</span><span class="token class-name">Brace</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// emit better error here</span>            <span class="token punctuation">...</span>                        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">restore_snapshot</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">mk_expr_err</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>span<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">None</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Parser</code> 中很多代码都在处理类似这种逻辑。错误处理也是一个很大的话题，在 <code>parsing</code> 这个阶段能做的都是明显的语法层面的处理。</p><h3 id="宏展开"><a href="#宏展开" class="headerlink" title="宏展开"></a>宏展开</h3><p>在 <code>Parsing</code> 的过程中会遇到宏，但宏处理需要在 <code>AST</code> 构建之后，所以在这个过程中所有的宏会通过占位符来特殊标识。</p><p>相对 <code>Parsing</code>，宏展开是一个更为复杂的过程，<code>AST</code> 有了之后会 <code>driver</code> 会通过一下调用路径来逐个 crate 展开宏：</p><pre><code>resolver_for_lowering -&gt; configure_and_expand -&gt; expand_crate -&gt; fully_expand_fragment</code></pre><p><a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_expand/src/expand.rs#L409"><code>fully_expand_fragment</code></a> 这个函数是宏展开的主要算法，首先找到 AST 中的占位符，维护一个队列，然后不断地去展开直到所有的宏占位符都处理完毕，再统一加到 AST 中去，这是因为宏代码中也可能包含宏？如果某次迭代没有展开一个宏说明有语法问题。</p><h3 id="Name-resolution"><a href="#Name-resolution" class="headerlink" title="Name resolution"></a>Name resolution</h3><p><code>Name resolution</code> 就是解析 <code>AST</code> 中的所有名字，包括变量名、函数名、类型名、生命周期的命名等等。<br>在宏展开的过程中，我们只处理了 <code>import</code>，而并没有关注所有的名字解析，所有的命名需要等到宏展开处理了之后专门来解析名字，这也是这部分代码很多函数的名字叫做 <code>late_*</code>，很多逻辑在一个叫作 <code>late.rs</code> 的文件里。但我们并没有看到一个 <code>early.rs</code> 的文件，因为被拆分成了三个文件：<code>build_reduced_graph.rs</code>, <code>macros.rs</code> 和 <code>imports.rs</code>。</p><p>我们来写个程序包含一个明显的变量 <code>a</code> 未定义：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>编译器在编译的过程中肯定会报错，使用以下命令来把第一个错误信息当作一个 <code>bug</code>，这样我们就可以获得这个报错的调用堆栈，这是调试编译器一个很有用的小技巧：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rustc ./p/main.rs -Z treat-err-as-bug<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过查看堆栈我们可以看到错误是在这里出现的，因此我们找到了 <code>name resolving</code> 的入口在<a href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_resolve/src/lib.rs#L1483">resolve_crate</a>：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Entry point to crate resolution.</span> <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">resolve_crate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> krate<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Crate</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_crate"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"finalize_imports"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">finalize_imports</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token class-name">EffectiveVisibilitiesVisitor</span><span class="token punctuation">::</span><span class="token function">compute_effective_visibilities</span><span class="token punctuation">(</span>sel          <span class="token punctuation">...</span>          <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"late_resolve_crate"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">late_resolve_crate</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_main"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">resolve_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_check_unused"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">check_unused</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_report_errors"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">report_errors</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx             <span class="token punctuation">.</span>sess             <span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_postprocess"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">crate_loader</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>c<span class="token closure-punctuation punctuation">|</span></span> c<span class="token punctuation">.</span><span class="token function">postprocess</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Make sure we don't mutate the cstore from here on.</span>     <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span><span class="token function">untracked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cstore<span class="token punctuation">.</span><span class="token function">leak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>self.late_resolve_crate(krate)</code> 就是按照 <code>crate</code> 逐个去解析里面的 <code>name</code>，而 <code>self.resolve_main()</code> 是找整个程序中是否存在 <code>main</code>。<code>LateResolutionVisitor</code> 就是用来递归地遍历 <code>AST</code> 里的元素，比如 <code>resolve_local</code>，<code>resolve_params</code> 等等。</p><p>这里有一个很重要的概念叫做 <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_resolve/late/struct.Rib.html#"><code>rib</code></a>，我估计是 <code>Rust internal block</code> 的简称🤔，这里有<a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_resolve/late/enum.RibKind.html">各种类型的 <code>rib</code></a>，一个 <code>rib</code> 就是定义了一个命名空间和其对应的 <code>binding</code>:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Rib</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">R</span> <span class="token operator">=</span> <span class="token class-name">Res</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> bindings<span class="token punctuation">:</span> <span class="token class-name">IdentMap</span><span class="token operator">&lt;</span><span class="token class-name">R</span><span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> kind<span class="token punctuation">:</span> <span class="token class-name">RibKind</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比如我们写代码中的一个大括号就会引入一个新的 <code>rib</code>，同样的一个函数或者模块的定义会引入对应的 <code>rib</code>。对于代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那如何能找到在 <code>println!</code> 的时候所用的变量 <code>a</code> 呢？因为变量是可以被覆盖的，可以想象这是一个按 scope 从里往外找的过程，从代码上也可以验证这个猜想，<a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_resolve/src/ident.rs#L279">resolve_ident_in_lexical_scope</a> 函数就是这样实现的。</p><p>在名字解析的过程中，Rust 分别为 types、values、macros 保存了不同的命名空间，因此下面这样的代码虽然看起比较诡异但却是合法的 Rust 代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">type</span> <span class="token type-definition class-name">x</span> <span class="token operator">=</span> <span class="token keyword">u32</span><span class="token punctuation">;</span><span class="token keyword">let</span> x<span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> y<span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// See? x is still a type here.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>名字解析是非常复杂的部分，光 <code>late.rs</code> 这个文件就有 4000 行代码了。之前我做过一个关于<a href="https://github.com/rust-lang/rust/pull/104864/files">名字解析的 PR</a>，当一个变量没在当前 <code>scope</code> 里找到的情况下尝试去 <code>inner scope</code> 找，如果找到则给出建议。这虽然是个不复杂的 PR，但我通过这个 PR 理解了这块的大致逻辑。</p><h3 id="Ast-validation"><a href="#Ast-validation" class="headerlink" title="Ast validation"></a>Ast validation</h3><p>这个阶段没做什么特别复杂的检查，比如这种：</p><ul><li>no more than <code>u16::MAX</code> parameters;</li><li>c-variadic functions are declared with at least one named argument;</li><li>c-variadic argument goes the last in the declaration;</li><li>documentation comments aren’t applied to function parameters;</li></ul><p><code>AstValidator</code> 实现了各种 <code>check_*</code> 函数，通过 <code>visitor pattern</code> 在 AST 里逐个检查对应的元素，在编译器中最常用的设计模式就是 <code>visitor pattern</code> ，所以在 <code>rust_ast</code> 里定义了这个 <a href="https://github.com/rust-lang/rust/blob/13471d3b2046cce78181dde6cfc146c09f55e29e/compiler/rustc_ast/src/visit.rs#L111">Visitor</a> 的 <code>trait</code>：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Visitor</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'ast</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token class-name">Sized</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_ident</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> _ident<span class="token punctuation">:</span> <span class="token class-name">Ident</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_foreign_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">ForeignItem</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk_foreign_item</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk_item</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_local</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> l<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Local</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk_local</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_block</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Block</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">walk_block</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的自定义 <code>Visitor</code> 只需要实现这个 <code>trait</code> 就行了：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token class-name">Visitor</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token keyword">for</span> <span class="token class-name">AstValidator</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_attribute</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> attr<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Attribute</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">validate_attr<span class="token punctuation">::</span></span><span class="token function">check_attr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>session<span class="token punctuation">.</span>parse_sess<span class="token punctuation">,</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">visit_expr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> expr<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token class-name">Expr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">...</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HIR"><a href="#HIR" class="headerlink" title="HIR"></a>HIR</h2><p>HIR 是 rustc 中使用的主要 IR，是在解析、宏扩展和命名解析之后生成的。HIR 的许多部分与 Rust 表面语法非常相似，除了 Rust 的一些表达式形式已被脱糖。例如， <code>for</code> 循环被转换为 <code>loop</code> 并且不出现在 HIR 中，这使得 HIR 比普通 AST 更易于分析。</p><p>我们可以使用以下命令来展示一个程序的 <code>HIR</code> :</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rustc main.rs -Z <span class="token assign-left variable">unpretty</span><span class="token operator">=</span>hir-tree <span class="token operator">></span> tree.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以看到即使一个非常简单的程序，生产的 <code>hir</code> 也是非常长的，因为带了很多编译器里面分析使用的字段，另外 <code>HIR</code> 中也带有对应的代码行，也包括 <code>Span</code> 等这些信息，对生成诊断非常重要。<code>rustc_hir/src/intravisit.rs</code>  定义了一些方便在 <code>HIR</code> 上遍历的 <code>visitor</code>。</p><p>HIR 和 AST 基本是一一对应的，所以整个转换的过程就是遍历一遍 AST，代码在 <code>rustc_ast_lowering</code>。注意 HIR 里的 <code>HirId</code> 非常重要，这个 ID 是后续使用 HIR 时候经常会用到的，所以必须是唯一的。在 lowering 的过程中通过 <code>next_id</code>这个函数来生成唯一的 ID。</p><p>我曾经尝试做过一个比较大的 PR 来保证父节点的 HIR_ID 一定比子节点的小，但是做到后来发现代码中的递归经常需要先创建子节点，然后再创建父节点，这样 HIR_ID 就很难保证顺序，否则代码就改得很难看。如果你感兴趣可以看看能否继续做下去 <a href="https://github.com/rust-lang/rust/pull/103114/files">Assign HirIds in HIR traversal order</a>。</p><p>语法糖什么的都会在这时候处理掉。</p><h3 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h3><p>类型推断是自动检测表达式类型的过程，比如以下代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> things <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    things<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"thing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们并没有显示声明 things 的类型，但是因为后续代码中往 things 里写入了一个字符串，所以 things 的类型可以推断出是 <code>Vec&lt;&amp;str&gt;</code>。</p><p>Rust 使用的是一个改进版本的 <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner (HM)</a> 算法，该算法最先被实现在 ML 系的编程语言中，后来被广泛采用在各种函数式编程语言里。</p><p>这块我目前接触也比较少，记得之前做过一个 PR 尝试修复一个 type inference 的小问题，不过没做完  <a href="https://github.com/rust-lang/rust/pull/107567">Extend Infer ty for binary operators</a>，问题看起来也比较简单</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">myfunction</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> one <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment">// ok</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> two <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        <span class="token operator">!</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// cannot infer type</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> three <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        <span class="token operator">!</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// ok</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">one</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">two</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">three</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量 <code>two</code> 不能被推导出来是因为 <code>i</code> 没有类型，虽然我们知道 <code>a</code> 的类型是 <code>Vec&lt;bool&gt;</code> ，但不能保证 <code>a[i]</code>就是 <code>bool</code> 类型，如果你感兴趣可以试试看能否解决。</p><p>Type inference 有其局限性，2015 年 RFC <a href="https://rust-lang.github.io/rfcs/0803-type-ascription.html">0803-type-ascription</a> 提出来作为补充，但这个 RFC 实现了之后一直没有稳定，最终社区又提出把这个功能给去掉，而这个工作也涉及到大量的改动：<a href="https://github.com/rust-lang/rust/issues/101728">De-RFC 3307: Remove type ascription</a>。</p><h2 id="MIR"><a href="#MIR" class="headerlink" title="MIR"></a>MIR</h2><p>MIR 是比 HIR 更低层次的中间表示，从 HIR 构建。MIR 方便用于控制流分析和代码优化，其中也包括 Rust 特殊的 <strong>borrow checking</strong>。MIR 的关键特性：</p><p>MIR 的一些关键特性是：</p><ul><li>基于控制流图</li><li>没有嵌套表达式</li><li>MIR 中的所有类型都是完全显式的</li></ul><p>更深入了解可以读官方的这篇文章 <a href="https://blog.rust-lang.org/2016/04/19/MIR.html">Introducing MIR</a>。MIR 都是一些比较原子性的操作，离 LLVM 的 IR 比较近，所以很方便后面代码生成部分。另外为了方便做 borrow checking MIR 也会在插入一些 scope 的标签。</p><p>我们可以通过 <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=30074856e62e74e91f06abd19bd72ece">Rust Playground</a> 查看生成出来的 MIR，如何基于 MIR 做数据流分析可参考 <a href="https://rustc-dev-guide.rust-lang.org/mir/dataflow.html">MIR dataflow</a>，在 MIR 上做 <a href="https://rustc-dev-guide.rust-lang.org/borrow_check.html#major-phases-of-the-borrow-checker">borrow checking</a> 也会更精准，NLL(non-lexical lifetime) 就是这样解决的。</p><h2 id="Codegen-代码生成"><a href="#Codegen-代码生成" class="headerlink" title="Codegen 代码生成"></a>Codegen 代码生成</h2><p>一直到这里为止，编译都是在做数据转换，把代码变成中间层表示，然后抽象的等级越来越低，最后把 MIR 生成 LLVM IR，然后生成二进制文件。</p><p>Rust 后端可以是 LLVM、Cranelift 或者 GCC，这些都依赖于第三方库来实现，所以需要最大程度共享一些基础代码。</p><p>在这个阶段也做了如下这些事情：</p><ul><li>为范性类型替换成具体的类型</li><li>为具体类型生成代码称为单态化 (<em>monomorphization</em>)</li><li>MIR 转换为 codegen IR </li><li>调用 codegen 后端生成可执行文件</li></ul><p>代码生成的入口点是 <code>rustc_codegen_ssa::base::codegen_crate</code>。</p><hr><p>我理解 Rust 是强加了些便于做静态分析的语言特性的编程语言，比如 lifetime 和 borrow checking 规则，编译器内部集成了很多静态分析功能。</p><p>当然我们只是从很高的纬度去快速过了一遍，里面还有些特殊的部分很复杂但我还没开始细看，比如 <code>trait solving</code> 。</p><p>后续继续更新 😁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个 Rust 程序是如何从源文件编译为二进制文件的？&lt;/p&gt;
&lt;p&gt;如果从头开始看 rustc 的源码会无从下手，我之前通过解决 issue 去读过部分模块的源码，就是 bottom-up 的方式，但我还未从整体上理解 rustc 的源码结构。&lt;/p&gt;
&lt;p&gt;这篇文章主要
      
    
    </summary>
    
    
      <category term="编程" scheme="http://catcoding.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
      <category term="编译器" scheme="http://catcoding.me/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>苹果：为了安全让 M2 吃灰</title>
    <link href="http://catcoding.me/p/apple-perf/"/>
    <id>http://catcoding.me/p/apple-perf/</id>
    <published>2023-03-06T23:20:08.000Z</published>
    <updated>2023-03-12T16:24:30.492Z</updated>
    
    <content type="html"><![CDATA[<p>苹果新的芯片性能真是不错，并且续航很可观，所以我最近买了个 M2 Pro。有几年没使用 Mac 系统了，所以日常使用还有些别扭，但最让我闹心是发现了苹果一个让人大跌眼镜的设计，而我几乎没找到关于这点的中文资料，所以写下来分享给你。</p><p>我日常会花时间在 Rust 编译器项目上，经常需要编译 rustc 和跑单元测试。单元测试大概是 1.4 w 个测试用例，测试框架会并行跑编译并执行后对比结果。我发现这台 Mac 跑测试一共需要 16 分钟，这是不可接受的，因为我之前使用 <code>WSL</code> 也不过 20-30 分钟左右。我用一台 32 c 64 g 的 Linux VM 跑同样的测试只需要 1.5 分钟。</p><p>我这台 Mac 选的配置一般，CPU 核数是 6 性能 + 4 效能，另外内存 32 G，这样算来也不可能有 10 倍的性能之差。在 <a href="https://github.com/rust-lang/rust">Rust 代码仓库</a>跑单元测试：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./x <span class="token builtin class-name">test</span> tests/ui --force-rerun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以通过 <code>htop</code> 看到明显没有充分利用所有的 CPU，上图是 Mac 的系统资源统计，下图是 Linux VM 的：</p><p><img src="/images/ob_pasted-image-20230308155722.png" alt=""></p><p><img src="/images/ob_pasted-image-20230305225021.png" alt=""></p><p>我实在想不通为什么会这样，因为我之前看到过 <a href="https://twitter.com/m_ou_se/status/1413589063735681028">Mara Bos</a> 发的 M1 Mac 的数据，她大概只需要 9 分钟跑完所有的单元测试。</p><p>然后我在 Rust 开发者论坛 rust-zulip 里发起一个<a href="https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/.E2.9C.94.20Is.20there.20any.20performance.20issue.20for.20MacOS.3F">帖子</a>，很快得到了一些开发者的回复。刚开始有人怀疑是 <code>mdworker_shared</code> 进程的问题，这个进程是为 Spotlight 做索引用的，因为跑测试会不断生成新的临时文件，从 <code>htop</code> 上看这个进程会占用不少 CPU。但我把 Spotlight 彻底关闭掉，性能确实有一点点提高，但这明显不是根本原因。</p><p>我怀疑是不是测试框架用的 <code>threads</code> 数目不对，看代码是通过这个 <a href="https://github.com/rust-lang/rust/blob/0fbfc3e76916521b509b63286296dd0762170d34/library/test/src/helpers/concurrency.rs#L11">get_concurrency</a> 获取的，我通过 <code>RUST_TEST_THREADS</code> 尝试把数目提高，但是也没卵用。</p><p>Eric Huss 用的是 M2 Max，他跑测试花费的时间是 9 分钟，这个结果显然也不能匹配上高贵的 Max 配置。</p><p>后来有人提到是不是因为 <code>SIP</code>，<strong>Huss 关闭 <code>SIP</code> 之后跑测试时间立马从 9 分钟减少到 1 分 36 秒 ! 这几乎是 5 倍多的提速。</strong> 另外，如果把 <code>SIP</code> 打开但把网络给关闭掉，同样能得到类似的提速。</p><p>这就是说跑单元测试的时候系统在不断地发送网络请求，这也解释了为什么我对比国外的用户跑测试所用的时间会更长，因为我走了 VPN 啊！我关闭 <code>SIP</code> 之后测试时间从 16 分钟提高到 153 秒，这可是 10x 的提速！</p><p>那么 <code>SIP</code> 是什么？</p><p>这东西全称 <a href="https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection">System Integrity Protection</a>，译为系统完整性保护：</p><blockquote><p>System Integrity Protection (SIP) in macOS protects the entire system by preventing the execution of unauthorized code. The system automatically authorizes apps that the user downloads from the App Store. The system also authorizes apps that a developer notarizes and distributes directly to users. The system prevents the launching of all other apps by default.</p><p>During development, it may be necessary for you to disable SIP temporarily to install and test your code. You don’t need to disable SIP to run and debug apps from Xcode, but you might need to disable it to install system extensions, such as DriverKit drivers.</p></blockquote><p>SIP 是 OS X El Capitan 时开始采用的一项安全技术，目的是为了限制 root 账户对系统的完全控制权，也叫 Rootless 保护机制。从文档看出，<strong>苹果自家的 <code>Xcode</code> 系统是做了特殊处理的</strong>，但第三方软件需要经过 <code>SIP</code> 的检查。</p><p>更多细节请参考这篇文章 <a href="https://sigpipe.macromates.com/2020/macos-catalina-slow-by-design/">macOS 10.15: Slow by Design</a>，<strong>简而言之 <code>SIP</code> 会在我们跑任软件之前，把你的执行文件做一个校验和，然后通过网络请求发送到让人敬畏的苹果服务器，就是为了检测是否是恶意软件！</strong></p><p>在我跑单元测试的时候，通过查看 Mac 的系统日志可以发现这么一条关键信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">log stream <span class="token operator">|</span> <span class="token function">grep</span> Xprotect<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/ob_pasted-image-20230306224206.png" alt=""></p><p><code>XprotectService</code> 这个就是在检查我跑测试用到的一个 <code>dylib</code> 文件。<code>Xprotect</code> 是一个病毒扫描器，它会检查可执行文件是否在已知恶意软件列表中。</p><p>这真是个让人无语的设计！</p><p>这不仅适用于从网络下载的文件，也适用于你自己编译的程序或者是写的一小段脚本。因此，即使你编写了一行 shell 脚本并在终端中运行它，可能也会有延迟，在 HackerNews 上看到<a href="https://news.ycombinator.com/item?id=23274033">一个中国开发者</a>发的可能有几秒的延迟：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">$'#!/bin/sh<span class="token entity" title="\n">\n</span>echo Hello'</span> <span class="token operator">></span> /tmp/test.sh <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> a+x /tmp/test.sh<span class="token function">time</span> /tmp/test.sh <span class="token operator">&amp;&amp;</span> <span class="token function">time</span> /tmp/test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>PS：如果你运行过这个命令把 <code>Terminal</code> 加到可信列表，跑脚步就没这个问题了：<br><pre class="line-numbers language-console" data-language="console"><code class="language-console">sudo spctl developer-mode enable-terminal<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>更让人吐血的是，此问题已报告给了苹果，<strong>然而苹果回应说这是“设计使然”</strong>！而你也会看到更多人在网络上反馈同样的性能问题，比如：</p><p><a href="https://www.reddit.com/r/linux/comments/tj12vw/hugo_runs_twice_as_fast_in_asahi_linux_than_macos/">Hugo runs twice as fast in Asahi Linux than macOS on the same M1 Mac system</a></p><p>好了，如果你也会频繁跑大量的程序，可能也会受此影响。为什么我说”可能“，是因为这东西太复杂了，我还没搞清楚所有细节！官方文档关于 <code>SIP</code> 只有寥寥数语，如果你想了解更多关于 <code>SIP</code> 的资料，可以参考这篇博文 <a href="https://derflounder.wordpress.com/2015/10/01/system-integrity-protection-adding-another-layer-to-apples-security-model/">System Integrity Protection – Adding another layer to Apple’s security model</a>。</p><p>当我粗看这篇文章的时候，以为可以配置一下 <code>/System/Library/Sandbox/rootless.conf</code> 就可以忽略某些目录的文件，结果是我太幼稚了。我问 bjorn3 怎么回事，得到的回答是：</p><blockquote><p>The system file protection is only a small part of the protections against malware macOS has. Xprotect is a virus scanner which checks all executables against a liat of known malware. There is signature checking (AMFI) which also checks if the certificate the executable has been signed with has been revoked (using an internet service from apple). This also checks if the entitlements the executable declares are allowed or for example only allowed by apple signed executables (like the SIP bypass entitlement). There is also a check that the application is allowed to access certain protected directories like your documents or images directory. And there are a couple of other checks. These are performed independent of where the executable is stored.</p></blockquote><p>看起来就只有全关闭这条路了？如果你想关闭 <code>SIP</code>，还有那么点麻烦：</p><ol><li>重启 Mac，按住 Command + R 直到屏幕上出现苹果的标志和进度条，进入 Recovery 模式。(如果是新的 Mac 就在启动的时候长按住电源键)</li><li>在屏幕上方的工具栏找到并打开终端，输入命令 <code>csrutil disable</code> ；</li><li>关掉终端，重启 Mac；</li><li>重启以后可以在终端中查看状态确认。</li></ol><p>关闭也许会让你的 Mac 处于裸奔状态，我也不清楚有多大的安全隐患。开启 SIP 只需在上面第 2 步命令改为 <code>csrutil enable</code> 即可。</p><hr><p>我上一个 Mac 是 2012 年买的，一共用了六七年，那台 Mac 真是非常耐用，所有的硬件这些年都没出现问题。苹果的硬件一直领先业界几个段位，我上次买是因为 Retina 屏幕，这次买是因为苹果自家的芯片。</p><p>有人说 Mac 是最适合开发者的设备，但苹果关心开发者么？我在 Rust Zulip 问一个对 Mac 很熟的开发者，这都快七年了为什么苹果不修复这个明显的问题，他的回答是：</p><blockquote><p>从我作为一个局外人的观察来看，苹果公司不再像以前那样关心开发者了。他们曾经有一流的文档资料，但现在你要是能找到一点点文档就该知足了。</p></blockquote><p>也许在苹果眼里只有使用 <code>Xcode</code> 的开发者才能称之为开发者！否则绝不会弄出这么个脑残设计，事实上很多开发者都没有意识到这是系统的默认行为，这么牛逼的芯片很多时候是在吃灰。</p><p>这不是 <code>Secure by Design</code>，而是 <code>Slow by Design</code>！</p><hr><p><strong>Update</strong>:<br>一个读者指出了更简单的办法，把你信任的工具加入到 Developer Tools:<br><img src="/images/ob_pasted-image-20230307105335.png" alt=""><br>注意必须通过 UI 设置，这条命令虽然提示设置成功了，但是其实没成功 😂：<br><img src="/images/ob_pasted-image-20230307110005.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;苹果新的芯片性能真是不错，并且续航很可观，所以我最近买了个 M2 Pro。有几年没使用 Mac 系统了，所以日常使用还有些别扭，但最让我闹心是发现了苹果一个让人大跌眼镜的设计，而我几乎没找到关于这点的中文资料，所以写下来分享给你。&lt;/p&gt;
&lt;p&gt;我日常会花时间在 Rust 
      
    
    </summary>
    
    
      <category term="工具" scheme="http://catcoding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Apple" scheme="http://catcoding.me/tags/Apple/"/>
    
      <category term="Mac" scheme="http://catcoding.me/tags/Mac/"/>
    
      <category term="安全" scheme="http://catcoding.me/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>为 Rust 做贡献的经验分享</title>
    <link href="http://catcoding.me/p/how-to-contribute-to-rust/"/>
    <id>http://catcoding.me/p/how-to-contribute-to-rust/</id>
    <published>2023-01-18T21:36:07.000Z</published>
    <updated>2023-03-12T16:24:30.496Z</updated>
    
    <content type="html"><![CDATA[<p>2022 年下半年我花了很多时间为 Rust 做贡献，最近一个阶段性的收获是我获得了 <a href="https://foundation.rust-lang.org/news/community-grants-program-awards-announcement-introducing-our-latest-project-grantees/">Rust Foundation 项目资助</a> 🙌。</p><p>这个收获完全是副产物，我在 8 月份开始做这些的时候不知道 Rust Foundation 有这类资助，在为 Rust compiler 做了 30 多个 PR 后我发现了这个资助项目，然后很快就发起了申请。我的项目计划是：</p><blockquote><p>To support contributions to the Rust compiler, and to continue to blog about the experience, sharing the learning experience, knowledge, and skills with others.</p></blockquote><p>所以除去写代码，最近几个月我会写一些 Rust 相关的技术文章。我之前写过一篇 <a href="https://catcoding.me/p/my-experience-learning-rust/">我如何学“会”了 Rust</a> ，分享了一些去年通过做开源项目来学习 Rust 的相关经验。</p><p>这篇主要集中在如何参与到 Rust compiler 相关的开发中来，但我觉得纯写技术文章会有些单调，而且很多资料都有官方文档，翻译为中文意义不大，所以这篇我主要写自己的感受和经验。</p><h2 id="我如何开始"><a href="#我如何开始" class="headerlink" title="我如何开始"></a>我如何开始</h2><p>我一直是通过为项目做贡献来学习 Rust，因为纯看书或者文档我觉得收获不大，大概是年纪大了看了就忘记了🐸。</p><p>很多事情都不是规划好的，我觉得生活充满了随机性，但我会努力和乐观些，并保持好奇心。好奇心对程序员很重要，这是源动力。</p><p>我的第一个 Rust compiler 的 PR 是在 2021 年 9 月做的 <a href="https://github.com/rust-lang/rust/pull/88493">Remove duplicated diagnostics</a> 。这是我在使用 Rust 的开发过程中发现的问题，一时兴起翻看 compiler 的代码想知道这个现象是如何产生的，毕竟这看起来很容易 debug。</p><p>事实证明我低估了上手的难度，这个问题我大概花了一周的业余时间，期间当然也花了不少时间去看文档，我还尝试使用 gdb 去一行行跟踪代码。最终的修复虽然也比较简单，但是代码 review 来回好多次。</p><p>做完第一个 PR 之后，我觉得很有成就感，但随即我就去搞其他的了。一直到 2022 年的 8 月，我偶然又看了几个 issue，感觉有一些 parser 和报错信息相关的问题比较容易解决，所以就又开始做了。过段时间刚好是微软的 hackthon，有两周左右时间可以用来学习感兴趣的东西，所以我的时间比较多地投入到上面，一直到现在都会规律性地给 Rust 做贡献。</p><p>我解决的问题比较零碎，很多都涉及 diagnostics，也有些涉及 Infra 之类的，还有些是纯粹编译器里的 bugfix，我喜欢解决一个个独立的 issue，这让我觉得每个新的问题都是一个小谜题，而做稍大一些的改动需要耗费更持久的精力。后续我会试着找一些固定的方向做。</p><h2 id="贡献流程"><a href="#贡献流程" class="headerlink" title="贡献流程"></a>贡献流程</h2><p>Rust 编译器的仓库里面包含了上万个测试用例，不管是解决 bug 还是做一些新功能开发，最好先写一些最小测试用例，然后不断修改代码、编译、测试，直到用例测试通过。</p><p>编译型语言最大的弊端是失去了 interactive programming 的乐趣，特别是 Rust 这种编译特别耗时的语言，不是很适合做探索式编程，我的办法是编译的时候就继续看代码，还有在关键的地方多加一些日志信息。</p><p>在这个过程中，最耗时的可能是代码 review 这个阶段，PR 发出来之后 rustbot 会从列表中随机挑选一个 maintainer 来 review 代码，但因为目前很多 maintainer 的 review list 积累过长，所以需要等待很久才能开始。目前社区正在讨论如何解决这个问题 <a href="https://internals.rust-lang.org/t/did-we-start-reviewing-prs-slower/18033">Did we start reviewing PRs slower?</a>，我的解决办法是 PR 发出之后就开始解决其他问题，如果有反馈再切回这个分支来修改。</p><p><img src="/images/ob_pasted-image-20230117125646.png" alt=""><br>对于比较大的开源项目，需要用大量时间去和其他人沟通和讨论，所以写作能力很重要。看文档、理解代码、调试代码、和其他人交流，这些是软件开发中的核心能力，在做开源工作时得到很好的提升，可以很快地迁移到其他项目上。</p><h2 id="如何选择-issue"><a href="#如何选择-issue" class="headerlink" title="如何选择 issue"></a>如何选择 issue</h2><p>大家可能会有个误解，认为要为编译器做贡献必须得对 Rust 很了解。我认为不是的，以我的经验和水平算也不上很资深的 Rust 开发人员，我并没有在实际工作和生产环境使用过 Rust，但对编译器做贡献并不需要对语言本身了如指掌。</p><p>如果涉及到语言本身的语义、语法的改动，则需要 RFC 的流程，经过社区大量的讨论，这些对于新手来说相对不容易，但编译器项目里面本身有很多用户发现的问题、流程改进、bugfix、重构、优化等需要做，所以新手最适合从解决 issue 开始。</p><p>当掌握了 Rust 的主要的语法，能看懂大部分代码的情况下就可以开始，新手需要通过一些简单的问题来上手，带着问题看代码更有效果。</p><p>但刚开始，你可能不知道自己能解决什么问题，可以从 <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AE-mentor">E-mentor</a>, <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AE-easy">E-easy</a>, <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AE-help-wanted">E-help-wanted</a> 这类标签去找一些相对简单的问题来解决。但如果找不到适合的，也可以随机找一些自己能看懂的问题，试着去解决。</p><p><a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AA-diagnostics">A-diagnostics</a> 的问题通常是完善或者修复 rustc 的报错信息，这类问题适合新手。Rust 编译器里面很多代码都是为了给用户提供尽量有用的报错信息，Rust 在这块的关注和投入超过绝大部分编程语言，正如 <a href="https://github.com/estebank">estebank</a>写道：</p><blockquote><p>We spent decades trying to invent a sufficiently smart compiler when we should have been inventing a sufficiently empathetic one.</p></blockquote><p>既然 Rust 学习曲线比较陡峭，我们应该让编译器善解人意。这类问题通常需要去理解 AST，推测用户的编程意图，给他们提供有用的帮助信息。</p><p>我们可以通过搜索关键字的方式来找到错误信息对应的代码，但并不是所有的这类问题都容易解决，有的时候需要在不同的阶段中去验证，比如我这个 PR <a href="https://github.com/rust-lang/rust/pull/101975">Suggest to use . instead of ::</a>，方法调用报错是在 <code>resolve</code> 阶段出现的，但是我们需要等到 <code>hir typeck</code> 阶段才能去复核是否能给出帮助信息。</p><p>有的 <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+label%3AI-ICE">ICE</a> 问题也比较容易解决，比如一些 corner case 没有处理的情况，通常有一个粗暴的解决方法，但从各种修复方案中权衡利弊也是门艺术。</p><h2 id="如何发现问题"><a href="#如何发现问题" class="headerlink" title="如何发现问题"></a>如何发现问题</h2><p>做编译器开发，一个重要的转变是从语言的使用者变成改进者，编程语言是工具，编译器也就是另外一个软件，这都是可以改进的。如果视角变了，就能发现很多问题。</p><p>有一天在 Twitter 上看到这个分享，我的疑问是为什么编译器会同时出现两个建议，第一个明显是只适合关心返回结果的情况：</p><p><img src="/images/ob_pasted-image-20230117005319.png" alt=""></p><p>所以我记录下来，随后发起一个 PR 对此做了修复 <a href="https://github.com/rust-lang/rust/pull/104875">Properly handle postfix inc/dec</a>。</p><p>发现问题的另一个来源是日常使用，比如我在日常使用 Rust 时发现如果我少输入了一个 ‘}’，编译器可能无法指出括号不匹配的位置，而且如果源文件很长可能会报出大量错误，这是因为大括号的不匹配没有得到适当的处理，导致 parser 出来的语法树是完全不对的，而编译器总是尝试去从错误中恢复。这种情况下除了指出缺少 ‘}’，给出其他信息都是无法帮助用户尽快修复问题的，所以我做了另一个 <a href="https://github.com/rust-lang/rust/pull/104012">PR 去解决这个问题</a>。</p><h2 id="一些小贴士"><a href="#一些小贴士" class="headerlink" title="一些小贴士"></a>一些小贴士</h2><p><a href="https://rustc-dev-guide.rust-lang.org/getting-started.html">Guide to Rustc Development</a> 这个文档需要经常看，这份文档相对源码可能有些地方不够新，但对了解编译器的各个主题概要非常有帮助。</p><p>Rust 有一个不那么完整的 <a href="https://doc.rust-lang.org/reference/">Reference</a>，如果你看不懂某部分代码，很可能是不知道相关的名词，这时候翻看这个 reference 就会很有帮助。</p><p>在 rustc 的开发过程中，<code>x.py</code> 是经常使用到的命令，我把自己常用的命令写成了一个 <a href="https://github.com/chenyukang/share/blob/main/justfile">justfile 配置文件</a>，这样做测试、查日志、rebase 之类的会比较方便。</p><p>在调试过程中，日志加上读代码比 gdb 一行行去跟踪更有用。通过阅读代码，在关键的步骤打印日志，通过运行时的日志去验证自己的猜想，这样我们可以在脑海中获得代码的主要流程和组织结构，而通过 gdb 跟踪容易迷失在具体的细节里。</p><p>使用 rust-analyzer 读 Rust 代码很容易，特别是 <code>show call hierarchy</code> 对理解函数调用特别有用。强类型系统对于写代码可能是一个负担，但对于阅读和理解代码绝对有很大的好处，类型就是文档。</p><p>在开发过程中如果遇到问题，可以去 <a href="https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp">t-compiler/help</a> 发帖求帮助，zulip 是 Rust 编译器开发人员使用的讨论工具，你也可以在上面通过用户名找具体的人讨论问题，通常大家都是很乐于帮助的。</p><p>另一个好的学习方法是去 review 其他人的 PR，刚开始看不懂没关系，可以看看大致思路。有的 issue 如果我感兴趣但没时间去解决我会点击订阅通知，这样 issue 如果被 close 我会收到邮件，我可能会去看看 PR。</p><p>国内开发人员在做开源的时候所会面临的一个问题是语言障碍，这只能通过长时间的不断练习能提高。如果想中文沟通，欢迎找我交流。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你对编译方面的开发不感兴趣，也可以试着去找其他领域，Rust 在 Infra、WebAssembly 和 Web 开发、嵌入式、游戏、安全等领域都在快速发展。另外，对 Rust 做贡献不限制于写代码，报出好的 issue、改善文档和翻译、加入讨论这些都属于社区贡献。</p><p>如果你只是想了解一些编译相关的知识，这些资料非常适合入门：</p><ul><li><a href="http://craftinginterpreters.com/">Crafting Interpreters</a></li><li><a href="https://github.com/rui314/9cc">9cc: A Small C Compiler</a> </li><li><a href="https://github.com/utam0k/r9cc">r9cc: Toy C compiler</a></li></ul><p>创造运气在于多做并且让更多人知道，做开源和分享对程序员来说是一个创造运气的事。希望我的分享对你有用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2022 年下半年我花了很多时间为 Rust 做贡献，最近一个阶段性的收获是我获得了 &lt;a href=&quot;https://foundation.rust-lang.org/news/community-grants-program-awards-announcement-in
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://catcoding.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>我的 2022</title>
    <link href="http://catcoding.me/p/2022-summary/"/>
    <id>http://catcoding.me/p/2022-summary/</id>
    <published>2023-01-02T22:08:07.000Z</published>
    <updated>2023-03-12T16:24:30.492Z</updated>
    
    <content type="html"><![CDATA[<p>2022 对于我来说是特殊的一年，在这一年里我有失望、痛苦、愤怒，也有不少付出、收获和成长，一年到尾最大的感受是活着不易，庆幸还能写一年的总结。</p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>刚好去年的元旦，我做了一个开始更多写作的决定，在 2022 年的头一个月里，我做到了日更的节奏。而后的半年我保持在一周两篇左右的频率，但是后半年我就开始偶尔写写了，这是因为我有了很多精神内耗，为了缓解内耗我后半年很多空余时间都在编程。</p><p>总共写了 68 篇文章，在这近一年的写作过程中，我收获了 3000 个的公众号订阅，博客阅读大概 10 w 多，这对于很多大号来说不值一提，但我自己比较满足了，因我大概也就比较密集地写了半年，另外写作对我来说是业余爱好。在这个过程中我的写作能力得到了提高，在最近的一篇文章中，码农翻身的 liuxin 帮我润色和组织文章，让我意识到写那种广泛传播的文章和写纯干货的文章有很大的区别，文章想要引起传播效应得有一些钩子一样的东西激发读者的情绪，另外起标题真是个技术活。当然我写作并不是完全为了流量，能实践不类型的写作对我来说是一种收获。</p><p>在今年我也尝试了一段时间周刊，我的很多读者也是喜欢这种形式。虽然我的 Obsidian 里面还保存了不少我读过的未分享文章，但最近我没有写了，希望新的一年能继续保持下去。我在考虑使用竹白来专门写周刊，也许可以做付费的形式，一种履约也许让我把这件事情更长久地做下去。</p><p>Obsidian 是今年我一直在用的工具，除去发布过的文章，我今年做了更多的笔记，所以在我印象中似乎今年的记忆更为深刻些。</p><p>通过写作我认识了更多朋友，这是我本来所能预想到的。所以新的一年，我会继续写作，争取能写得更多。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>2022 年我阅读了一些小说，之前分享过我读完了所有余华的作品。根据微信阅读的统计，2022 年我有 210 天阅读过，读了 67 本书，其中读完的只有 37 本。陪女儿练乒乓球的地方旁边刚好有个书店，所以我每周都会去里面逛逛。</p><p>今年读的书大多是非技术类的，也许是因为年纪更大了或是因为阅读了这些书，我也会琢磨些之前未细致考虑过的人生问题。</p><p><img src="/images/ob_pasted-image-20230102154901.png" alt=""><br>在这些书中我推荐：</p><ul><li>纳瓦尔宝典</li><li>项塔兰</li><li>悉达多</li><li>阿诚的棋王、树王、孩子王</li><li>余华的书</li></ul><p>奇鸟行状录这本书也许是我去年读的最厚的小说，我觉得前 3/4 很好，我喜欢里面关于井的故事，结尾我不喜欢。</p><p>阿诚的文字很特别，精细而深刻，人除了生存，总得找一个角落安放精神：</p><blockquote><p>我常常烦闷的是什么呢？为什么就那么想看看随便什么一本书呢？电影儿这种东西，灯一亮就全醒过来了，图个什么呢？可我隐隐有一种欲望在心里，说不清楚，但我大致觉出是关于活着的什么东西。</p></blockquote><p>…</p><blockquote><p>人总要呆在一种什么东西里，沉溺其中。苟有所得，才能证实自己的存在，切实地掂出自己的价值。</p></blockquote><p>除去阅读，我也会听一些播客，比如文化有限，看电影解说，比如越哥说电影，最近这段时间我喜欢看徐云的骑行流浪的视频。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>我家有两个女儿，小的不到一岁半，还处于‘养’的阶段，大女儿五岁多，更多的挑战在于‘育’。家庭占据了我很多时间和精力，特别是从三月份开始我一个人带着大女儿在苏州宅了近两个月。这段时间里我深刻地体会到了带孩子的苦与乐，由于我拙劣的厨艺，女儿瘦了几斤，而我却胖了几斤。</p><p>这段时间里，我终于从碗盘不沾进化成了可以做顿家常菜的水平，这也是被逼出来技能吧。我对家庭生活里的琐碎事有了更多耐心，虽然有时候还是自觉做得不够好，但今年是进步最大的一年了。</p><p>在健康上，我今年面临的问题是肩胛骨酸痛，这算是职业病了。新冠是今年绕不开的主题，和绝大部分人一样我整年做了 11 个月核酸，结果在 2022 年的最后几天感染了新冠。</p><p>新冠感染的第一天我特别难受，妻子还在考虑是不是普通感冒，我很清楚这肯定就是新冠了，我都不必去再去做核酸检测，因为全身酸疼、精力被抽干，这种感受是我之前从未体验过。我的症状只持续了两三天左右，而后妻子和小孩也都开始有了症状，不过幸好都是三天左右就没有特别难受了。</p><p>经过两周的恢复，干咳才完全消失，但我感觉体力已经大不如前，比如稍微劳作一下就不想动了，还会偶尔心跳异常，所以至今仍然不敢过多运动。</p><p>2022 年里有太多不能明说的敏感词，对未来我仍然比较悲观。之前看过张宏杰的两本书《饥饿的盛世》和《中国人的性格历程》，在这些魔幻和痛苦的日子里，我对此有了更深刻的体会。</p><p>我每天都会在 Youtube 上看王局的节目，估计看多了之后自然就会比较悲观，刚开始我还会和相近的朋友分享些看法，后来我也渐渐独自琢磨和消化了。相比蒙住眼睛和耳朵装作什么都不知道，我更愿意选择知道然后悲观。</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>2022 年也是我这几年做开源最多的一年吧，从这个 Github 上的统计上看，虽然有 12623 个提交，但很多都是我写文章时 Obsidian 的自动备份。</p><p><img src="/images/ob_pasted-image-20230102161409.png" alt=""></p><p>从 8 月份左右开始基本都是在做真的代码提交了。之前我也分享过，今年下半年我主要在给 Rust compiler 做贡献，目前统计大概完成了 70 个 PR。</p><p>我算是在用编程来缓解新冠带给我的不良情绪，当我无法改变什么却又忍不住悲观时，写写代码时间就过去了。很多夜里，我一边等待着编译和测试结果，一边打开王局的节目，那些难熬的日子就过去了。</p><p>通过给 Rust 做贡献，我不仅找到了编程的那种纯粹快乐，也找到了一个乐于助人的社区，还得到了一些经济上的回报。我一直在践行多元化自己的收入和生活，尝试如何不依赖公司和组织，所以我对这段时间的改变很满意，也许 2023 年还会有更大的变化。</p><hr><p>新冠让我感受到了个人在大时代面前的渺小，我对未来不再做过长的规划，因为我们必须学会拥抱不确定性，学着如何过好一天、一周、一个月，把握好当下就是最好的应对措施。</p><p>新的一年，希望读更多书、写更多文章和程序，保持健康。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2022 对于我来说是特殊的一年，在这一年里我有失望、痛苦、愤怒，也有不少付出、收获和成长，一年到尾最大的感受是活着不易，庆幸还能写一年的总结。&lt;/p&gt;
&lt;h2 id=&quot;写作&quot;&gt;&lt;a href=&quot;#写作&quot; class=&quot;headerlink&quot; title=&quot;写作&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>玩了一周 ChatGPT，谈谈我的想法</title>
    <link href="http://catcoding.me/p/chatgpt/"/>
    <id>http://catcoding.me/p/chatgpt/</id>
    <published>2022-12-10T22:48:06.000Z</published>
    <updated>2023-03-12T16:24:30.496Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ob_pasted-image-20221210193738.png" alt="Alberto Romero via Midjourny"><span class="image-caption">Alberto Romero via Midjourny</span></p><p>看到推特上无数人在晒 ChatGPT 的截图，我也忍不住注册了一个账号，到目前为止我快玩了一周了。刚开始我感觉非常震惊，三观受到冲击，经过这几天的多次调戏发现了些 ChatGPT 的缺陷，兴奋劲过去了之后谈谈我的一些看法。</p><p>首先 ChatGPT 的语言理解基本都正确，甚至会根据上下文的不同背景使用不同的措辞，输出的句子也是语法上没有什么问题，而且他还具备一些日常的理解能力：</p><p><img src="/images/ob_pasted-image-20221210194610.png" alt=""></p><p><img src="/images/ob_pasted-image-20221210194616.png" alt=""></p><p>ChatGPT 善于在你给的简短描述上自由发挥，比如下面这段我让它帮忙写个工作总结，可以看出 AI 在这三个方面做了合理的细化和扩展：</p><p><img src="/images/ob_chatpgt-1.png" alt=""></p><p>令人印象深刻的是它能围绕一个问题和我进行一定程度地互动：<br><img src="/images/ob_chatpgt-2.png" alt=""></p><p>但是，如果你继续深入地问他感受和观点，它就会陷入两种结果：从训练中积累出来地“理中客”，或说“我是 AI 没有具体感受”。</p><h2 id="合理的使用方式"><a href="#合理的使用方式" class="headerlink" title="合理的使用方式"></a>合理的使用方式</h2><h3 id="辅助编程"><a href="#辅助编程" class="headerlink" title="辅助编程"></a>辅助编程</h3><p>如果我们想查询一个简单的代码片段，ChatGPT 是比较适合的，甚至这种有确定答案的查询其结果比 Google 好。比如这种问题：<br><img src="/images/ob_pasted-image-20221210192703.png" alt=""></p><p>但我们并不能完全信任其结果。通常经典的编程问题，比如这种排序算法、不同编程语言里典型的文件操作、如何发起一个 HTTP 请求之类的问题，可以预见网络上这类可用于训练的资料非常多，所以其结果通常是对的。</p><p>但某些情况下，ChatGPT 生成的代码时有问题的，甚至是误导性的。比如我同事在日常工作中让他生成一个 PowerShell 连接 SQL 的代码，其结果中有一个伪造出来的参数。</p><p>另一个让我更震惊的是，某些情况下 ChatGPT 可以发现程序里的问题，比如我们把这个快排程序刻意加入两个 Bug，AI 居然都能理解并找出来：</p><p><img src="/images/ob_pasted-image-20221210194729.png" alt=""></p><p><img src="/images/ob_pasted-image-20221210230518.png" alt=""><br>这是和 Copilot 最大的区别，不止能帮忙补全代码，也能作为代码 Review 的辅助工具。在编程的时候使用这个工具需要你本身对这块足够了解，否则就会被坑。在学习编程时适当使用也会很不错。</p><h3 id="辅助创作"><a href="#辅助创作" class="headerlink" title="辅助创作"></a>辅助创作</h3><p>ChatGPT 在根据一些条件去生成文字方面确实有一手，比如<a href="https://twitter.com/Piglei">@piglei</a> 的这个例子：<br><img src="/images/ob_pasted-image-20221210194030.png" alt=""></p><p><img src="/images/ob_pasted-image-20221210222808.png" alt=""></p><p>这是目前我所看到的类似工具中做得最好的，比之前那些智能写作工具有一个本质上的提高。ChatGPT 似乎收集了很多模板，在适当的时候可以套进去，比如你让他生成一个大学申请书，它就会按照一定的模板去套你的信息。</p><h3 id="语言翻译"><a href="#语言翻译" class="headerlink" title="语言翻译"></a>语言翻译</h3><p>我真实投入了日常使用的是英语翻译，比如我这周有就用 ChatGPT 来生成了两份英语邮件回复。我对比了翻译的质量，这个结果比 Deep Translator 要好，我基本不用做特别多的修改，就能拿来直接用。英文文章翻译为中文同样结果不错。<br><img src="/images/ob_pasted-image-20221210215112.png" alt=""></p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>ChatGPT 会尽量回答问题，就像是一个活了几个世纪的老人，似乎什么知识都能知道一些，然后给出一个大概及格的回答。但有时候它是在瞎忽悠，如果你是外行就不一定发现他在忽悠。</p><p>关于事实的询问，它有时候会伪造出来一些看起来合理，但其实是错误的答案：<br><img src="/images/ob_pasted-image-20221210195433.png" alt=""></p><p>即使目前这个测试版本还存在很多明显的问题，我认为 ChatGPT 这次的刷屏标志着 AI 应用进入了一个新的阶段。这也让我们再次思考人类的智慧是否可以被替代，我们的工作是不是要丢了。</p><p>淘汰人类不一定会吧，但确实会让某些领域失去些魅力。几年前 <em>AlphaGo</em> 在围棋领域击败了最强大的人类选手，一直以来我们认为 AI 在围棋上是不能做到这点的，因为搜索空间太大了，而这确确实实发生了。在 DeepMind 的纪录片里，我看到 AlphaGo 团队的程序员们自己都觉得不可思议，称其本质和原理上是简单的，就是一个基于概率的搜索程序，言语中还透露着一些惋惜，棋艺这个我们人类自豪的智慧艺术竟然这样就被击败了。现在围棋已经被 AI 彻底玩腻，专业选手还得不断学习 AI 下棋的套路。柯洁现在似乎对围棋的乐趣没那么深了，我看到他的一个访谈里谈起围棋，透露着一种无奈和空虚感。</p><p>ChatGPT 目前因为所有人都在刷屏一些表现良好的例子，所以可能会被大家高估。我一个高中同学是心理咨询师，看着 AI 如此自然地回答问题有点担心自己失业，所以很想把玩一把。我写了个程序做了个接口转发给她玩，她稍微琢磨了一下，似乎又不担心自己丢工作了。</p><p>ChatGPT 强项在于写作，如果我们周围充斥着机器生成的文本，那纯手工写作会显得更有价值？<br><a href="https://twitter.com/paulg">Paul Graham</a> 最近在推上写到：</p><blockquote><p>If AI turns mediocre writing containing no new ideas into a commodity, will that increase the “price” of good writing that does contain them? History offers some encouragement. Handmade things were appreciated more once it was no longer the default.</p></blockquote><p>…</p><blockquote><p>And in particular, handmade things were appreciated more partly because the consistent but mediocre quality of machine-made versions established a baseline to compare them to. Perhaps now we’ll compliment a piece of writing by saying “<em>this</em> couldn’t have been written by an AI.”</p></blockquote><p>我赞同这个观点，比如最近我偶然看到 <a href="https://www.infoq.cn/article/mEux81fTgUD0NlbJK9Lj">InfoQ 上的这篇文章</a>，很明显是人肉在机器翻译的基础上随便做了点修改，读起来就是那么地别扭，而且因为编辑是外行，文章里面还有些重要的错误。而这就是趋势，我么将来会被越来越多的这样内容充斥。</p><p>统计学家<a href="https://zh.wikipedia.org/w/index.php?title=I.J._Good&amp;action=edit&amp;redlink=1">I.J. Good</a>于 1965 年提出技术奇点的必要条件──“智能爆炸”概念：</p><blockquote><p>让我们将超级智能机器定义为一种能够远远超过任何人的所有智力活动的机器。如果说设计机器是这些智力活动的一种，那么超级智能机器肯定能够设计出更加优良的机器；</p></blockquote><blockquote><p>毫无疑问，随后必将出现一场“智能爆炸”，人类的智能会被远远抛在后面。因此，第一台超级智能机器是人类需要完成的最后一项发明，前提是这台机器足够听话，会告诉我们如何控制它。</p></blockquote><p>这最后一项发明是否临近了？我乐观猜想二十一世纪应该还不能实现，程序员这工作应该在我退休之前还是安全的😂？不过我还是很乐于使用这些 AI 辅助工具，这些工具也将渐渐地彻底改变编程，短短半年的时间里 Copilot 已经成为我日常编程中比较依赖的东西。</p><p>你对 ChatGPT 有何感想？欢迎留言交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ob_pasted-image-20221210193738.png&quot; alt=&quot;Alberto Romero via Midjourny&quot;&gt;&lt;span class=&quot;image-caption&quot;&gt;Alberto Romero via M
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="人工智能" scheme="http://catcoding.me/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Twitter 实习生 George Hotz</title>
    <link href="http://catcoding.me/p/geohot/"/>
    <id>http://catcoding.me/p/geohot/</id>
    <published>2022-11-29T17:29:07.000Z</published>
    <updated>2023-03-12T16:24:30.496Z</updated>
    
    <content type="html"><![CDATA[<p>经过一轮又一轮的裁员，Twitter 大批骨干离职。</p><p>有人戏称：现在 Twitter 办公室里只剩下两个最“硬核”的程序员了。</p><p><img src="/images/ob_pasted-image-20221130121508.png" alt=""></p><p>这两个人中一个自然是老板 Elon Musk。</p><p>另外一个则是 33 岁的 George Hotz，一个周薪 2000 美元的 Twitter 实习生。</p><p>这位实习生的年龄着实大了一点儿，并且缺乏前端相关的经验，不得不从了解 JavaScript 和 GraphQL 开始，从头一点点学习 Twitter 使用的编程语言 Java 和 Scala，他甚至在网络上直播自己如何弄明白 <a href="https://www.youtube.com/watch?v=z6xslDMimME">Twitter 是如何运行的</a> 。</p><p>这样的人怎么可能入得了 Elon Musk 的法眼，逆行加入 Twitter 呢？</p><p><img src="/images/ob_07147c2e7e77357fbc29369945348fb.jpg" alt=""></p><p>原因很简单，George Hotz 是一位超级技术大牛，网络上随处可见他的神奇经历。</p><p>2007 年 8 月 21 日，当时 17 岁的 George Hotz 在自己博客宣布成功破解 iPhone，手机不再局限于 AT&amp;T 网络，而是支持其他 GSM 网络，并在博客上发布了详细的解锁过程和视频，最终这部破解的 iPhone 换了一部跑车和三部新的 iPhone，让他在黑客圈子里声名鹊起。</p><p>2009 年，他又开始解锁 PlayStation 3，后来被 Sony 起诉，最终因为黑客圈最大组织 Anonymous 施予的强大压力下和 Hotz 和解。</p><p>随后几年他去了高校潜心研究机器学习。</p><p>2014 年 7 月，他加入 Google 的 Project Zero，短暂工作后退出。</p><p>2015 年，专注于驾驶辅助技术，在网上免费发布了他的自主驾驶代码“openpilot”，声称可以用最小的成本做出个更好的自动驾驶技术。</p><p><img src="/images/ob_pasted-image-20221129114516.png" alt=""></p><p>这给特斯拉带来了巨大威胁，Elon Musk 在 2015 年就想“招安”他，让他来特斯拉做自动驾驶，后来因为种种原因谈崩，George Hotz 自己成立了一个做自动驾驶的公司 comma.ai，因此成为了 Tesla 的对手。前段时间他还在点评 Tesla 发布会时，表示对其机器人产品的不屑。</p><p>George Hotz 肯定是不缺工作也不缺钱的人，为什么要在这个时候加入 Twitter 呢？</p><p>可能是他感受到 Elon Musk 和他是一类人，他喜欢混乱和挑战，他最近一个多月才开始频繁发推，并且开始体会到社交网络的乐趣。</p><p>也可能因为他没经过 996 的毒打，很想体验一把鸡血的高强度推特工作。当那封名为 <code>A fork in the Road</code> 的美国版奋斗者邮件发出后，Geroge Hotz 评论到：</p><blockquote><p>This is the attitude that builds incredible things. Let all the people who don’t desire greatness leave.</p></blockquote><p>随后表示自己不想远程办公，想去旧金山进行全职的实习生工作，正好 Elon Musk 也认为远程工作不靠谱：</p><p><img src="/images/ob_pasted-image-20221129120931.png" alt=""></p><p>另外，他正在从自己创办的公司中退出，似乎是对 <a href="https://geohot.github.io/blog/jekyll/update/2022/10/29/the-heroes-journey.html">自动驾驶失去了兴趣</a> 。当然这并不意味着 comma.ai 失败了，而是他觉得自己对运营一个更为庞大的公司没有兴趣：</p><blockquote><p>It’s no longer a race car, it’s a boat. And steering a boat requires too much damn <em>planning</em> and <em>patience</em>.</p></blockquote><p>所以在这个空档期找一些没做过的事情试试，就是这么任性。在一个代码直播中，他自称多年前也做过一些老派的互联网技术，那时候主要还是用 PHP，现在这些互联网相关的技术他之前没怎么实战过，后台开发、前端、微服务，对些他来说都是没折腾过的，所以称之为 <code>For the glory of the technical challenge</code>。</p><p>至于有的人对此表示不理解，他的回复是优秀的程序员想干什么就干什么，不需要理由：<br><img src="/images/ob_pasted-image-20221129122457.png" alt=""></p><p>作为顶尖黑客，geohot 在互联网上有很多轶事。他如何做到如此出色和有创造力，普通人能从他身上学到些什么？</p><p>最近几个月，我在业余时间会去看 George Hotz 的 <a href="https://www.youtube.com/@geohotarchive">油管视频</a> ，感觉非常有趣，也有收获。他在直播里通常会把自己的思路自言自语说出来，而且会时不时停下来谈谈对一些事情的看法，有时候还会哼点小曲。他也是一个非常直率的人，说话风趣，说话语速比较快，很有节奏感，有时候可当作 rap 来听，我们还能锻炼英语听力。</p><p>强烈推荐你也去观摩一把，看看顶尖程序员如何工作的。我认为这大概是 Learn by doing 和 Learn in Public 最好的实践。他每次通常会定一个最小目标，然后连续数小时的持续学习，比如：</p><ul><li>在直播中开发小巧的、类似 pytorch 的深度学习框架 <a href="https://github.com/geohot/tinygrad">geohot/tinygrad</a></li><li>在没看过 Clang 和 LLVM 的情况下去尝试实现 C 语言的一个新的语法逻辑</li><li>实现一个和自己下国际象棋的 <a href="https://www.youtube.com/watch?v=RFaFmkCEGEs">AI 程序</a></li><li>看论文，调试各种机器学习的模型，玩 diffusion</li></ul><p>顶尖程序员并不是人坐下代码就噼里啪啦出来了，而是也可能和普通人一样，需要不断地 Google 和翻阅文档，一样可能会混淆行和列，从教程中拷贝粘贴代码，看着报错信息饶头皱眉 wtf，还有程序跑出来正确结果那种孩童般的欢呼雀跃。</p><p>这种观感就如同一些观众评论到：</p><blockquote><p>That exact same thing happens to me EVERYTIME. Nice to see someone 10 times smarter than me do the same.</p></blockquote><p>…</p><blockquote><p>It’s encouraging to see that someone as ridiculously genius as George Hotz still has to Google Python and even struggles with the way stuff works in his program. It definitely made me realize I have just been focusing on memorizing too much stuff when it comes to programming. I just need to make more projects and have more fun doing them! Thanks Geohot!</p></blockquote><p>…</p><blockquote><p>Dude has an IQ of &gt; 9000</p><p>Confuses rows and columns like a normal human Finally,</p><p>   I feel less shitty now.</p></blockquote><p>当然有的时候你也能看到他速度非常快，敲代码就如同电影里那样 (之前用 Vi，最近改用 VsCode 了)：</p><blockquote><p>this guy programs like how hollywood thinks people program</p></blockquote><p>他看文档经常扫一样就知道个大概，看起来就像是凭借直觉在工作，这就是积累下来的自学能力，可以快速迁移到任何项目上，他解释到 <a href="https://www.youtube.com/watch?v=N2bXEUSAiTI&amp;t=2920s">Object level skills will die out, metalevel skills will be useful</a>，比如学 Data Science, 我们到底是学了某个公司用的工具，还是去学统计学？前者是 object level 的，后者是 meta level 的。</p><p>在这些直播中，我觉得一些比较有趣的观点和片段是：</p><ul><li><a href="https://www.youtube.com/watch?v=_L3gNaAVjQ4&amp;t=8640s">不折腾编辑器和多屏幕，这些不影响效率</a>, Give me a Macbook Air and a corner。</li><li>工作中你也许用不到数学，但学习数学和物理给人一种 Knowing the secrets 的感受，那些给你教条的家长、老师他们可能没你懂世界是如何运行的。</li><li>不喜欢远程办公，这让工作感觉像度假，喜欢去公司和同事一起当面工作。</li><li>为什么 30 多岁来还去当实习生，薪酬 2000 美金一周 <a href="https://www.youtube.com/watch?v=nvtoOxNfDQo&amp;t=855s">what the fuck, who cares？</a></li><li>我经常搜索一些看起来简单的问题，在别人看来我就是个新手，这不重要，<a href="https://www.youtube.com/watch?v=nvtoOxNfDQo&amp;t=1080s">别担心别人的看法</a> ，关注自己的能力，而不是外在的印象。因为印象和人设是很容易改变的，而能力才是最重要的。</li><li>开源代码比内部代码有用，<a href="https://www.youtube.com/watch?v=nvtoOxNfDQo&amp;t=1940s">很多公司会把好的代码开源出来</a> ，而那些内部用的代码质量其实很低。</li><li>开发过程中喜欢把主要的步骤用 plain text 写下来。</li><li>如何学习编程，想一个自己感兴趣的项目，直接开干，Learn by doing，看编程视频没法学会编程。</li><li><a href="https://www.youtube.com/watch?v=_L3gNaAVjQ4&amp;t=9749s">推荐的编程语言</a>：Assembly, C, Python, 外加 Haskell 和 Verilog, 你不用对 Assembly 非常精通，但只有懂了 Assembly 才懂计算机底层在干什么，才知道 C 的精妙之处，懂了 C 之后才知道 Python 帮你做了什么，这三门语言是抽象的不同层次。学一下 Haskell 可以帮助你理解编程语言的设计，学些 Verilog 让你知道硬件如何运行。</li><li><a href="https://www.youtube.com/watch?v=nvtoOxNfDQo&amp;t=9570s">C++ 太复杂，Golang 是给学不会 C++ 的 Google 程序员用的🤣</a></li><li>我们处于编程 2.0 时代，Machine learning 就像是数据驱动编程。</li><li>什么是编程，面向新手讲解 <a href="https://www.youtube.com/watch?v=N2bXEUSAiTI">what is programming?</a></li><li>相信技术奇异点，两篇改变自己人生的文章，推荐 <a href="http://www.fairpoint.net/~jpierce/staring_into_the_singularity.htm">Staring Into The Singularity</a> 和 <a href="https://www.unqualified-reservations.org/">Unqualified Reservations by Mencius Moldbug</a> 。</li></ul><p>通过观看这些视频，我感受到他和普通人的明显区别是：<strong>极其强烈的好奇心和空杯心态，强大的学习能力和持续专注的能力</strong>，这也许是最值得我们学习的。而他去 Twitter 折腾，正如他在博客上写的那样：</p><blockquote><p>I hope that there’s people in the world who get joy from actually <em>doing</em> the thing and not just solving the problem.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过一轮又一轮的裁员，Twitter 大批骨干离职。&lt;/p&gt;
&lt;p&gt;有人戏称：现在 Twitter 办公室里只剩下两个最“硬核”的程序员了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ob_pasted-image-20221130121508.png&quot; alt=&quot;
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="程序员" scheme="http://catcoding.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="编程" scheme="http://catcoding.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>译：阅读的必要性</title>
    <link href="http://catcoding.me/p/read/"/>
    <id>http://catcoding.me/p/read/</id>
    <published>2022-11-26T22:49:07.000Z</published>
    <updated>2023-03-12T16:24:30.500Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://paulgraham.com/read.html">The Need to Read (paulgraham.com)</a><br>作者：Paul Graham<br>2022 年 11 月</p><p>在我小时候读的科幻小说中，总有比阅读更有效率的方式获取知识，神秘的 “磁带” 如程序加载到计算机一般植入人的大脑中。</p><p>这种事不太可能很快实现。这不仅是因为我们很难找到阅读的替代品，而且因为即使存在，它也是不够的。阅读关于 <code>x</code> 的内容并不只是教你了解 <code>x</code>，同时还教你如何写作 [^1]。</p><p>那又怎样？如果我们找到了更为快速的方式来替代阅读，大家就没必要写得好了，不是吗？</p><p>更重要的原因是，写作不仅仅是一种传达想法的方式，也是一种创造想法的方式。</p><p>一个好的作家不只是思考，然后写下他的想法，作为一种记录。好的作家几乎总是会在写作的过程中发现新的东西。而据我所知，这种发现是无可替代的。与其他人讨论是发现想法的一个好方法。但即使这样做了，当你坐下来写作时，你仍然会发现新的想法。这种思考只能通过<a href="http://paulgraham.com/words.html">写作</a>来完成。</p><p>当然，也有一些思考是可以不通过写作完成的。如果你不需要太深入地研究一个问题，你可以不通过写作也能解决。例如，如果你正在考虑如何连接两台机器的部件，也许写作是无用的；而当一个问题可以被很正式地描时，你可以在头脑中解决；但如果你需要解决一个复杂的、定义不清的问题，写出来总是会有帮助。反过来，这意味着不擅长写作的人在解决这类问题时几乎总处于劣势。</p><p>不能写好就不能思考好，不读好就不能写好。这里的 “读好” 是指两个层面上的，你必须善于阅读，而且要读好的东西 [^2]。</p><p>如果你只是想获取信息，那有很多其他方法。但是，对于想要获得想法的人来说，阅读是必不可少的。</p><p><sub>[^1] 有声读物可以提供优秀写作的例子，但听别人朗读并不能像自己阅读一样教会你写作。</sub></p><p><sub>[^2] 这里的”善于阅读”不是指善于机械地阅读，相比起快速阅读，获取文字的含义更为重要。</sub></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;http://paulgraham.com/read.html&quot;&gt;The Need to Read (paulgraham.com)&lt;/a&gt;&lt;br&gt;作者：Paul Graham&lt;br&gt;2022 年 11 月&lt;/p&gt;
&lt;p&gt;在我小时候读的科幻小说中，总
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>和 Rust Compiler 开发者面基</title>
    <link href="http://catcoding.me/p/talk-with-compiler-hacker/"/>
    <id>http://catcoding.me/p/talk-with-compiler-hacker/</id>
    <published>2022-11-23T23:56:12.000Z</published>
    <updated>2023-03-12T16:24:30.504Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有更新博客了，最近两个月我在开心地写代码，今天想写篇文章，赶紧抓住这个冲动。</p><p>上周和 Rust compiler 的一个核心开发 <a href="https://github.com/compiler-errors">compiler-errors</a> 约了个线上面基。今天想写写我们沟通的主要几个方面，因为大部分都是技术相关的问题，所以我觉得写出来和大家分享一下没关系。</p><p>他对 Rust 项目贡献时间刚好满一年，这期间做了 <a href="https://github.com/rust-lang/rust/pulls?q=is%3Apr+is%3Amerged+author%3Acompiler-errors+sort%3Acreated-asc">400 多个 PR</a>，效率实在太高。我在 Rust 社区混了两个月了，这期间提交的很多 PR 都是他帮忙 Review 的，开发过程中碰到问题我也会向他请教。有次偶然看到他 Twitter 放开了自己的时间表，任何对 Rust compiler 的开发者都可以约个时间聊聊，所以我就约了个线上会议。</p><p>首先我问了一个比较宽泛的问题：你如何调试编译器，因为我发现你解决问题非常快。</p><p>compiler-errors: 首先对于一个问题，我会尝试构建一个最小能重现问题的代码用例，根据报错信息或者代码栈看源代码，rust-analyzer 对看代码帮助非常大，我们基本可以很快跳转到任何变量或者函数的定义。使用 VsCode 的 terminal 运行命令，错误栈里的文件信息里面有源代码的路径，ctrl 按下去可以直接跳转到对应的代码行。我对 compiler 的很多部分都了解一些，主要是因为看了不少代码，有时候一看错误信息就能大致判断出问题的位置，如果有必要再去看运行的日志。</p><p><em>VsCode terminal 运行命令直接跳转文件位置这个我学到了，我之前一直习惯在系统终端运行命令，VsCode 只是用来编辑代码。</em></p><p>我：你是否使用 GDB 之类的调试器？<br><strong>compiler-errors:</strong> 我基本不用这个，因为使用 GDB 调试需要另外开一些编译选项，这会让编译变得很慢，而且运行的时候也会变得很慢。我记得很早之前使用过一次，感觉不太好。</p><p>我：我进行了两个月的 Rust compiler 开发，所以接触到了很多语言的细节，给我的感受是 Rust 像是一个大杂烩，我能看到 Ruby 的影子，比如链式调用这样的风格，也能看到很多函数式编程的影子，所以这很独特，但我会担心 Rust 未来的发展，是否会太过独特而导致只有一小群人在使用。</p><p><strong>compiler-errors:</strong> 对此我也不是很确定，确实 Rust 比较复杂，有很多问题还没解决，初学者上手的难度比较高，但一个开发者不用掌握所有 Rust 的边边角角也能开始开发，我很肯定，Rust 对于编写和维护大型的、对性能、安全型要求高的项目来说是非常合适的。比如 Rust compiler 这个项目本身，这么庞大的项目我们在 Review 代码的时候其实是比较简单的，主要看实现的逻辑是否有问题，而不会担心内存方面的问题，而且我们也有信心不断地对代码进行重构。Rust 从学术界的编程语言借鉴了不少东西，比如 OCaml 是一门很精美的语言，但是很多年一来一直对并行这块支持不好，工业界的使用范围也比较少。</p><p><em>这些感受和我基本一致，在这么多年我断断续续的学习 Rust 过程中，我从未掌握过 Rust 的所有内容，但我发现从代码层面理解一个 Rust 项目非常容易，我接触过的几个领域的项目都是如此，比如 wasmer, youki, compiler，因为 Cargo 和统一的代码组织方式，还有 rust-analyzer 这样的工具辅助，理解代码相对来说容易很多。</em></p><p>接着我让他帮忙简单看了看我正在做的一个相对比较大的 PR，而后聊了一下他在 aws 工作的情况，这些就不细写了。</p><p>期间也问了一个我觉得自己看代码还没理解的部分，就是 method lookup 的相关实现，他说最好在一个 session 里面来分享这些，这样其他人也可以看到。Compiler team 会定时组织一些技术分享，视频都会上传到 Youtube，感兴趣的可以在这里看：<a href="https://www.youtube.com/results?search_query=RustcContributor%3A%3Aexplore">RustcContributor::explore - YouTube</a></p><p>我觉得这种线上面基的经历不错，可以认识一些人，得到一些交流。这一年我基本都在家办公，现实中除了和同事沟通，认识新人的机会比较少。所以我也打算搞一个线上预约，如果想和我交流的可以在这里选择一个时间，我们沟通半小时：<a href="https://calendly.com/cyukang/30min">https://calendly.com/cyukang/30min</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久没有更新博客了，最近两个月我在开心地写代码，今天想写篇文章，赶紧抓住这个冲动。&lt;/p&gt;
&lt;p&gt;上周和 Rust compiler 的一个核心开发 &lt;a href=&quot;https://github.com/compiler-errors&quot;&gt;compiler-errors&lt;/
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>无意识偏见</title>
    <link href="http://catcoding.me/p/unconscious-bias/"/>
    <id>http://catcoding.me/p/unconscious-bias/</id>
    <published>2022-10-21T19:50:07.000Z</published>
    <updated>2023-03-12T16:24:30.504Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到 Hao Chen 在 Twitter 上分享了无意识偏见，<a href="https://twitter.com/haoel/status/1566636122330959872">Hao Chen on Twitter: “Unconscious Bias 无意识偏见</a></p><p><img src="/images/ob_pasted-image-20220906074202.png" alt=""></p><p>在外企中这确实算一个必修课，微软入职的时候这是着重培训的一块内容。多元和包容的职场环境，需要员工关注这些细节。</p><p>在经过培训之前，“无意识偏见”对我来说很陌生，但回想起来我其实是有过这样的经历的。</p><p>我联想到了前公司的一件事情。当时我们在做企业的 IT 安全，解决公司数据的安全问题。我们安全相关的团队经过了一些讨论，我需要把这些东西形成文档。其中有一块是员工的安全管理，我们当时的结论是对于外包人员，需要着重管理，因为外包人员素质和安全意识差，人员流动性高，所以接触的数据需要分级等等。</p><p>这些都是我们讨论的东西，所以我写在了我们团队的 Conflence 页面。我刚编辑完 (我猜他是无意间看最近编辑页面发现的)，一个外包员工给我发私信，言语中透露着愤怒，谁说的外包人员素质差？</p><p>我一下意识到，这样写对他造成了很大的伤害。后来这个员工就离职了，我不确定是不是具体因为这件事导致他的离职，但我很肯定，外包在公司里面会感受到各种隐形的歧视的。</p><p>不止我的前公司，我也见过很多其他公司的外包人员的各种待遇，比如同在一个办公室里，但节日礼品、文化衫这些只有正是员工有，如此等等。当然可以从公司角度考虑，需要节省成本，但从工作环境和对人的关怀来说，我们应该努力减少偏见对人的伤害。</p><p>其实无意识歧视非常普遍，主要是因为人们习惯用标签和惯性思维。例如一个 HR 筛选简历，他最基本的一个筛选条件是学历、专业等等能迅速做出判断的条件，这也许主要是为了效率。当 HR 把筛选条件扩大到年龄、地域、性别等，我们通常会觉得过分了，但这些规则在社会上一直隐形运行着。</p><p>人们通常会对自己的受歧视经历印象深刻，但如果你是歧视者，就会自己做出的歧视行为毫无知觉，大多数人会难以发现自己带着习惯形成的偏见。正如耗子所说，偏见不止是对他人会造成伤害，对自己的认知和进步也会形成阻碍。比如技术上的偏见，抛去应用场景和需求谈技术栈，就会让自己的偏见无意识占了主导，从而做出不好的选择。</p><p><strong>我认为偏见主要是会扼杀了好奇心和求知欲，当你把一个对立的标签贴上之后，就认为自己已经足够了解，从而会丢掉去了解的好奇心和动力。</strong></p><p>没人会是一个毫无偏见的人，除非他抛去所有生活经验的总结，但尽量客观地看待人和事这个习惯值得培养，于人于己都有好处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到 Hao Chen 在 Twitter 上分享了无意识偏见，&lt;a href=&quot;https://twitter.com/haoel/status/1566636122330959872&quot;&gt;Hao Chen on Twitter: “Unconscious Bias 无
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>我曾经干了 3 年 EDA</title>
    <link href="http://catcoding.me/p/3-years-in-eda/"/>
    <id>http://catcoding.me/p/3-years-in-eda/</id>
    <published>2022-08-28T22:01:11.000Z</published>
    <updated>2023-03-12T16:24:30.492Z</updated>
    
    <content type="html"><![CDATA[<p>这周末在上海和几个前同事聚了聚，勾起我的一股回忆。</p><p>今天就写写 EDA，因为我的第一份工作就是加入了上海的一个创业公司，我们做的就是 EDA 行业中自动化形式验证工具。</p><p>这个行业如今被卡脖子，资本涌入，有人称之为国内的风口，但我加入的那时候就像是一个老鼠洞。我毕业那会儿正好看了《黑客与画家》，所以选择了一个创业公司，走了一条更少人走的路。</p><p>不过短短三年，我也只是在这个行业浅尝辄止。下面这些谈谈我的经历和感受，凭回忆写写有可能不够准确。</p><p>不得不说，美国人卡得很准，中国不是要大力发展芯片么，没有 EDA 这种工具要做芯片简直就是天方夜谭，EDA 软件实际上已经成为中国高端芯片的命门所在。</p><p><img src="/images/ob_pasted-image-20220825005953.png" alt=""></p><p>电子设计自动化（Electronic design automation，缩写：EDA），这个行业的发展伴随着 1980 年后的芯片革命和硅谷的崛起。芯片本质上是很多个物理逻辑门的组合，在芯片的早期，因为复杂度和集成度远不如现在，设计人员还可以手动完成电路设计和布线。</p><p>然后芯片的复杂度越来越高，自然人们开始想，如果能够使用软件来描述硬件设计就好了。1986 年，硬件描述语言 Verilog 推出，1987 年 VHDL 推出，各种仿真器开始出现，这些仿真器可以解析 Verilog/VHDL，并对设计的芯片进行仿真，这样使得芯片设计可以在真正被应用前进行严格的验证。</p><p>如今，EDA 工具已经成为芯片设计行业的标准工具，涵盖了芯片设计、布线、验证和仿真的所有流程。</p><p>EDA 行业的三巨头是 Synopsys、Cadence、Mentor，这些公司比我们大部分现在的程序员年龄都大，其中 Mentor 成立于 1981 年，另外两个分别成立于 1985 和 1986，这些公司如今已经成为事实上的垄断，占据 80% 左右的市场份额。</p><p>2011 年，我加入 NextOp 的时候，公司已经创立了 5 年并开始进入了稳定期。市场人员在美国，主要研发人员在上海，这种模式和现在 zoom 这类公司很像。两个创始人都是 90 年左右去美国，读了博士之后进入了这个行业。</p><p>他们发现了一个比较细分的市场，因为日常工作中经常需要人为地去写 Property，所以就想如何能在仿真器运行之后自动生成 Property 就好了。Property 类似于我们写程序中的断言，可以当作硬件的一部分 spec，也可以用于硬件开发中的 regression testing，如果一个断言被触发了，可能是一个 Bug，也可能是一个之前漏掉的 coverage。因为硬件的 Bug 非常非常值钱，如果能在芯片设计阶段发现 Bug，那么这个工具将非常有用，我们的产品名称就叫做 BugScope。</p><p>我记得当时我们的一个重要里程碑就是找到了苹果的 Bug，可以感受到公司上下都非常有成就感，因为发现一个苹果的硬件 Bug  可以减少很多可能的损失，这非常能证明工具的价值。</p><p>这里面有很多技术上的难点，自动生成 Property 可以用到的输入有两方面，仿真器的运行数据和 Verilog/VDHL 代码。如何把仿真器里的运行数据搞出来，如何节省磁盘，我当时看着那些几十年的 C 头文件，去调试仿真器的 hook 函数，有时候盯着下面这种信号仿真看，如今想来都头大。</p><p><img src="/images/ob_pasted-image-20220825005451.png" alt=""></p><p>更难的是如何去自动发现数据里的规律，结合 Verilog 代码去生成 Property，如何写出足够简单而不会自相矛盾的 Property。这些会涉及到 Model checking、<a href="https://en.wikipedia.org/wiki/SAT_solver">SAT solver</a> 之类的算法，Model checking 的开山鼻祖  <a href="https://en.wikipedia.org/wiki/E._M._Clarke" title="E. M. Clarke">E. M. Clarke</a> 为创始人的博士生导师，所以作为了公司的顾问。他因为 Model checking 的开拓性工作获得了 2007 年的图灵奖。</p><p>虽然公司很小，但技术氛围很好，有些像个实验室，开发人员基本都是来自中科大、上交大、电子科大。作为刚毕业的小白，我在这个公司待的三年还是能学到了不少东西。里面的代码主要是几十万行的 C/C++，任何产品的 crash 都是在客户的机器上，所以对代码质量要求很高。回想起来 Software Engineering 做得非常不错，代码测试覆盖率几乎 100%，还有一堆 fuzz testing，为了解决内存问题 valgrind 在自动化测试中用了很多。</p><p>这个行业门槛太高，因为涉及到多个方面，需要一些硬件背景，最好有一些芯片从业经验，还需要好的软件工程能力。具体到我们的问题，比如 Property 怎么生成，就需要不少行业积累和手工打磨，一个个 case 去琢磨，当时公司 10 来个人也只有两三个做这块。我跟着做过一小段时间，发现自己做不来，我的耐心和相关知识都不够。</p><p>EDA 行业那时候就已经非常稳定，黄金时期已经过去。有个老板经常感叹，整个 EDA 行业的大小好不如香蕉行业。</p><p>我们那时候已经有一些稳定的客户，最大的客户应该是苹果，在上海的时候我也去 Marvell、中兴这些公司做现场调试。</p><p>2013 年我们公司被印度人主导的公司 <a href="https://semiengineering.com/atrenta-buys-nextop/">Atrenta 收购了</a>，过了几年 Atrenta 又被 Synopsys 收购了，我在 2014 年因为想去深圳就离职了。在这个稳定的行业，如果想做也是可以一直做下去的，我之前的同事们，有一部分还在 Synopsys 做，有一部分去了美国，有一部分在国内出来创业一圈，随着我国大力支持 EDA 行业，他们又回到了这个行业继续奋斗。</p><p>我国是否能自研出来这些 EDA 工具？我们几十亿，几百亿地往里面砸钱，总能激起一些浪花，民族之光华为总能做出来吧？</p><p>我不确定，能不能做出来是一回事，好不好用或者能到什么深度又是另一回事。比如现在国内 EDA 工具的领头华大九天能做出部分 5 nm 芯片的国产替代，但 3nm 及以下的高端芯片就被美国卡脖子了。</p><p>EDA 这类工具在硅谷自然生长出来，而不是资本催生出来的，也不是一个或者两个公司做出来的。</p><p>行业迅猛发展有其时代的背景，因为有了些实际的需求和一定的行业积累，自然会有些人去解决问题和创新，完善的产权保护机制让人能够去解决一些看似小的问题，成为创业企业养活自己，比如像 Verilog/VHDL 这类的 Parser 是一个小公司 Verific 做的，我现在还记得是因为他们每年给客户送上一张巨大的卡通硅谷地图。</p><p>像我所在的公司这种一再被并购，大鱼吃小鱼的过程一直在发生，这些 EDA 巨头就是从无数个收购中发展起来的。</p><p>我国不缺软件开发人才和资金，但缺既有软件开发能力和这个行业背景，又能解决一些基础数学问题的人，据说国内 Synopsys 已经被挖走了一大半。也许我们短时间能好好追赶一阵，但彻底解决卡脖子的问题估计需要更多年了。</p><p>如今想起还有些怀念，单纯的一段技术工作体验。我那时候还是浮躁，要是能更多一些纯粹的好奇心就好了，这样会有更深入的体验。</p><p>但这次我们这几个聚会的同事，大多都跳出了这个行业，主要因为我们对这行没有特别大的兴趣和优势，另外想法比较多吧，总之跳了出来就不可能再回去了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周末在上海和几个前同事聚了聚，勾起我的一股回忆。&lt;/p&gt;
&lt;p&gt;今天就写写 EDA，因为我的第一份工作就是加入了上海的一个创业公司，我们做的就是 EDA 行业中自动化形式验证工具。&lt;/p&gt;
&lt;p&gt;这个行业如今被卡脖子，资本涌入，有人称之为国内的风口，但我加入的那时候就像是
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
</feed>
