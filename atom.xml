<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员的喵</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://catcoding.me/"/>
  <updated>2022-05-06T08:32:29.270Z</updated>
  <id>http://catcoding.me/</id>
  
  <author>
    <name>yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能测试小工具</title>
    <link href="http://catcoding.me/p/perf-tools/"/>
    <id>http://catcoding.me/p/perf-tools/</id>
    <published>2022-05-06T11:20:07.000Z</published>
    <updated>2022-05-06T08:32:29.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="procpath"><a href="#procpath" class="headerlink" title="procpath"></a>procpath</h2><p>一个 Python 实现的小工具，我们可以用来不断监控某个进程 (或者一组进程) 的资源使用情况，比如内存、CPU、IO 等。使用说明在这里：<a href="https://pypi.org/project/Procpath/">Procpath · PyPI</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pipx <span class="token function">install</span> Procpath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装即可，然后使用命令先来生成一个统计数据，并存储在 sqlite，并且可以生成统计图：</p><p><img src="/images/ob_2022-05-06-110341.png" alt=""></p><p>我之前排查一个<a href="https://github.com/second-state/dapr-wasm/issues/16">内存问题</a>时就用这个工具来调试，非常方便。比如我要统计 <code>image-api</code> 这个进程的内存情况，并生成图就使用下面这个脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> ./image-api-go <span class="token operator">></span> infer.log <span class="token operator">&amp;</span><span class="token function">sleep</span> <span class="token number">3</span><span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>pidof ./image-api-go<span class="token variable">`</span></span><span class="token builtin class-name">echo</span> <span class="token string">"begin record <span class="token variable">$pid</span> ..."</span><span class="token function">rm</span> -rf ff.sqlite/home/coder/.local/bin/procpath record -i <span class="token number">1</span> -r <span class="token number">60</span> -d ff.sqlite -p <span class="token variable">$pid</span>/home/coder/.local/bin/procpath plot -d ff.sqlite -q rss -p <span class="token variable">$pid</span> -f rss.svg<span class="token builtin class-name">echo</span> <span class="token string">"recorded <span class="token variable">$pid</span> ...."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你看看 <a href="https://heptapod.host/saajns/procpath/-/blob/branch/default/procpath/procfile.py">procpath 的代码</a>发现也非常简单，就是通过 Linux 系统下的 <code>/proc/&#123;pid&#125;</code> 下面的数据来进行统计的：</p><p><code>/proc/&#123;pid&#125;/stat</code>  ： 进程资源统计<br><code>/proc/&#123;pid&#125;/io</code> ： 进程 IO 相关统计<br><code>/proc/&#123;pid&#125;/fd</code> ： 进程句柄</p><p>具体通过 <code>man proc</code> 查询 Linux proc 相关的文档。类似的还有我以前记录过的 <a href="https://catcoding.me/p/runlim/">调优的小工具 RunLim</a>。</p><h2 id="Hyperfine"><a href="#Hyperfine" class="headerlink" title="Hyperfine"></a>Hyperfine</h2><p><a href="https://github.com/sharkdp/hyperfine">sharkdp/hyperfine: A command-line benchmarking tool</a></p><p>这个 Rust 命令行工具可以用来批量跑程序，找出程序的耗时区间，生成的结果可以输出为 JOSN 格式，这样能用来可视化对比结果。</p><p>比如我们使用这个工具来对比 <code>youki</code>、<code>crun</code>、<code>runc</code> 的性能，<a href="https://github.com/containers/youki/pull/544#issuecomment-1118473648">add the benchmark result to README, containers/youki</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hyperfine --prepare <span class="token string">'sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches'</span> --warmup <span class="token number">10</span> --min-runs <span class="token number">100</span> <span class="token string">'sudo ./youki create -b tutorial a &amp;&amp; sudo ./youki start a &amp;&amp; sudo ./youki delete -f a'</span>hyperfine --prepare <span class="token string">'sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches'</span> --warmup <span class="token number">10</span> --min-runs <span class="token number">100</span> <span class="token string">'sudo crun create -b tutorial a &amp;&amp; sudo crun start a &amp;&amp; sudo crun delete -f a'</span>hyperfine --prepare <span class="token string">'sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches'</span> --warmup <span class="token number">10</span> --min-runs <span class="token number">100</span> <span class="token string">'sudo runc create -b tutorial a &amp;&amp; sudo runc start a &amp;&amp; sudo runc delete -f a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跑出结果如下：<br><img src="/images/ob_2022-05-06-111156.png" alt=""></p><p>这个工具的作者用 Rust 写了好几个非常好用的命令行工具，比如 <code>fd</code> 快速查找文件等。</p><h2 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h2><p><a href="https://github.com/wg/wrk">wg/wrk: Modern HTTP benchmarking tool</a></p><p>这个工具可以用来批量发起 HTTP 请求，使用方法很简单：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 12 个线程、保持 400 个 HTTP 连接，跑 30 秒。我以前使用这个工具来对接口进行压力测试，非常方便。</p><p>还有个 Python 的测试工具叫作 <a href="https://locust.io/">Locust - A modern load testing framework</a>，这个功能更强大一些，我们可以写 Python 脚本来扩展测试逻辑，当然也可以用来做压力测试。</p><p><img src="/images/ob_2022-05-06-111856.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;procpath&quot;&gt;&lt;a href=&quot;#procpath&quot; class=&quot;headerlink&quot; title=&quot;procpath&quot;&gt;&lt;/a&gt;procpath&lt;/h2&gt;&lt;p&gt;一个 Python 实现的小工具，我们可以用来不断监控某个进程 (或者一组进程) 的资源使用
      
    
    </summary>
    
    
      <category term="工具" scheme="http://catcoding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>第 11 期，隐藏的后门；Worse is Better；Wolfram 和 Jobs</title>
    <link href="http://catcoding.me/p/weekly-11/"/>
    <id>http://catcoding.me/p/weekly-11/</id>
    <published>2022-05-01T20:46:06.000Z</published>
    <updated>2022-05-06T08:32:29.274Z</updated>
    
    <content type="html"><![CDATA[<p>我每周会分享一下这周看到的好内容，加上自己的一些个人理解和评注。前面三期为：</p><p><a href="https://catcoding.me/p/weekly-8/">#8 Valve，另一种公司</a></p><p><a href="https://catcoding.me/p/weekly-9/">#9 理想中的开发者</a></p><p><a href="https://catcoding.me/p/weekly-10/">#10 下一个 Google；最高形式的财富；冒名顶替综合症</a></p><p>这期分享的都是一些经典的老文章，有的老到比我的年纪都大，比如第一篇：</p><h2 id="隐藏的后门"><a href="#隐藏的后门" class="headerlink" title="隐藏的后门"></a>隐藏的后门</h2><p><a href="https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf">Reflections on Trusting Trust by Ken Thompson</a></p><p><a href="https://mananshah99.github.io/blog/2020/07/01/trusting-trust/">A Discussion of Ken Thompson’s “Reflections on Trusting Trust”</a></p><p>Unix 的缔造者之一 Ken Thompson 在 1983 和 Dennis Ritchie 共同获得了图灵奖，他的的获奖演讲以《Reflections on Trusting Trust》（反思对信任的信任）为题，就是上面那篇短短三页的论文。</p><p><img src="/images/ob_pasted-image-20220430114112.png" alt=""></p><p>在这篇文章中 Ken Thompson 阐述了一种在编译器里面加上后门的巧妙办法，让他可以登录任何早期的 Unix 系统。</p><p>有的人会说编译器里加恶意代码，我们看看编译器的源代码不就知道了么，所以大家通常认为开源软件更安全，毕竟源码面前，毫无秘密。</p><p>Ken Thompson 的办法巧妙在于，他先修改了一个编译器的源码，编译出来的编译器为 P0,  P0 可以在另外一份没有后门的编译器源码中插入代码，这样出来的编译器就还是有后门的 P1，但是你看源码又发现不了任何踪迹。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">compile</span> <span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">/* If the code we're compiling is code for the Unix login command */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match</span> <span class="token punctuation">(</span>code<span class="token punctuation">,</span> login_code_pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">compile</span> <span class="token punctuation">(</span>backdoor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/* If the code we're compiling is similar to the compiler source code */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match</span> <span class="token punctuation">(</span>code<span class="token punctuation">,</span> compiler_code_pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">compile</span> <span class="token punctuation">(</span>compiler_code_with_both_if_statements_inserted<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">/* Do regular compilation things */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器开发中有个常用的概念是自举 (bootstrapping)，就是用这门语言实现的编译器编译新版本的编译器源码，一门新的编译型编程语言，实现自举是第一个里程碑。</p><p>这里就牵涉到<strong>鸡生蛋还是蛋生鸡</strong>的问题，那第一个编译器肯定不是自身语言实现的，比如 C 第一个编译器是 B 语言写的， Rust 编译器的第一份源码是 OCaml 的。</p><p>Ken Thompson 的做法可以理解为在自举过程中加入了特定的后门逻辑，导致编译出来的编译器都会有问题。</p><p>这里有位作者在 Go 编译器上做了 PoC，<a href="https://ekyu.moe/article/thompson-hack-on-golang/">为编译器植入隐藏后门——亲手实践 Thompson hack</a>。</p><p>这类安全问题可以统称为信任链攻击，使用这种攻击手法，越底层的软件被动了手脚危害越大。一个 <code>npm install</code> 下去可能几百个第三方包就安装了，之前也出现过在 npm 包里加入挖矿代码这样的事。</p><p>现在软件开发的依赖如此错综复杂，我们只能相信写代码的人了。</p><h2 id="Worse-is-Better"><a href="#Worse-is-Better" class="headerlink" title="Worse is Better"></a>Worse is Better</h2><p><a href="https://dreamsongs.com/RiseOfWorseIsBetter.html">Rise of Worse Is Better</a></p><p>这篇文章是 1991 年写的，可以说影响了好几代程序员。我在学校的时候也读到过，这次重读一遍。</p><p>一个好的、理论上正确的设计包含这几点：</p><ol><li>简单性</li><li>正确性</li><li>一致性</li><li>完整性</li></ol><p>实践中采用这种设计哲学的方式称作 MIT 方式，在这种方式下设计的是 Lisp 和 Lisp Machine(一种专门跑 Lisp 的硬件)。</p><p>而 <strong>worse is better</strong> 的哲学认为简单性是最重要的，但为了保持简单可以一定程度上牺牲其他三个特性，这称之为  New Jersey 方式。这种方式下实现的产物是 C 和 Unix。</p><p>为什么称为 New Jersey 方式 ? </p><p>因为 C/Unix 的创造者 Dennis Ritchie 和  Thompson 所在的学校 UC Berkeley 在 New Jersey，另外美国人喜欢调侃新泽西，觉得相比起附近高贵的纽约，这地方真是又土又穷。新泽西乡巴佬，赤裸裸的地域歧视和小讽刺啊！</p><p>这篇文章中的主要例子是一个操作系统中的  <code>PC loser-ing</code> 问题，我看的时候没太看懂，然后搜到了这篇文章 <a href="https://blog.reverberate.org/2011/04/eintr-and-pc-loser-ing-is-better-case.html">EINTR and PC loser-ing , The “Worse Is Better” case study</a>。这篇文章的推测我认为是对的，早期的 Unix 系统调用有一个 EINTR 返回状态 (被中断的系统调用)，表示系统调用过程中发生了中断，需要重试，所以调用的时候经常写这种代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">again<span class="token operator">:</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> BUFFSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>      <span class="token keyword">goto</span> again<span class="token punctuation">;</span>  <span class="token comment">/* just an interrupted system call */</span>    <span class="token comment">/* handle other errors */</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这看起来确实够丑陋的，不过因为几乎所有的开发者默认都想重试，所以  4.2BSD 开始就已经支持自动重试，而 POSIX API 通过修改 <code>struct sigaction</code> 的  <code>SA_RESTART</code> 参数来决定是否重试。</p><p>所以，Unix 系统调用接口虽然当时看起来丑陋，但是逐渐已经通过缝缝补补把这个问题解决了！</p><blockquote><p> In other words, Berkeley UNIX was already doing “the right thing” five years before “Worse is Better” was written!</p></blockquote><p>而 Lisp Machine 对比 Unix，虽然设计精美、统一，但是却迅速陨落了。在软件开发中，这种新泽西方法似乎更有生命力，简单而言就是小步快跑，实现简单，快速出活。 Unix 就是这样，虽然理论上看起来不够优雅，但是足够简单，可以很快地移植到不同的硬件上去，所以越来越流行：</p><blockquote><p>The worse-is-better philosophy means that implementation simplicity has highest priority, which means Unix and C are easy to port on such machines. Therefore, one expects that if the 50% functionality Unix and C support is satisfactory, they will start to appear everywhere. And they have, haven’t they? Unix and C are the ultimate computer viruses.</p></blockquote><blockquote><p>The lesson to be learned from this is that it is often undesirable to go for the right thing first. It is better to get half of the right thing available so that it spreads like a virus. Once people are hooked on it, take the time to improve it to 90% of the right thing.</p></blockquote><p>这和另外一个软件开发箴言是一个意思：</p><blockquote><p>Make it work, make it right, make it fast<br>– Kent Beck.</p></blockquote><p>而 Lisp 本身虽然已经没落，但一些核心的东西却深刻地改变了编程语言和软件开发，比如递归、函数式编程、GC、Eval、Code as Data 等等，参考 <a href="http://www.ruanyifeng.com/blog/2010/10/why_lisp_is_superior.html">为什么 Lisp 语言如此先进</a>。</p><h2 id="Wolfram-和-Jobs"><a href="#Wolfram-和-Jobs" class="headerlink" title="Wolfram 和 Jobs"></a>Wolfram 和 Jobs</h2><p><a href="https://twitter.com/stephen_wolfram/status/1517589051552972806">Stephen Wolfram on Twitter</a></p><p><img src="/images/ob_pasted-image-20220430143425.png" alt=""></p><p>Wolfram 是著名软件 Mathematica 的作者，在这封 1987 年的信件里面他回复了 Jobs 的咨询。这个文件里面倒是没有列出 Jobs 的原问题，不过从标题和回复内容看，大概是 Jobs 想在 NeXT 里面做一个叫作 jobsbooks 的东西，里面包含一些词典、手册、等常用的书籍和参考，所以向 Wolfram 咨询数据来源有哪些？</p><p>当然这是我的猜测，Wolfram 是很适合问这个问题的人，他几乎是一个百科全书式的天才。他年轻的时候开始做物理方面的研究，后来开始写软件：</p><blockquote><p>“我一直认为，做研究一定要用最好的工具。即使我用的是当时最先进的计算机，还是不断遇到故障。我明白，唯一的方法就是自己把它们造出来。所以，我就动手了。”</p></blockquote><p>于是 Mathematica 诞生了，这个软件被称作是“有史以来最重要的科学软件”。</p><p>我搜索后发现 Wolfram 和 Jobs 也就是在 1985 年左右结识的，这篇文章是 Wolfram 2011 年 Jobs 去世时写的 <a href="https://writings.stephenwolfram.com/2011/10/steve-jobs-a-few-memories/">Steve Jobs: A Few Memories—Stephen Wolfram Writings</a>。</p><p>里面写到了多年前的往事，甚至 Mathematica 这个软件的名字是 Jobs 给取的。其中有段还写到，一次交谈时 Jobs 心烦意乱、小鹿乱撞，原来他晚上有个约会：</p><blockquote><p>The Steve Jobs—so confident as a businessman and technologist—had melted away, and he was asking me—hardly a noted known authority on such things—about his date.</p></blockquote><p>但 Wolfram 肯定比 Jobs 更“书呆”，怎么可能给出约会的建议，哈哈。</p><hr><p>这些老文看起来也挺有趣！</p><p>各位劳动节快乐！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我每周会分享一下这周看到的好内容，加上自己的一些个人理解和评注。前面三期为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://catcoding.me/p/weekly-8/&quot;&gt;#8 Valve，另一种公司&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://catco
      
    
    </summary>
    
    
      <category term="技术" scheme="http://catcoding.me/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="周刊" scheme="http://catcoding.me/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>焦虑自救小册</title>
    <link href="http://catcoding.me/p/anxiety-handbook/"/>
    <id>http://catcoding.me/p/anxiety-handbook/</id>
    <published>2022-04-28T19:00:07.000Z</published>
    <updated>2022-05-06T08:32:29.262Z</updated>
    
    <content type="html"><![CDATA[<p>最近有的读者找我咨询问题，聊下来我发现 IT 从业人员共有的突出问题就是焦虑。现在疫情、政策等大环境原因导致行业不稳定和生活艰难，焦虑是很多人的常态。</p><p>我也曾经焦虑过大概两年，这种状态刚开始自己还没意识到，直到出现了一些身体上很明显的症状才引起重视。后来经过一些自我调整我基本解决了这个问题，我之前写了篇文章分享自己的方法：<a href="https://catcoding.me/p/how-to-beat-anxiety/">35 岁，我用这三种方法克服焦虑</a></p><p>虽然相对前两年，我的焦虑感确实少了很多，但我并不认为已经一劳永逸地解决了这个问题，每个年龄段有不同的焦虑点，这似乎是一个一生需要关注的事情。我的这些方法虽然对自己有用，也不一定适合所有人，而且换城市、换工作的隐形成本是很大的。</p><p>我最近和学心理学的老同学聊了聊，顺便收集了一些工具、方法和书籍，总结出来供大家参考。</p><p>如果大家能一起来完善这个小手册就更好了，这文档共享在 Github：<a href="https://github.com/chenyukang/anxiety-handbook">anxiety-handbook</a></p><h2 id="自我测试"><a href="#自我测试" class="headerlink" title="自我测试"></a>自我测试</h2><p><a href="https://www.qqtest.com/s/20.htm">SAS 焦虑自评量表 - 健康心理测试</a></p><p><a href="https://www.idrlabs.com/cn/anxiety-stress-depression/test.php">焦虑、压力、抑郁测试</a></p><p>关于测试：</p><ul><li><strong>正确对待测试，不要对结果恐慌</strong>。测试前做好心理建设，不管结果多遭，不要害怕它，想想自己参与测试的初衷是想让事情朝正确的方向发展。</li><li><strong>将测试当作解决问题的工具</strong>。测试结果可以用来检测自己应对焦虑的情况：当焦虑变严重时，思考自己哪里没有做到位，不断改进克服它的方法；当焦虑减轻时，给自己一些奖励，让自己再放松一些。</li></ul><h2 id="认识焦虑"><a href="#认识焦虑" class="headerlink" title="认识焦虑"></a>认识焦虑</h2><p>焦虑多是由不确定引起的，是<strong>人类进化过程中保留下来的对外界的戒备</strong>。对于大部分人来说，焦虑是无法完全避免的，甚至适度的焦虑是能促使人进步。但是焦虑达到一定程度就会影响健康，特别是影响睡眠的时候情况更为糟糕。</p><blockquote><p>焦虑患者常常对现实生活中的某些事情或将来的某些事情表现的过分担忧，有时患者也可以无明确目标的担忧。这种担心往往是与现实极不相称的，使患者感到非常的痛苦。还伴有自主神经亢进，肌肉紧张或跳动等<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%BE%8B%E7%A5%9E%E7%B6%93%E5%A4%B1%E8%AA%BF" title="自律神经失调">自律神经失调</a> 的症状。部分患者会自觉身体总是不舒服多次去医院看医生，又检查不出症状。但是对于患者来说，总会一直担心。</p><p>– 维基百科</p></blockquote><p>就我个人体会，焦虑的时候会失眠、消化不良、精神紧张、心跳有时候感觉速度快。</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>认识到自己焦虑的原因是缓解焦虑的第一步，IT 从业人员的焦虑是很多是由国内的行业氛围、社会大环境导致的。</p><p>职场的 996 工作节奏、35 岁现象、末尾淘汰、职场 PUA 等等，这些让人没有足够的安全感。</p><p>另一部分原因是自我认知造成的，我们大多数人沿着社会预期的道路而行，并未想过自己想要什么样、适合什么样的生活。</p><p>这与教育和文化背景有关系，我们一直都存在一个较为单一的评价体系，在学校里面我们为了分数而竞争，毕业时我们为了一份的工作而竞争，职场上我们为了更好的绩效、更高的工资而竞争。竞争是我们的生活常态，而既然有竞争就会导致人有压力，日积月累形成焦虑。</p><p>而且，焦虑特别容易出现在对自己有要求的人群中，出现的年龄段也比较集中，焦虑大多出现在 25 ~ 40 左右，因为这个年龄段是职场和人生的关键期，也逐渐需要承担家庭的责任。</p><p>往往我们过了某些时间关口就会好一些，这个关口可能是认知和价值观上的改变，可能是学会了接纳自己，或者是学会了和焦虑相处。希望这个手册能帮你更快地闯过关口。</p><h2 id="职场焦虑"><a href="#职场焦虑" class="headerlink" title="职场焦虑"></a>职场焦虑</h2><p>摆脱焦虑一个很重要的部分是认识自己所处的环境，识别出周围环境中的有害因素，这包括国内 IT 行业的两个常见问题：</p><h3 id="内卷"><a href="#内卷" class="headerlink" title="内卷"></a>内卷</h3><p>内卷会让人长期处于无意义的竞争状态，非常容易让人滋生焦虑。国内很多 IT 公司存在内卷的情况，这里有一个 IT 从业者维护的 996 公司列表你可以参考。以我的经验来说，对于大型 IT 公司，个人所处于的小组和部门可能更重要，直属 Leader 对你影响很大程度上决定了你在公司的工作感受：</p><p><a href="https://github.com/996icu/996.ICU/tree/master/blacklist">996.ICU/blacklist · 996icu/996.ICU</a></p><p>如果你想改变内卷的环境，可以通过换组或者是换工作到 955 的公司，换城市、或者甚至去国外：</p><ul><li><a href="https://github.com/formulahendry/955.WLB">955.WLB 955 不加班的公司名单</a></li><li><a href="https://github.com/623637646/996.Leave">996.Leave 逃离 996</a></li><li><a href="https://github.com/chenyukang/remote-jobs-cn">remote-jobs-cn 国内远程办公职位</a></li></ul><h3 id="职场-PUA"><a href="#职场-PUA" class="headerlink" title="职场 PUA"></a>职场 PUA</h3><p>PUA 全称 “Pick-up Artist”，起初指的是受过系统化学习实践精神控制者，让异性着迷的男女们，字面上的解释 PUA 指的是搭讪艺术家。</p><p>PUA 是一种诱骗和洗脑的技术，从而神不知鬼不觉的达到自己的目的，而且这是一种很难发现，非常隐晦的一种欺骗方式。</p><p>一些管理者并没有良好的管理能力，倒是学会了一些抓人的手法，所以职场 PUA 是很多 IT 人面临的困境。常见的职场 PUA 手法：</p><ul><li>否定，不断批评和挑刺，有的时候会美其名曰鞭策你进步</li><li>打压，分配过多的任务，但是会告诉你在锻炼你</li><li>对比，拿你和别人对比，让你造成心理落差，或者怀疑自己的能力</li></ul><p><a href="https://www.bilibili.com/video/BV1pr4y1p7pB?spm_id_from=333.999.0.0">怎么看领导是培养还是 PUA 我？</a></p><p>当然还有很多手法，其实 PUA 的本质是让你觉得一切都是为了你好，从而让你不用怀疑地去执行任务。被 PUA 的人往往自身比较难以认识到，需要跳出来才能发现。</p><p>如果你的 Leader 让你太累，心理压力大，可以往这方面考虑一下自己是否在被 PUA。如果遭遇 PUA 解决办法就是换组或者换公司。</p><h2 id="改变认知"><a href="#改变认知" class="headerlink" title="改变认知"></a>改变认知</h2><p>焦虑部分是因为认知局限所造成的，所谓庸人自扰。提升思维高度可以从根本上解决一些问题。思维和认知的高度往往也涉及到对人生中重要事项的看法和选择，这包括：</p><ul><li>关于钱、工作的看法</li><li>是否待一线城市</li><li>是否结婚和要小孩</li><li>如何衡量成功</li><li>什么是幸福</li><li>对死亡的看法</li></ul><p>个人的经历可能会改变认知，除此之外阅读、观影、思考、交谈也可能会改变认知。下面是我收集的一些相关书籍和纪录片。</p><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p>解决焦虑问题类的书籍，往往被当作心灵鸡汤，鸡汤并没有不好，当你过于焦虑的时候，喝碗鸡汤有时候挺有用。另外一些哲学、历史方面的书也有用：</p><p><a href="https://book.douban.com/subject/2277299/">《当下的力量》</a> 生活在过去使人忧愁，生活在未来使人焦虑，最好的状态是活在当下。</p><p>《象与骑象人》如何获取幸福，过有意义的生活</p><p>《人生的智慧》叔本华关于健康、财富、名声、荣誉、养生和待人接物所应遵守的原则等。非常推荐。</p><p>《沉思录》</p><p>《被讨厌的勇气》</p><p>《获得幸福的勇气》</p><p><a href="https://book.douban.com/subject/35539713/">《焦虑的人》</a> 这是一本小说，情节跌宕起伏，故事温暖又治愈。</p><p>《精神焦虑症的自救》分为病例分析卷和访谈卷，包含对焦虑的全面介绍，还有大量摆脱焦虑情绪的技巧。</p><p>《焦虑是头大象，如何一口一口吃掉它》作者主张通过自我书写缓解焦虑，有书写的建议和方法，帮助人们辨别不同的焦虑状况如何用自我书写来缓解。</p><h3 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h3><p>好的纪录片能让人了解个人生活之外的广袤世界、历史长河，意识到人类之渺小，从而改变认知：</p><ul><li>蓝色星球</li><li>王朝</li><li>脸庞，村庄</li><li>河西走廊</li><li>人世间</li><li>徒手攀岩</li><li><a href="https://open.163.com/newview/movie/courseintro?newurl=M6HV755O6">哈佛大学公开课：幸福课</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="培养爱好"><a href="#培养爱好" class="headerlink" title="培养爱好"></a>培养爱好</h3><p>培养爱好可以缓解部分焦虑，因为爱好让我们从日常工作生活中脱离出来。很多中年人都是通过爱好来缓解生活中的琐碎感。</p><p>运动、写作、钓鱼、摄影、乐高等，都是非常好的爱好。</p><h3 id="日常技巧"><a href="#日常技巧" class="headerlink" title="日常技巧"></a>日常技巧</h3><p>常对自己说这几个字：</p><p><strong>“无所谓”<br>“没必要”<br>“不至于”</strong></p><p>冯唐分享过一个做法，如果你焦虑或者认为自己碰上了什么迈不过去的坎，找个医院去 ICU 门口待上一段时间。</p><h3 id="心理咨询"><a href="#心理咨询" class="headerlink" title="心理咨询"></a>心理咨询</h3><p>和行业相关的朋友咨询了一下，目前主流的心理治疗价目表：</p><ul><li><p>新手 200-300</p></li><li><p>中级 500-800</p></li><li><p>专家 1000 以上</p></li></ul><h3 id="药物治疗"><a href="#药物治疗" class="headerlink" title="药物治疗"></a>药物治疗</h3><p>常见药和副作用，待补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有的读者找我咨询问题，聊下来我发现 IT 从业人员共有的突出问题就是焦虑。现在疫情、政策等大环境原因导致行业不稳定和生活艰难，焦虑是很多人的常态。&lt;/p&gt;
&lt;p&gt;我也曾经焦虑过大概两年，这种状态刚开始自己还没意识到，直到出现了一些身体上很明显的症状才引起重视。后来经过一
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="职场" scheme="http://catcoding.me/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="程序员" scheme="http://catcoding.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>第 10 期，下一个 Google；最高形式的财富；冒名顶替综合症</title>
    <link href="http://catcoding.me/p/weekly-10/"/>
    <id>http://catcoding.me/p/weekly-10/</id>
    <published>2022-04-24T14:28:06.000Z</published>
    <updated>2022-05-06T08:32:29.274Z</updated>
    
    <content type="html"><![CDATA[<p>我每周会分享一下这周看到的好内容，加上自己的一些个人理解和评注，这算是一种比较轻的持续输出方式，前面三期为：</p><p><a href="https://catcoding.me/p/weekly-7/">#7 无聊的技术栈</a></p><p><a href="https://catcoding.me/p/weekly-8/">#8 Valve，另一种公司</a></p><p><a href="https://catcoding.me/p/weekly-9/">#9 理想中的开发者</a></p><p>这是第 10 期。</p><p>不知不觉我已经按照这种方式写作了 10 周，本来这周打算偷懒一下跳过这期，但一想到已经写了 9 周为什么不保持连续。你看，这种为自己定个计划的方式就像是契约，是培养习惯的好办法。</p><p>当然我觉得这种写作对自己还是有好处的，能让自己更深入阅读和思考。如果你对我的周刊有什么建议请告诉我！</p><h2 id="The-Next-Google"><a href="#The-Next-Google" class="headerlink" title="The Next Google"></a>The Next Google</h2><p><a href="https://news.ycombinator.com/item?id=30921628">The next Google | Hacker News</a></p><p><a href="https://dkb.io/post/the-next-google">The Next Google</a></p><p><a href="https://kagi.com/">Kagi Search</a></p><p>我觉得 Hacker News 非常好，主要是有一个非常好的讨论氛围，而且都是公开的。好遗憾，为什么没有类似的中文社区，或者有但我没有发现？</p><p>在这篇帖子中，大家在讨论一些其他的搜索引擎。Kagi 就是这样一个还在 Beta 阶段的产品，它认为每个人都应该定制自己的搜索选项和结果。</p><p>我觉得这也许是个方向，因为当一个产品已经做到市场的绝对统治时，只有差异化的方向才能有所突破，但这种差异化也就意味着小众。虽然大部分人对此项目表示悲观，但不少人说明了 Google 在某些方面确实需要改进。</p><p>做一个大众化的产品，界面越简单选项越少越好，因为大部分人其实都很懒，不想做选择，选择和记忆都是反人性的。Google 和 TikTok 都是这个道理：</p><blockquote><p>I think ‘more customization’ which is a theme with a lot of these alternatives is a fundamental dead end. I don’t know where this persistent myth comes from that people love choice and tinkering, because they clearly don’t. There’s a huge cost associated with having to make choices, and one feature of successful modern apps is that they’re frictionless. That’s why TikTok is so successful. There’s no login, no user chosen social graph, everything’s abstracted away.</p><p>And that’s by the way why Google is still successful as well. Because it literally still is a simple box where you put a question in and it gives you answers without needing to do anything else. The only way to beat that is to make it even better while not making it more complicated which is very hard to do.</p></blockquote><p>和中文互联网圈类似，人们也觉得现在太多的 “walled gardens” 让互联网变得不够开放：</p><blockquote><p>Open Web died or almost died because of walled gardens like Facebook, Instagram and Twitter. Billions of people who hang out on Facebook, Instagram and Twitter would hang out instead on Open Web e.g. websites, blogs, forums etc. if walled gardens didn’t exist.</p></blockquote><p><strong>walled gardens</strong> 这个词太形象了，我们现在都习惯于有围墙的花园了。这很多都是资本的产物，因为资本要盈利，围墙就被当作了护城河。</p><p>也许 Web3 能一定程度解决这个问题，谁知道呢。</p><h2 id="最高形式的财富"><a href="#最高形式的财富" class="headerlink" title="最高形式的财富"></a>最高形式的财富</h2><p> <a href="https://www.collaborativefund.com/blog/the-highest-forms-of-wealth/">The Highest Forms of Wealth · Collaborative Fund</a></p><p>财富能带来幸福和快乐么，当然可以，但是前提是没有被滥用。钱就像是氧气，没有肯定不行，但是多了似乎就没有更多好处。这篇文章中提出的观点我觉得很好：</p><blockquote><ul><li>Desiring money beyond what you need to be happy is just an accounting hobby.   </li><li>How much money people need to be happy <a href="https://www.collaborativefund.com/blog/goalpost/">is driven more by expectations</a>  than income.</li></ul></blockquote><p><strong>相比于纯粹地追求财富，我们更应该追求自由和独立</strong>。</p><p>虽然做一样的事情，<strong>被逼着做和自由选择地去做有着天壤之别</strong>：五岁的富兰克林·罗斯福抱怨说，他的生活被规则主宰着。所以他妈妈给了他一天自由的时间他可以做任何他想做的事，罗斯福那天在日记中写道：他很自觉地心满意足地回到了他的日常生活中，做着和之前同样的事。</p><p>钱可以让人可以选择不考虑钱的问题，而现实是有很多富人虽然很有钱，但是没时间：</p><blockquote><p>Charlie Munger summed it up: “I did not intend to get rich. I just wanted to get independent.” It’s a wonderful goal, and harder to measure than net worth.</p></blockquote><p>赚钱是一种特殊的技能、甚至是运气，而对于很多人来说，如何在没有财务自由的情况下不关心钱却是幸福快乐的秘诀。</p><blockquote><p>A thing I’ve noticed over the years is that some of the wealthiest people think about money all the time – which is obvious, because it’s causation. But it’s an important observation because most people, despite aspiring to become one of the wealthiest, actually want something different: <strong>the ability to not have to think about money.</strong></p></blockquote><p>结合这篇文章看会有更多启发：</p><p><a href="https://amaca.substack.com/p/how-i-got-wealthy-without-working?s=r">How I got wealthy without working too hard</a></p><h2 id="冒名顶替综合症"><a href="#冒名顶替综合症" class="headerlink" title="冒名顶替综合症"></a>冒名顶替综合症</h2><p><a href="https://blog.rust-lang.org/inside-rust/2022/04/19/imposter-syndrome.html">Imposter Syndrome</a></p><p>Rust Inside 是一个 Rust 社区的官方博客，最近发了一篇关于冒名顶替综合症的文章，可以说 IT 行业从业者很多人都有这个症状。</p><p>Rust Foundation 工作人员会和一些贡献者联系，帮他们申请资金赞助。在实际的运作过程中，尽管一些贡献者喜欢这个机会，但他们觉得自己不配或者不够资格申请赞助，因为自认为与其他杰出贡献者相比，自己做的微不足道。</p><p>当我们低估自己知道的东西，夸大我们认为别人知道的东西时，就会出现冒充者综合征，这种效应通常会被系统性的偏见所强化。</p><p><img src="/images/ob_pasted-image-20220424134040.png" alt=""></p><p>这一现象具体表现在：</p><ol><li><p>取得现实的外部的成就，但是没有内在的成就感</p></li><li><p>认为周围的人高估了自己的能力</p></li><li><p>把自己的成就归因为运气或者其他外界因素</p></li><li><p>担心恐惧别人会发现自己其实是假的，其实自己能力没有别人想象的那么好</p></li><li><p>自己做的好的地方不给自己奖励，无法接纳也不相信别人对自己的赞扬</p></li></ol><p>我自己也有一些这方面的问题，<strong>感觉造成的最大困扰是不够自信</strong>。</p><p>不过这些年逐渐好一些了，因为我了解到很多人看起来很优秀或者很强，因为网络是个放大器，如果真实了解下来与你我并没有太大差异，或者我们没看到别人成果下的努力和挣扎，从而给自己强加了一些 peer pressure。</p><p>所以，你有这方面的问题么？有什么好的解决办法可以分享给我🙌</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我每周会分享一下这周看到的好内容，加上自己的一些个人理解和评注，这算是一种比较轻的持续输出方式，前面三期为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://catcoding.me/p/weekly-7/&quot;&gt;#7 无聊的技术栈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="周刊" scheme="http://catcoding.me/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>我如何学“会”了 Rust</title>
    <link href="http://catcoding.me/p/my-experience-learning-rust/"/>
    <id>http://catcoding.me/p/my-experience-learning-rust/</id>
    <published>2022-04-21T12:35:06.000Z</published>
    <updated>2022-05-06T08:32:29.266Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ob_pasted-image-20220421211405.png" alt=""></p><p>最近我打算把自己的小项目 <a href="https://github.com/chenyukang/obweb/">Obweb</a> 后端用 JavaScript 重写，之前是用 Rust 写的。</p><p>重写基于以下考虑：</p><ul><li>Rust 受众少，和 Obsidian 的用户群体重合的就更少了</li><li>Rust 开发 Web 后端确实不便，虽然我也看过其他的 Rust Web Framework，但看起来都还不太成熟</li><li>在使用 Web 框架 Warp 的过程中有很多坑，而且代码看起来异常复杂</li><li>Web 开发这块 JavaScript 有很多现成的库</li><li>这个项目比较简单，性能不敏感，使用 Nodejs 也不会有大的差异</li><li>我想写写 JavaScript </li></ul><p>当初用 Rust 也只是为了练手，今天聊聊自己如何跟进这门小众而、难学的编程语言，顺便谈谈这些年我对 Rust 的一些感受。</p><p>我最早关注到 Rust 是 2014 年，当时还没发布 1.0 ，但是核心的概念和设计理念已经定了，那就是不走 GC，通过编译器保证类型和内存安全，兼顾性能和安全。</p><p>接触没多久后我试着实现一个简单的 scheme 解释器，就写这个小项目 <a href="https://github.com/chenyukang/rust-scm">rust-scm</a> 。这种几百行的项目就能很好的上手一门编程语言，因为在这个过程中会涉及输入输出、递归、测试，抽象方式等。</p><p>当时我觉得 Rust 用起来还行，但是有些部分很复杂，比如指针还有 Borrow Checker，另外最大的问题当然是第三方库太少。</p><p>那时还有一个印度程序员 ckkashyap 开了一个坑，用 Rust 写一个 Unix-like 的操作系统 <a href="https://github.com/ckkashyap/rustix">rustix: Unix kernel in rust</a> ，我看有点意思就跟着做了几个 PR。没多久他就弃坑了，转去搞一门更小众的编程语言 Nim，打算重新用 Nim 实现 xv6 <a href="https://github.com/ckkashyap/nim-xv6">nim-xv6: Translate xv6 to nim</a> 。不过我们一直保持联系，有时候在 gtalk 上聊聊。他工作了大概有 20 年，非常喜欢折腾。后来他换工作去了微软，碰巧随后几年我也去了微软，最近他给我发邮件说又开了新坑 <a href="https://github.com/lispware/minilisp">lispware/minilisp</a> ，一起来搞啊，哈哈，我们这些 Polyglot Programmer 就是这么容易见异思迁。</p><p>后来几年我也没太关注 Rust 了，只是偶尔看看官方的一些文章之类的。在这期间国内的数据库公司 PingCap 发展起来了，国内也出现了一些 Rust 语言爱好者。</p><p>中间这些年，我有时会在 <a href="https://exercism.org">https://exercism.org</a> 上写写练习，这些上面的编程题不是算法，而是一些典型的简单编程挑战，包含测试用例，非常适合用来练手在学的语言。</p><p><img src="/images/ob_pasted-image-20220420174057.png" alt=""></p><p>这个网站更好的地方在于里面有一些各个语言的爱好者当导师，你可以选择让他们 review 你的代码，这样就可以从经验丰富的导师那里学一门语言的最佳实践：</p><p><img src="/images/ob_pasted-image-20220420174816.png" alt=""></p><p>最近一年多我重新关注 Rust，发现热度比之前好多了，Github 上不少项目都在用 Rust 写 (当然也可能是我自己之前关注了一些开发者，他们继续在折腾)，相关的生态和工具链也发展起来了，比如 rust-analyzer 加上 VSCode 的开发体验非常好，比如 Cargo 管理包很好用。</p><p>Rust 近些年在区块链和 WebAssembly  两个领域发展得不错。我认为 Rust 适合那些性能和安全性要求比较高的项目，比如 Infrastructure、存储、交易之类的项目，而一般的纯业务之类的项目就不太适合。</p><p>回顾起来发现 2021 年我参与的几个项目都和 Rust 相关：</p><ul><li><a href="https://github.com/chenyukang/gomoku">gomoku</a></li><li><a href="https://github.com/containers/youki">containers/youki: A container runtime written in Rust</a></li><li><a href="https://github.com/wasmerio/wasmer">wasmerio/wasmer: WebAssembly Runtime</a></li><li><a href="https://github.com/second-state/dapr-wasm/">second-state/dapr-wasm</a></li></ul><p>可以说我学会了 Rust，能自己写些小项目，能在 Rust 的中大型项目中做贡献，也对 Rust 本身做贡献，但是我对一些语言细节不太清楚，比如我做 <a href="https://dtolnay.github.io/rust-quiz/">Rust Quiz</a> 发现好多都做不出来。事实上 Rust 因为走了一条独特的设计思路，导致语言本身比较复杂。</p><p>我的学习方法就是时不时地开个坑练手，或者去参与到一些比较活跃的开源项目中。我买了一本中文版本的 Rust 书，但是感觉没耐心看完。</p><p>对于大部分开发任务，我们没有必要掌握一门编程语言的所有细节。好办法是花尽量少的时间去掌握日常开发所需要的 80%，而不是花 80 % 时间去掌握平时比较少见的 20%。我觉得对于 Rust 来说，20% 包括宏、Unsafe，还有一些复杂的 Pointer、Pin 之类的东西，这些需要了解的时候再去看看就行。</p><p>前几天看到 geekplux 写的<a href="https://geekplux.com/posts/how-i-learned-programming">我是如何学会编程的</a> 有类似的概括：</p><blockquote><p><strong>编程只是一个工具，学习一门技术的时候要快速掌握其最核心的部分，抛弃细枝末节，直接动手实现目标，中途遇到不会的再 Google 即可</strong>。这样才是高效快速的学习方式。</p><p>学会这个思维的<strong>好处</strong>是，我后来学什么都特别快，自我总结出一套<a href="https://geekplux.com/posts/learning-by-index">学习方法</a>。但<strong>坏处</strong>是知识点掌握的不牢靠，很多细节需要现学现卖，这在日常编程中好像没什么影响，随手 Google 随手写，但面试就很差了，毕竟面试是通过考察细碎的知识点来衡量你的知识面（我不苟同这个面试方式，但确实是现在最流行的）。</p></blockquote><p>学习新东西从来不是线性的，所以如果你看别人给出一个最佳的学习路径，比如看完某本书，然后再看另外一本更深入的，然后再买个什么课….</p><p>这种路线也许可以参考，但也别太当真，学会了的标准肯定是能拿来应用。我认为绝大部分书没有官方的文档更有价值，大部分课程还没有直接在开源项目中实践更有效。</p><p>所以我建议不管是新手还是老鸟，要学一门新技术就去看官方文档，然后自己试着做些小项目，如果还想继续深入就做一些更大的项目，或是参与到开源项目中去。</p><p>通常是技术不难学，但是领域知识比较难学，因为要实践某些领域知识需要相关环境和工作内容。</p><hr><p>2022 我打算好好学一下 JavaScript 😉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ob_pasted-image-20220421211405.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近我打算把自己的小项目 &lt;a href=&quot;https://github.com/chenyukang/obweb/&quot;&gt;Obweb&lt;/a
      
    
    </summary>
    
    
      <category term="编程" scheme="http://catcoding.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>第 9 期，理想中的开发者；Generative Art；学习 Container</title>
    <link href="http://catcoding.me/p/weekly-9/"/>
    <id>http://catcoding.me/p/weekly-9/</id>
    <published>2022-04-15T18:07:05.000Z</published>
    <updated>2022-05-06T08:32:29.274Z</updated>
    
    <content type="html"><![CDATA[<p>我每周会分享一下这周看到的好内容，加上自己的一些个人理解和评注，这算是一种比较轻的持续输出方式，前面三期为：</p><p><a href="https://catcoding.me/p/weekly-6/">#6 创造者和实施者</a></p><p><a href="https://catcoding.me/p/weekly-7/">#7 无聊的技术栈</a></p><p><a href="https://catcoding.me/p/weekly-8/">#8 Valve，另一种公司</a></p><p>这是第 9 期。</p><h2 id="理想中的开发者状态"><a href="#理想中的开发者状态" class="headerlink" title="理想中的开发者状态"></a>理想中的开发者状态</h2><p>你理想中的开发者状态是什么样的？</p><p>肯定不是无尽的会议和摧残的 996。</p><p>看到这位日本开发者的视频之后，我觉得这就是理想中的开发者状态。</p><p>这位独立开发者花了 6 年时间做了一个面向开发人员的 Markdown 编辑器，这里有个产品介绍视频：</p><p><a href="https://www.youtube.com/watch?v=-qBavwqc_mY">How to take notes in Markdown efficiently with Inkdrop</a></p><p>老实说，我已经找到了适合自己的 Markdown 编辑工具，但是我还是被他的视频深深吸引，忍不住试试他的产品。</p><p>他的视频里都没有说一句话，都是通过键盘敲打声音带出字幕，画面从东京街头随拍一直切换到自己临时租的小屋，整整 40 分钟他就在那里默默地使用自己的编辑器，偶尔伸个懒腰或者抿口茶，背景音就是一些好听的键盘声和轻音乐。</p><p><img src="/images/ob_pasted-image-20220415160810.png" alt=""></p><p>这太独特了！我们可以通过视频感受到他对自己产品的执着、自豪、和品味。</p><p>然后我接着看他其他的视频：</p><ul><li><a href="https://www.youtube.com/watch?v=bSMZgXzC9AA">How to build a portfolio website using Next.js, Chakra UI, Framer Motion, and Three.js</a></li><li><a href="https://www.youtube.com/watch?v=GznmPACXBlY">How I built a software agency website with Next.js and Tailwind CSS</a></li></ul><p>里面有从头到尾展示如何做一个好看的主页，跑到深山老林依着山涧泉水给朋友做网站，我想这大概就是程序员界的李子柒吧，他拍出了我理想中的开发者状态。</p><p>现实中独立开发者其实很苦，刚好我这周看到个 v2ex 上关于独立开发者的讨论，<a href="https://www.v2ex.com/t/846708">个人开发者处境是否越来越困难了</a> ，大家在诉苦国内 Andriod 独立开发者要上线一个产品越来越难。</p><p>这里还有些大环境的原因，<strong>这个年代已经是存量时代</strong>，几乎任何一个领域都存在多个竞品，用户似乎不缺少软件，问题是用户为什么要选择你的产品。</p><p>而作为个人开发者除了能写代码，还需要会营销和宣传，比如上面那位日本开发者的手法，品位、情怀、故事，这些都是代码之外的事，但在这个存量年代这些就很重要。</p><h2 id="Generative-Art"><a href="#Generative-Art" class="headerlink" title="Generative Art"></a>Generative Art</h2><p>这周我不经意间看了一些 Generative Art 相关的东西。</p><p>在我的 Ob 里一直收藏着这个介绍傅里叶的网页地址：<a href="https://www.jezzamon.com/fourier/zh-cn.html">傅里叶变换交互式入门</a> 。这个文章写得很好，已经被翻译成多国语言，非常生动地解释了傅里叶变换是如何工作的。网页上看到的动画都是通过纯 JavaScript 在 Canvas 上画出来，所有代码都是开源的。</p><p>然后我又在 B 站看到 AnthonyFu 介绍如何实现梅花的动画，<a href="https://www.bilibili.com/video/BV1wY411n7er?spm_id_from=333.337.search-card.all.click">用 Canvas 做梅花生长动画</a> 。</p><p>我之前看他的个人主页时也注意到了背景里的那个图画效果。他这在视频里介绍这也是递归的一个实现，只是中间加了一些随机性，比如长度、角度上的随机。</p><p>这两个都算是 Code Generative Art 的例子，我们通过这个关键词去搜能找到很多类似、好玩的东西。</p><p>这篇文章 <a href="https://aiartists.org/generative-art-design">Generative Art: 50 Best Examples, Tools &amp; Artists</a> 非常全面地介绍了这个主题。<br><img src="/images/ob_pasted-image-20220415150359.png" alt=""></p><blockquote><p>“What I enjoy the most is the complex and intricate results you can get from a set of simple rules.” </p><p>— Anders Hoff</p></blockquote><p>想起来我在学校的时候也做过一些简陋的类似东西，比如我这个<a href="https://github.com/chenyukang/Maze">迷宫生成器</a>:<br><img src="/images/ob_pasted-image-20220415150012.png" alt=""></p><p>动画和可视化都能给观众深刻的印象，简单的规则加上随机性就能做出很多精妙的东西。</p><h2 id="学习-Container"><a href="#学习-Container" class="headerlink" title="学习 Container"></a>学习 Container</h2><p><a href="https://iximiuz.com/en/posts/container-learning-path/">Learning Containers From The Bottom Up</a></p><p>作者写了很多 Container 相关的文章，质量都非常高。我对这些有兴趣，打算以后如果有时间也写写这个系列。</p><p>如果要学习 Container 的原理和内部实现，不一定要盯着 runc，可以看看后来一个红帽员工用 C 实现的 <a href="https://github.com/containers/crun">crun，A fast and lightweight fully featured OCI runtime and C library for running containers</a> 。</p><p>我参与的这个项目：Rust 实现容器 <a href="https://github.com/containers/youki">containers/youki</a>，里面很多都是参考的 crun 的。C 代码其实比 Go、Rust 都精简。</p><hr><p>这就是本周的分享了。</p><p>我本来打算这周离开苏州回老家待着，结果因为疫情的变化，我不敢去车站了，所以继续宅在苏州等等看吧。</p><p>大家保重！😷</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我每周会分享一下这周看到的好内容，加上自己的一些个人理解和评注，这算是一种比较轻的持续输出方式，前面三期为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://catcoding.me/p/weekly-6/&quot;&gt;#6 创造者和实施者&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="周刊" scheme="http://catcoding.me/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>成为 UP 主</title>
    <link href="http://catcoding.me/p/be-a-creator/"/>
    <id>http://catcoding.me/p/be-a-creator/</id>
    <published>2022-04-13T18:09:59.000Z</published>
    <updated>2022-05-06T08:32:29.262Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ob_pasted-image-20220413084633.png" alt=""></p><p>上周我录制了一个视频分享在 B 站，<a href="https://www.bilibili.com/video/BV18Y4y1H7Gu">程序员使用 Obsidian 的经验</a> 。</p><p>这算是我践行多元发展的一个尝试吧，看起来作为 UP 主我取得了一个好开头，视频发布三天已经有三千多的观看记录，播放量超过了自己公众号文章的阅读量，而且这是一个 28 分钟的视频，可比看一篇文章的几分钟要长多了。</p><p>和大家分享一下过程和收获，算是 BTS。</p><p>先谈谈动机，上次我写了一篇文章 <a href="https://catcoding.me/p/obsidian-for-programmer/">我的 Obsidian 使用经验</a> ，感觉文字在这种需要演示的场景下显得无力，因此萌发了做视频的想法。</p><p>我看过一些 Obsidian 相关的视频，有的讲解得很棒，剪辑得也很好，但太多是关于 Ob 产品的介绍、插件介绍和使用，我想看的是真实的笔记场景和流程，而且我自己总结出来的这套流程好像没有人提及过。</p><p>所以我就开干了。</p><p>前期选择和试用各种录屏工具，我总共花了大概两个小时，最后的选择是 <a href="https://obsproject.com/">Open Broadcaster Software</a> 。其他我觉得也不错的备选是 Zoom 和 B 站的必剪，以后我再试试。</p><p>录制的整个过程花了差不多一个小时，因为我没有经验，首次录制完了之后才发现没声音，然后又重新录制了一遍。</p><p>当然还是有诸多不满意，但我已经比较累了，我想这次就先这样吧，于是立刻发布了。随后我去 v2ex 发了个帖子宣传了一下，B 站的流量很不错，因为我发的帖子点击才 1400 多，那最终点进去看的也不到 1000 左右？所以后续的观看应该基本是 B 站本身的流量积累起来的</p><p>看数据统计时发现我的粉丝 100 % 男性，25 岁以下和 40 岁以上居多，难道就没有对 Ob 感兴趣的女生🤣?</p><p>另外 B 站果然是学习的好地方，通常都是深夜开始学习。</p><p><img src="/images/ob_pasted-image-20220413090508.png" alt=""></p><p>通过第一次实践我学到了：</p><p><strong>不用力求完美</strong>，因为作为新手第一次就力求完美，会导致耗费太大力气，从而产生抗拒心理。如果第一次视频比较快完成，而且我也知道了一些明显的改进点，就会想着赶紧下次实践。</p><p><strong>宣传</strong>，如果我没有在 V 站发帖，肯定是没有这么多人看的。这个朴实策略我之前也提到过：找到自己的目标受众，尽量创造出好的内容。</p><p><strong>自信</strong>，我和大多数技术人一样，不擅长演讲。但这种录视频可以很好地规避公开演说的紧张和压力，我们可以反复练习，也可以后期修改，所以做视频分享其实适合我这种内向型的人。我也怕在录音中听到自己的声音，不太好解释这种心理，反正就是感觉不真实或者和自己想象中的不一样。这次录完后我认真听了一遍，发现普通话确实不太标准，另外有时候稍显啰嗦。但我觉得内容大于形式吧，真实也是一种特色。</p><p><strong>创作者心态</strong>，当自己试着写些文章、做视频之后，会发现不自觉就抱有一种创作者心态，再去看文章、视频时会去关注一些很细的问题，想着哪些地方可以模仿学习。</p><hr><p>后续更新计划，如果时间允许我会再录一些 Obsidian 相关的视频，后续我会尝试着做技术学习、代码解读分析这方面的分享，欢迎关注<a href="https://space.bilibili.com/477825203">我的 B 站</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ob_pasted-image-20220413084633.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上周我录制了一个视频分享在 B 站，&lt;a href=&quot;https://www.bilibili.com/video/BV18Y4y1H7
      
    
    </summary>
    
    
      <category term="视频" scheme="http://catcoding.me/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="创作者" scheme="http://catcoding.me/tags/%E5%88%9B%E4%BD%9C%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>魔幻......</title>
    <link href="http://catcoding.me/p/complaint/"/>
    <id>http://catcoding.me/p/complaint/</id>
    <published>2022-04-10T12:13:06.000Z</published>
    <updated>2022-05-06T08:32:29.262Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇算是一个纯吐槽，我真觉得很魔幻…..</p><p>昨天我看到一个新闻，<a href="https://mp.weixin.qq.com/s/l8u9JifKDlRDoz32-jZWQg">核酸结果统计难？复旦博士生的操作火了</a></p><p><img src="/images/ob_pasted-image-20220410093443.png" alt=""></p><p>这位博士当然干了一件大好事，在疫情这种节骨眼上大量节省了手工操作的时间，为民解难。</p><p>给他点赞！</p><p>接着我就觉得悲哀、难过。</p><p>现在疫情这种紧急情况中，如果这样的事还被拿国字号媒体拿来宣传，这说明这事有些罕见。</p><p><strong>我们仍然用着最原始的数据工具和方法，人肉手工去处理大量疫情相关的数据，效率如此低下。</strong></p><p>就在前几天，我老婆给我发了一个截图，说同学所在单位 (政府机构) 要处理一个疫情的表格，要把批注导出按照小区重新组合，数据量比较大，他们百度之后不知道如何解决，问我这个老程序员能不能解决：</p><p><img src="/images/ob_pasted-image-20220410094110.png" alt=""></p><p>我纳闷了一会儿，这个对于稍微熟悉 Excel 的人应该不难吧，毕竟 Excel 有效率极高的宏操作….  而且发给我这个外人会不会涉及到隐私信息。</p><p>我说发给我试试吧，我老婆把我的号码给了那位同学，不过后来他也没发给我了。</p><p>所以，我昨天看到那个新闻后不禁感叹，复旦这还算是上海，还在人才济济的高校，能有博士出来随手解困，像我老家那种小地方呢？</p><p><strong>全国有多少我老家那种小地方，而上海只有一个。</strong></p><p>即使是做疫情的 IT 系统，技术方式仍然采用的是上世纪的。以前 VeryCD 的老大 Dash 最近在网上吐槽上海核酸检测：</p><p><img src="/images/ob_pasted-image-20220410100020.png" alt=""></p><p>我上个月在深圳的时候，发现也是这样的分了多个入口：<br><img src="/images/ob_pasted-image-20220410101840.png" alt=""></p><p>难道做这些系统的人还不知道负载均衡为何物…..</p><p>后来我看一些网友分析的，可能原因是：</p><ul><li>外行领导内行，领导觉得这样能解决问题</li><li>每个入口是一个承包商【虽然我觉得不太可能】</li></ul><p>最后看到这个解释，我释然了……<br><img src="/images/ob_pasted-image-20220410102014.png" alt=""></p><p>再想想西安「一码通」的那事，唉。</p><p>疫情已经两年多了，我们可以看到各地的流调报告仍然是在用 Word，Excel 之类的东西人肉管理，没有接口，没有系统互联，相关的信息化、数字化建设还没跟上。</p><p>而另一面，我们称自己是人工智能强国，我们互联网技术已经数一数二。</p><p>这就很魔幻…..</p><p>我们并不缺计算机人才，每年毕业几百万的应届生，其中往计算机行业转的人几乎有 1/3？每年也有大量经验丰富的 35 岁技术人员从互联网公司退下，这些都是马老师所说的<strong>为社会输送人才。</strong>…</p><p>人才输送到哪里呢？</p><p>公务员考试超过 35 岁都不行….</p><p>而这些机构单位要是稍微多招几个懂点计算机的，也不至于项目外包的时候被人坑，也不至于这么多民生相关的系统仍然只能用 IE，也不至于数据处理还需要博士使用“黑科技”来解救。</p><p>当然，我知道这很难，也很复杂，很多不能言说……</p><p>最近看了些上海疫情相关的事，心情低落，权当吐槽吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天这篇算是一个纯吐槽，我真觉得很魔幻…..&lt;/p&gt;
&lt;p&gt;昨天我看到一个新闻，&lt;a href=&quot;https://mp.weixin.qq.com/s/l8u9JifKDlRDoz32-jZWQg&quot;&gt;核酸结果统计难？复旦博士生的操作火了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
    
      <category term="吐槽" scheme="http://catcoding.me/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>Valve，另一种公司</title>
    <link href="http://catcoding.me/p/weekly-8/"/>
    <id>http://catcoding.me/p/weekly-8/</id>
    <published>2022-04-09T10:49:05.000Z</published>
    <updated>2022-05-06T08:32:29.274Z</updated>
    
    <content type="html"><![CDATA[<p>我每周会分享一下这周看到的好内容，加上自己的一些个人理解和评注，这算是一种比较轻的持续输出方式，前面三期为：</p><p><a href="https://catcoding.me/p/weekly-5/">#5 财富的三个车道</a></p><p><a href="https://catcoding.me/p/weekly-6/">#6 创造者和实施者</a></p><p><a href="https://catcoding.me/p/weekly-7/">#7 无聊的技术栈</a></p><p>这是第 8 期。</p><h2 id="Faster-sorting-with-Go-generics"><a href="#Faster-sorting-with-Go-generics" class="headerlink" title="Faster sorting with Go generics"></a>Faster sorting with Go generics</h2><p>Eli Bendersky 的技术文章可以作为技术写作的典范，他写这个博客已经 20 年了。</p><p>最近他写了一篇关于 Go 泛型的文章，通过排序算法来探索 Go 的泛型实现：</p><p><a href="https://eli.thegreenplace.net/2022/faster-sorting-with-go-generics/">Faster sorting with Go generics - Eli Bendersky’s website</a></p><p>文中作者实现了两个版本的冒泡排序算法，第一个版本是通过 Interface 实现，第二个版本是用泛型实现的，通过 Benchmark 发现泛型版本要快 20%。</p><p>Go 团队核心成员 Russ Cox 之前写到过：</p><blockquote><p>When a language decides on whether to have generics and how to implement them, it faces the following decision:</p><ul><li>do you want slow programmers, slow compilers and bloated binaries, or slow execution times?</li></ul></blockquote><p>不支持泛型就是 slow programmers，但是目前主流的泛型实现各有各的问题：</p><ul><li><p><strong>Slow compilers and bloated binaries</strong> 是指 C++ 那种 full monomorphization 的方式，编译器为每一处实际的泛型函数调用生成对应的函数代码，导致编译时间过长。写过 C++ 的程序员都有些体会，我以前那个公司的代码量也不至于很大，但是编译一遍得差不多一个小时。</p></li><li><p><strong>Slow execution times</strong> 是指 Java 那种 dynamic dispatch，调用的时候会动态分发，导致运行时开销。</p></li></ul><p>Go 团队采用了介于这两种之间的方法，像 int、string 这些原子型的类型就通过 full monomorphization 而其他复合类型使用 dynamic dispatch。</p><p>作者继续通过性能分析，对比反汇编后的指令来看这两者之间的差别。基于以上原理，上面的例子程序因为要排序的是 string 所以用的是 full monomorphization，这样对比 interface 版本少了 method dispatch 的时间，而且利用了编译器的另一个叫做  <a href="https://go101.org/article/bounds-check-elimination.html">bounds-check elimination</a> 的优化，这样 string 对比的时候没有 bound index 的检查。</p><p>不过既然 Go 采用的是混合的方式，也可能某些情况使用泛型的代码比 Interface 更慢，参考这篇文章： <a href="https://planetscale.com/blog/generics-can-make-your-go-code-slower">Generics can make your Go code slower</a></p><p>看起来 Eli Bendersky 的这篇文章也写了三周左右！他写博文通常会有完整的示例程序，非常严谨。</p><h2 id="180-天，每天做个简单网页"><a href="#180-天，每天做个简单网页" class="headerlink" title="180 天，每天做个简单网页"></a>180 天，每天做个简单网页</h2><p><a href="https://blog.jenniferdewalt.com/post/62998082815/after-180-websites-im-ready-to-start-the-rest-of">After 180 Websites, I’m Ready to Start the Rest of My Life as a Coder</a></p><p><a href="https://jenniferdewalt.com/">Jennifer Dewalt</a></p><p>这位女生学习编程的方式非常独特：</p><ul><li>连续 180 天</li><li>每天都完成一个虽然简单但足够完整的网页，写对应的博文</li><li>所有的代码都是开源在 Github 上</li></ul><p>她是学美术出身的，但是对互联网很感兴趣，所以想自己试着做一些东西来分享美术。我随便选了一些她完成的网页，感觉有些想法和设计不错。</p><p>比如这个 <a href="https://jenniferdewalt.com/window/page">窗户应用</a> 的效果，看起来非常逼真，而且关闭窗户的时候声音也会跟着变。</p><p>在这个过程中她学到的最重要的是：</p><blockquote><p>“Start Small. Keep Building.”</p></blockquote><p>这个女生的学习编程的方法非常好！</p><p>我虽然编程很多年，但是前端开发很少涉及，去年我想做一些东西所以自学了些前端技能。自学时我发现最有用的是这个 Github 代码仓库 <a href="https://github.com/bradtraversy/vanillawebprojects">Mini projects built with HTML5, CSS, JavaScript</a>  ，如果一个前端新手，能把这些例子都看一遍，基本就能上手了。</p><p>有的人在学习编程的时候，会有一种学生思维，比如等我先学 HTML，然后再看完这本 css 的书，然后就可以继续学 JavaScript ，然后再学 Vue 之类的。</p><p>这样很可能会磨灭学习兴趣，特别是对学习偏实际应用的前端技术而言，更好的学习路线就是想一个应用，做出来，然后再接着做更复杂的，在这个过程中边学边做，不懂的时候去补。<strong>我们要掌握的是能力，而不是知识。</strong></p><h2 id="Valve-的员工手册"><a href="#Valve-的员工手册" class="headerlink" title="Valve 的员工手册"></a>Valve 的员工手册</h2><p><a href="https://www.valvesoftware.com/en/publications">Publications - Valve Corporation</a></p><p>这个员工手册有各种语言的版本，手册里面还配有漫画，写得也很简洁，非常用心。</p><p>Valve 的这种企业几乎是独一无二的，这是他们的组织架构随着人数的变化演变：</p><p><img src="/images/ob_pasted-image-20220408230715.png" alt=""></p><p>可以看到里面完全是自由组织的一些项目组，员工自己决定做什么，加入哪个小组，手册里还说明了如何快速移动办公桌，这样你就可以随意搬到自己喜欢的项目组🤣。</p><p>每个组都有一个组长一样的角色，但主要是承担沟通枢纽的职责，而不是纯粹的管理，Valve 认为完全按照等级制度来构建公司会有严重弊端：</p><blockquote><p>等级制度会通过招募更多适合这一制度的人从而实现自我强化，让更多的人来充当下属的角色。最后，原先为客户服务的单纯目的将逐渐被成员利用体制谋求私利的欲望和行动所取代和吞噬。</p></blockquote><p>员工的成长不是等级的攀升，而是能力和收入的提升，Valve 鼓励员工向各个方面多元发展自己的能力。</p><p>这样看起来每个人都在掌握方向盘：</p><p><img src="/images/ob_pasted-image-20220408231451.png" alt=""></p><p>那这样组建公司的前提是什么？</p><p>就是要招聘到<strong>能力强而又协作、沟通足够好的人</strong>，所以他们的第一任务是<strong>招聘</strong>。</p><p>看完他们的员工手册后，引起了我的一些思考，Valve 看起来像是构建了一个乌托邦，居然还运行得如此好。</p><p>等级制度的弊端我们很容易体会到，比如员工为了晋升可能会做一些短期就有成果的事，虽然员工晋升了，但是这些事对公司而言真的是有价值的么？比如我们看到，很多公司的中层管理肆意招聘，因为手下的人多往往意味着 visibility，这在很多快速扩张的公司并不少见，而当危机真正来临的时候，大量裁员就出现了。</p><p>为什么世界上绝大部分公司是按照等级的架构来组织的，我想这几乎是刻在人类基因里的，我们可以看到在动物世界里，大猩猩、猴子、狼群等都有类似的组织形式。</p><p>另一个原因大概是，大量的优秀而又善协作的人才太少了，等级制度可以认为是精英治理，最基层的员工做的活都是单一而细分的，这样员工都是可以随意替换。</p><p>而且世界上大部分公司，所需要做的事大量是实施类工作，而 Valve 这样的游戏公司需要的是很多创意，公司性质的不同也决定了不同的组织模式。</p><p>当然，世界上有 Valve 这样的公司真是太好了！我顺便看了看这篇文章： <a href="https://www.a9vg.com/article/30432">关于 Steam、Valve 和 G 胖 你可能不知道的二三事</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我每周会分享一下这周看到的好内容，加上自己的一些个人理解和评注，这算是一种比较轻的持续输出方式，前面三期为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://catcoding.me/p/weekly-5/&quot;&gt;#5 财富的三个车道&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="周刊" scheme="http://catcoding.me/tags/%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>写作 12 年，我的经验和技巧</title>
    <link href="http://catcoding.me/p/writing-for-joy/"/>
    <id>http://catcoding.me/p/writing-for-joy/</id>
    <published>2022-04-06T12:58:06.000Z</published>
    <updated>2022-05-06T08:32:29.274Z</updated>
    
    <content type="html"><![CDATA[<p>多年以后，如果我还沉浸在写作的乐趣中，一定还记得 2019 年那位给了我鼓励和帮助的陌生读者，他帮我完整地润色了一篇长文，并给了我些提高写作的建议。</p><p>这让我赚到了第一笔稿费，当我提出用稿费感谢他时，他回复说你以后也帮助别人就好了。</p><p>最近我写文章更多了，收到一些积极的反馈，有的人也想开始写作，咨询我如何持续写作，希望我这篇文章也能帮助到这些朋友。</p><h2 id="为何而写"><a href="#为何而写" class="headerlink" title="为何而写"></a>为何而写</h2><p>大部分人高中毕业之后就再也没有尝试过写文章，没几个人天生喜欢写作，应试作文是很多人上学时所恐惧的事。</p><p>写作当然有很多实际的好处，比如赚钱，卖货，建立个人品牌等。Basecamp 的创始人 Jason Fried 曾经写到，如果你在一堆差不多的候选人中不知道选谁，那就选写作好的那个人；现在网络上也充斥着各种写作培训的广告，可见写作算是个稀缺技能。</p><p>我从 2010 年开始写博客，一直是想起来就写点，大多是随手记录技术心得，我觉得在互联网上有个自留地就很好。 </p><p>直到 2019 我才开始学着如何写好，因为我想搞个长期副业。我看到了一些人的分享和经历，他们说写作改变了自己的人生，会让人更丰富，比如 <a href="https://nik.art/why/">Why I Do What I Do</a> ，所以我也开始尝试英文写作。</p><p>为了赚钱去学习写作也挺好，起码有个目标和动力。<strong>但如果赚钱是唯一目标时，结果往往容易失望和放弃，因为这是一个投入周期如此漫长的事，短期上看也是投入产出比非常低的事，这条路上赚钱往往是副产物</strong>。</p><p>通过更密集的写作，我倒没赚多少钱，但得到了一些成长和乐趣，回想起来也是我当时解决焦虑的一个办法。现在要问我为什么写作，我认为有以下几点：</p><p><strong>我们常说写作即思考，并不是写作让人更丰富，而是思考让人更丰富</strong>。即使一个看似简单的主题，写起来之后发现好像还没想清楚，想写得好也得思考得深入和透彻。</p><p>每写完一个主题，意味着我对这个主题完成了阶段性的思考，分享之后会有畅快感，技术、非技术文章写完后都有这样的感受，我为了写而进行思考和总结，写完之后理解就更为深入了。</p><p>另一个原因是社交，年纪越大，家庭、工作所占时间更多，通常除去同事我们很难结交到更多人，这也是为什么人的年纪越大越容易孤独。</p><p>而写作是高质量社交，是和这个世界产生更多连接的方式。文字是行走的名片，读者和作者之间虽然未曾谋面，偶尔的交流就足够，通过公开写作很容易结识到兴趣相同的人。</p><p><strong>写作和分享是有乐趣的，能对抗生活中的焦虑和无聊</strong>，有闲暇安静下来写些东西分享出去，大概是最好的精神生活了。</p><p>总之，我认为写作是个长期有价值的事，所以我会继续写。</p><h2 id="写些什么"><a href="#写些什么" class="headerlink" title="写些什么"></a>写些什么</h2><p>不要怕写出来的东西太简单而被人嘲笑，不要怕没人关注，恐惧是糟糕作品的根源。刚开始就当写作是记录自己的学习和心得，是 <a href="https://www.swyx.io/learn-in-public/">Learn In Public</a> 的最直接方式。</p><p>作为技术人员，我们通常最容易开始写的就是技术。</p><p>有的人会建议只写某个细分领域，这是个好办法，也有利于品牌建设，比如 <a href="https://draveness.me/golang-book-release">Go 语言设计与实现</a> 这本书就是由一些列博文组成的，类似的还有<a href="https://www.zlovezl.cn/articles/my-book-releases/">用 Python 编程 13 年后，我把经验写成了 400 页的书</a> 。如果以后找到有持续热情的主题，我也会这样试试。</p><p>我最近喜欢写一些非技术类的主题，比如个人成长，理念，经验分享等。我曾是个技术宅，我的技术兴趣广泛， 30 岁以后我逐渐觉得技术不是最重要的，技术是工具，职位只是人生中的一个角色，而人的观念、思维、视野、家庭、健康、甚至运气等决定人生上限和幸福与否。既然有相关的思考我就会写一些相关的文章。</p><p>所以，刚开始写作就随着自己的兴趣和热情。如果还没找到特定的主题，就从轻分享开始，像我的周刊那样就写写最近看到什么好内容、我的想法是什么。这类文章看似简单，要写好也不容易，可以通过这类文章锻炼起来。</p><h2 id="如何持久"><a href="#如何持久" class="headerlink" title="如何持久"></a>如何持久</h2><p>写作固然有益，但是很多人坚持不到发现写作益处的阶段，尝试写几篇，没有什么反馈和收获，而后不了了之。</p><p>不得不说刚开始确实比较难熬。作为普通人我们只能多读多写，不断练习，<strong>写了一定数量的文章后才会获得那种乐趣</strong>。我在写了二十多篇英文长篇后才慢慢体会到心流状态。</p><p>那如何才能坚持写下去？</p><p>可以适当地给自己定一些计划，比如我今年一月份没有上班，我给自己定的目标非常大，每天一篇，最终我完成 3/4 目标，这比没有计划要好了很多。</p><p>如果你给自己定排期，自然会有一些输出的压力。应对这个压力的办法是超前一些，我一直有一些文章在同时写，预计这周发的上周基本写好了，这样留有空间就能从容应对。</p><p><strong>另外重要的是反馈，因为如果你写的东西没有任何反馈，自然就难以坚持</strong>。</p><p>反馈的另一个好处是获得写作主题，比如这篇文章就是来自读者的问题，虽然我觉得自己并未在写作上取得好的成就，但有人问也就意味着我的经验也许能给他人启发。这样就犹如一个正向反馈的轮子，转动起来之后才不容易停下来。</p><p>数据可以用来追踪结果，比如阅读量、订阅数等，这些都可以用来量化自己。但一直盯着数据容易陷入自我怀疑，为什么这篇阅读量不好，为什么关注的人少。看数据要把周期拉长，比如一个月左右回顾一次，不和别人比较，因为每个人的节奏和风格都不同，比较会带来压力。</p><p>要持续写作必须培养出习惯，得有持续输入。<strong>阅读、思考、听播客都是输入，有输入输出的正向循环后才会有习惯</strong>。</p><p>有了习惯后，写的过程无非是把平时所想记录了下来。我觉得并没有花太多时间，思考即写作，而想的过程很多是在思绪乱飞的空余时间。</p><h2 id="写作技巧"><a href="#写作技巧" class="headerlink" title="写作技巧"></a>写作技巧</h2><p>没几个人天生写得好，要写好需要刻意练习。虽然我说自己写了 12 年，但是 2019 年之前我没有认真琢磨过如何写出好文章，我所写的无非是随手记录而已。</p><p>2019 年开始，我写了接近两年的英文技术类文章，有的被人翻译为中文，比如这篇 <a href="https://www.infoq.cn/article/8stbpdw9m9xvgvc2evip">学会所有的编程语言</a> ，我看后觉得如果直接写中文我不一定写得这么细致。再看我以前的博文发现有很多地方可以提高，在写作这方面我这两年的成长超过之前十年。</p><p>究其原因，我认为是学写英文的时候我写得很慢、很细，结果这样摸索了一段时间后更有韧性了，这是刻意练习的结果。</p><blockquote><p>最基本的，是要有一次写一个词的耐心，直至达到所需的长度。太多人缺乏这种耐心了。一旦你习惯了，写起来就会毫无困难</p><p> – 黑泽明</p></blockquote><p>提高的另一个原因是我从 Medium 上看了很多文章，学习文章排版和段落逻辑。</p><p>纯技术类的文章相对好写，因为内容和范围都在那里，我们只管写清楚就好。当然我们看到很多技术类文章质量不够好，说明主动琢磨过技术写作的人不多。我推荐看看 <a href="https://developers.google.com/tech-writing/overview">Technical Writing  </a> ，陈皓翻译过一个中文版本 <a href="https://github.com/chenyukang/share/tree/main/refs">Google 技术写作</a> ，中英文写作有很多共同点，好的观点，通顺的逻辑都是相通的。</p><p>非技术写作更难一些，因为自由度太高，比如讲好一个故事，讲明白一个道理，<strong>我认为最有用的写作技巧是诚实和自然</strong>。</p><p>我曾不够自信，因为我不会使用丰富华丽的修饰，也没有文彩，文章读起来没有快感，犹如白开水。</p><p>我向朋友请教如何提高文彩，朋友说你写的不是小说，大部分是干货而已，直白点就很好。</p><p>确实如此，那些我印象深刻的文章大多是对我有所启发，而不是阅读快感。<strong>好的故事和观点、真诚表达、简洁的格式，组合起来其实就能超过很多人</strong>。斯蒂芬·金在<a href="https://book.douban.com/subject/3888123/">《写作这回事》</a>中写道：</p><blockquote><p>简洁是写作风格的第一要素。尽量简洁，少用副词修饰。</p><p>不要卖弄，不要自我陶醉，最重要的是准确描述一个故事。</p></blockquote><p><strong>公开写作需要在一定程度上保持同理心和读者视角，不能完全自嗨，但也不能完全丢掉自我</strong>。</p><p>有段时间我经常琢磨 SEO 技巧，怎样选择关键词，怎么找热门主题，如何才能让文章排名更高 —— 我犹如一个生产同质内容的机器，这样就没了乐趣。</p><p>后来看到 flaviocopes 的作者写到 SEO trick number 1: do not worry about SEO，<a href="https://flaviocopes.com/blog-seo/">write things that help people</a> ，我深受启发，如果完全为了钱和流量而写，最终就会因为没趣而无法长久地写下去，写出来的也不够好。所以，<strong>更好的心态是把写作当成倾诉和分享</strong>。</p><p>写完后自己读读，看是否顺口，逻辑上是否有问题，哪些地方不对再改改。</p><p>对于特别想写好的主题，我会长时间修改。也许我今天写了主要内容，在接下来的半个月里，我的思绪可能还会在这个主题上，也许散步、看相关资料时有了新的想法，再去修改这篇文章，文章在发布之前经过了断断续续的多次修改。</p><blockquote><p> 如果你写的文字，你自己看都像吃了黄连一样苦憋的表情，那就不要指望别人看的时候能够津津有味。 </p><p> – 村上春树</p></blockquote><h2 id="获得读者"><a href="#获得读者" class="headerlink" title="获得读者"></a>获得读者</h2><p>人们经常说内容为王，你只管写，写得好了自然就会有人看。</p><p>这话放到以前是对的，在如今资讯爆炸的年代，能静下来好好读完一篇文章的人也越来越少了，不推广就根本没人关注到你。</p><p>为了获得反馈，我们就需要稍微做一些自我推广。很多人讨厌推广，这是人之常情，之前我也害羞推广自己。我最近倒发现把自己写的发给朋友看看，或是去自己平时晃悠的社区推广一下也没什么，迈过心里那道坎就无所谓了。</p><p>如果要推广自己的文章，那就推自己非常满意的内容，人们通常不会反感被推销高质量或是对自己有用的东西。</p><p>不用每篇文章都很高质量，但是得有一小部分好内容让人记住，建立起信任感。有了一些固定读者就会有驱动力，最难的是初期滚雪球阶段。</p><p>所谓高质量通常有两种：</p><ul><li><p><em>阐述了一个很好的理念和想法，或者分享了一个很好的故事</em><br>比如我经常提 Learn In Public，我自然会把流量推到最初阐述这个理念的站点。</p></li><li><p><em>很好、很全面地给出了某个 Evergreen 主题的总结和答案</em><br>Evergreen 译为<strong>常绿</strong>，就是不会随着时间流失而失去热度的主题，例如 coolshell 的<a href="https://coolshell.cn/articles/21672.html">我做系统架构的一些原则</a> ，这种是算是常绿主题；而 2022 年十大科技新闻，Rust 社区闹分离了，这些就不算是常绿，因为过一段时间大家就不关注了。</p></li></ul><p>这叫作<a href="https://www.blogmarketingacademy.com/redwood-strategy/">红杉策略</a>，红杉树可以生长上千年，可以长到一百多米高，引人注目，犹如我们说的常绿内容。根据二八原则，少部分高质量的内容会不断带来流量。创作出少部分高质量的内容，不断保持更新，不断地推广，形成口碑效应 。</p><p>如果是写英文，我们还能期望能通过 Google 带来有些自然流量，如果是中文就不要期望百度能带来多少自然流量。</p><p>初期主要靠自己的主动推广和口碑，对于技术类文章我没发现特别好的中文社区，如果想自我推广在 v2ex、知乎试试，也可以向大号投搞，比如我就往 ruanyifeng 的周刊投过稿获得了我新域名的第一波较大的流量。</p><p>每个人获取流量的方式都不同，而且也存在偶然因素，有的人可能写了一两篇爆款就火了，有的人可能是因为被某个大 V 推了一下就成了。但我认为比较靠谱的方式就是，找到你的目标读者可能出现的地方，然后创造出好内容。</p><h2 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h2><p>如果是想短期试试手，不想折腾工具，那就选择现有的平台：</p><ul><li>中文：知乎，InfoQ，掘金</li><li>英文：Medium ，hashnode ，dev. to </li></ul><p>虽然平台各有各的问题，到好处在于不必折腾，自带流量。</p><p>如果要长期写下去那就不要依赖平台，我的博客经历过好几次平台倒闭，没有建立起固定读者。</p><p>内容最好是可以完全自己离线管理，本地编辑器撰写效率最好，文本和图片都通过 Git 管理版本，数据存储在 Github，参考 <a href="https://laike9m.com/blog/people-die-but-long-live-github,122/">People Die, but Long Live GitHub</a> 。域名用 Github Pages 之类的就行，Github Pages 也可以绑定自己的域名。</p><p>编辑工具我推荐使用带有双链支持的软件，比如 Obsidian、Logseq。我使用网页标注工具 Hypothesis 来把自己看过的东西同步到 Obsidian，写完后使用一些小脚本来自动化发布内容，具体参考：<a href="https://catcoding.me/p/obsidian-for-programmer/">我的 Obsidian 使用经验</a> 和 <a href="https://catcoding.me/p/publish-to-wechat/">如何无痛苦更新公众号</a> 。</p><p>国外大家喜欢使用 newsletter，国内习惯用公众号，公众号这种关注关系很弱，还有可能被封掉一下子就失去了读者，通过 RSS 也算是维持比较稳定的订阅关系。如果用我的自动同步的办法就把个人站点和公众号兼容了。</p><p>英文写作我还是推荐 Medium ，即使现在没那么火了，但是有流量还有认真的编辑和读者。中文技术社区我看得不多，但我看一些人在 CSDN 之类的地方写得风生水起，关键还是需要持续输出。</p><hr><p>以上是我的一些经验之谈，如果你能得到一些启发或有了写作的想法，那就很好。我相信认真写作一段时间会让你体会到丰富。</p><p>欢迎点赞、分享这篇文章，也欢迎和我交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多年以后，如果我还沉浸在写作的乐趣中，一定还记得 2019 年那位给了我鼓励和帮助的陌生读者，他帮我完整地润色了一篇长文，并给了我些提高写作的建议。&lt;/p&gt;
&lt;p&gt;这让我赚到了第一笔稿费，当我提出用稿费感谢他时，他回复说你以后也帮助别人就好了。&lt;/p&gt;
&lt;p&gt;最近我写文章更
      
    
    </summary>
    
    
      <category term="写作" scheme="http://catcoding.me/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="副业" scheme="http://catcoding.me/tags/%E5%89%AF%E4%B8%9A/"/>
    
  </entry>
  
</feed>
