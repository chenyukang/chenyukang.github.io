<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cyukang.com/"/>
  <updated>2019-07-27T04:25:31.483Z</updated>
  <id>http://cyukang.com/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>满足感源自细节</title>
    <link href="http://cyukang.com/2019/07/27/details_matter.html"/>
    <id>http://cyukang.com/2019/07/27/details_matter.html</id>
    <published>2019-07-27T04:25:31.000Z</published>
    <updated>2019-07-27T04:25:31.483Z</updated>
    
    <content type="html"><![CDATA[<p>最近自我感觉生活质量提高了不少，并不是突然撞大运发大财了，总结下来居然都是一些小细节，奇怪正是这些小细节每次都会让我会心一笑。</p>
<p><img src="/images/2019_07_26.org_20190727_085906.png" width="70%" hegiht="70%" align="center"></p>
<h4 id="org-mode"><a href="#org-mode" class="headerlink" title="org-mode"></a>org-mode</h4><p>作为一个近十二年的 Emacs 用户，最近开始使用 org-mode 了。之前一直偶尔看到说什么单独为了 org-mode 而花时间熟悉 Emacs 也是值得的，不过我一直没认真看，因为我认为在 Emacs下不太适合大量编辑中文，快捷键太多在中文输入的过程中会有一些影响。</p>
<p>最近因为杂事比较多，我特别想要一个结合了日程管理和文档管理的软件。之前用过 Bear，这款软件的好处在于其编辑支持得特别好，但是 Bear 没有日程管理。后来又重新用回 EverNote，这东西的文字编辑支持有点弱，日程管理就是个最基本的清单。还有一些代码嵌入方面的问题，拷贝进去支持再拷贝出来居然其中嵌了部分中文符号。</p>
<p>最后我终于花了点时间来看看这个传说中的 org-mode 到底神奇在何处。结果真的符合了好香定律，我怎么不一开始用 Emacs 就着手用这呢，后悔万千！</p>
<p>其实不管日程管理也好，日志、技术笔记等也好，本质上都是文字。org-mode 的日程和笔记都是存储的最原始的文本格式，而 org-mode 的编辑模式类似Bear，写起来非常容易上手。和 Markdown 类似属于「易读易写」的轻量级标签格式。</p>
<p>日程管理也有一些记录时间、统计时间，培养习惯的打卡类日程计划。配合 org-agenda 的各种视图，org-capture 的可定制的模板，用起来真是简洁而又迅速。自己再定制一些函数和脚本，实现从剪切板拷贝图片，使用修改过的 <a href="https://github.com/chenyukang/org-ruby/tree/block-version" target="_blank" rel="external">org-ruby</a> 自动从 org 转换为 Markdown，反正只要是文本其可塑性就非常强。</p>
<p><img src="/images/2019_07_26.org_20190727_003933.png" width="70%" hegiht="70%" align="center"></p>
<p>这才是对程序员最友好、最强大的文档和日程管理工具，<strong>其满足点在于『可定制』</strong>。</p>
<h4 id="全屏中小红点"><a href="#全屏中小红点" class="headerlink" title="全屏中小红点"></a>全屏中小红点</h4><p>当我开始大量使用 org-mode 记录之后，就不可避免地需要在全屏的 Emacs 下输入中文。而这经常会被打乱，总结一下发现其实是因为全屏状态下我经常会不知道目前是否启用了中文输入法。全屏模式下看不到输入法的任何图标，Baidu 的 Mac 输入法这个浮动状态栏不会在 Emacs 全屏的模式下显示，而且那个辐条本身看起来也太占空间了。在没有图标的情况下只有靠 Shift 或者 Ctrl blank 瞎切换了，非常让人厌烦。</p>
<p>这个困扰很久的问题最近也终于解决了， 这个 <a href="https://github.com/tekezo/ShowyEdge" target="_blank" rel="external">ShowEdge</a> 工具可以根据不同的输入法，配置不同的颜色，而且在任何全屏状态都根据输入法显示颜色。我的屏幕顶部就配置了这么一个小红点：</p>
<p><img src="/images/CAPTURE-2019_07_26.org_20190727_000238.png" alt="file:img/CAPTURE-2019_07_26.org_20190727_000238.png"></p>
<p>从此输入中文的体验大幅提高！虽然这是非常细节的一个地方，但是当你想到折磨自己的问题，其他人也关注到了，并且用了极其符合自己使用习惯的开源软件解决了，顿时觉得世界真美好！</p>
<p><strong>这里的满足点在于『可控性』</strong>。</p>
<h4 id="黑暗中的黄色光"><a href="#黑暗中的黄色光" class="headerlink" title="黑暗中的黄色光"></a>黑暗中的黄色光</h4><p>这东西犹如黑暗中的萤火虫，让人温暖，哈哈，其实就是小米的一款感应夜灯。我对小米的这种小的智能家电比较感兴趣，比如小爱同学也不错。这款夜灯的好处在于自动感应，进洗手间自己就亮，我每次都是比较晚才去洗漱刷牙，这灯不太亮也不太暗，而且可以根据声音、移动、和自然光亮度自动开关。其实功能很简单，符合软件设计中的哲学：专注唯一功能，但是功能做到极致。</p>
<p><img src="/images/2019_07_26.org_20190727_004316.png" width="350" hegiht="400" align="center"></p>
<p><strong>这应该是简单地满足了『确定性』的心理需求</strong>，为什么像语音助手这类东西虽然看起来比较炫酷，但用的人并不多，因为语音识别在日常使用过程中还是会存在各种干扰，最终造成使用过程中存在一些不确定性，从而影响了根本的使用体验。</p>
<p>Entered on [2019-07-26 五 23:31]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近自我感觉生活质量提高了不少，并不是突然撞大运发大财了，总结下来居然都是一些小细节，奇怪正是这些小细节每次都会让我会心一笑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_07_26.org_20190727_085906.png&quot; width=&quot;70%&quot; 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>保存 kmacro </title>
    <link href="http://cyukang.com/2019/06/23/2019-06-23-random-notes.html"/>
    <id>http://cyukang.com/2019/06/23/2019-06-23-random-notes.html</id>
    <published>2019-06-23T15:48:42.000Z</published>
    <updated>2019-06-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>宏是很强大的编辑方法，如果要长久保存一些宏可以使用下面的办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">M-x start-kbd-macro</div></pre></td></tr></table></figure>
<p>开始记录宏，通常快捷键为”C-x (“, 结束的快捷键为 “C-x )”。</p>
<p> 然后使用命令: </p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">M-x kmacro-name-last-macro</div></pre></td></tr></table></figure>
<p>  可以把这条宏给命名，如果要保存这个宏以便日后使用，需要打开 init.el 继续使用命令： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">M-x insert-kbd-macro</div></pre></td></tr></table></figure>
<p>选中命名的宏，这样就在 init.el 里面插入了刚才的宏，这个名字也就可以当作日常命令使用了。</p>
<p>例如我新建一个宏，作用是查找测试文件中的 “#[ignore]”，并删除掉那行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(fset &apos;rust-ignore</div><div class="line">      (lambda (&amp;optional arg) &quot;Keyboard macro.&quot; (interactive &quot;p&quot;)</div><div class="line">        (kmacro-exec-ring-item</div><div class="line">         (quote ([12 115 101 97 114 99 104 return 35 91 105 103 110 111 114 101 return 1 11 11 14] 0 &quot;%d&quot;)) arg)))</div></pre></td></tr></table></figure>
<p>如果要重复执行，则需要运行： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">C-x z</div></pre></td></tr></table></figure>
<p>当然后面可以连续按 z z z …. ， 执行多遍。</p>
<p> 参考: <a href="https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function" target="_blank" rel="external">https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;宏是很强大的编辑方法，如果要长久保存一些宏可以使用下面的办法：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;M-x start-kbd-macr
    
    </summary>
    
    
      <category term="Notes" scheme="http://cyukang.com/tags/Notes/"/>
    
      <category term="Emacs" scheme="http://cyukang.com/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>2019，愿你也健康</title>
    <link href="http://cyukang.com/2019/01/23/2019-wishes.html"/>
    <id>http://cyukang.com/2019/01/23/2019-wishes.html</id>
    <published>2019-01-23T15:48:42.000Z</published>
    <updated>2019-01-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h4><p>最近在坚持养成每天尽量花一小时锻炼的习惯，因为我想在 2019 年有个更健康、有活力的身体。</p>
<p>随着年纪的增长，身体的一些反馈还是如实地告诉自己在变老。衰老就是能力不断地退化、消失。之前打球能蹦蹦跳跳的，现在多跑跑就会喘气；之前精力更好、更喜欢到处走动，现在更倾向于静静休息。去年有的时候身体感觉不太好，有段时间特别疲劳，甚至也体验过一段低迷的至暗时刻。大概是因为生活不规律，而且基本没有怎么锻炼，体重也不断上升。因为在 2017 年初打篮球的时候把膝盖伤了，后来也不能激烈打球了。现在比较适合自己的运动方式就是跑步、游泳、散步之类的。</p>
<hr>
<h4 id="人总是会忘掉这件事"><a href="#人总是会忘掉这件事" class="headerlink" title="人总是会忘掉这件事"></a>人总是会忘掉这件事</h4><p>当然锻炼养生也不能抵抗衰老，这是个自然过程，锻炼至少能有助于健康。健康是所有幸福的最大基础，比什么都重要，俗话说『宁做健康的乞丐，也比做病恹恹的国王快活得多』。人更无法逃避的是死亡，这是所有生物的最终归宿和命运。只是人总会渐渐忘记自己会死，梁文道说的一个故事：</p>
<blockquote>
<p>很多年前，一位德国摄影师跟一个记者合作的拍摄计划，很有意思。那个摄影师去很多的临终病房，拍摄一些快要死去的人，趁他们还在世的时候，拍下他们的遗照。然后他们刚刚离开，合上眼睛的时候，又为他们再拍一张照片，两张照片放在同一版上，前面则是文字记者做的采访。</p>
<p>在这一系列的采访跟摄影当中，其中一个已死的老太太，在她的采访里面说的一句话，他一辈子都不会忘记。她说什么呢？她跟文字记者说，“你看，你看”，就指着病房玻璃外面楼下对面马路的一个超级市场，她指着那个超级市场跟摄影师和记者说：“<strong>你看那里头的人们，天天进进出出买东西，买面包、买肉、买卫生纸，你看他们的样子，他们好像从来不觉得自己会死。</strong>”</p>
</blockquote>
<h4 id="读《最后的告别》"><a href="#读《最后的告别》" class="headerlink" title="读《最后的告别》"></a>读《最后的告别》</h4><p>这本书很多人都推荐过，我最近刚好也看了一遍。这里面谈了一些人在最终衰老、告别时必须面对的问题和思考，其中也有一些作者所经历的老人故事，还有自己的父亲最后的抗争。其中有一个故事印象深刻，看完后我又查了查还真有这么个人和事。</p>
<blockquote>
<p>1980年3月，当附近火山已经开始冒水汽、隆隆作响时，这位83岁的老人却仍然拒绝撤离他在华盛顿奥林匹亚市附近圣海伦山脚的家。他是第一次世界大战时期的飞行员、禁酒时期的私酒制造者，已经在灵湖的这所房子里住了半个多世纪了。5年前，他成了鳏夫。所以，当时，在山脚这处300多亩的地盘上，只住着他和他的16只猫。三年前，他在屋顶铲雪的时候掉下来，摔断了腿。医生说他是个“该死的傻瓜”，在这样的年龄还爬到房顶去做事。<br>　　<br>　　“该死！”他给医生骂回去，“<strong>我都 80岁了！我有权做决定，有权做我想做的事。</strong>”</p>
<p>由于受到火山喷发的威胁，官方要求附近居民全部撤离，但是杜鲁门哪儿都不去。火山闷烧了两个多月，官方把撤离区域扩大到火山周围16千米。杜鲁门固执地不肯离开。</p>
<p>　“如果这个地方要毁灭，那我想跟它同归于尽，”他说，“反正如果失去它，我也会在一周之内结果我自己。”他直率、不和悦的讲话方式吸引了记者。他说起话来滔滔不绝，头戴一顶绿色的约翰·迪尔棒球帽，手拿一大高脚杯波旁威士忌和可乐。当地警察考虑为了他好而逮捕他，但是，由于他的年龄以及他们必须得承受的负面新闻，只好作罢。他们提出但凡有机会就带他离开，但他坚决予以拒绝。他告诉一位朋友：“<strong>如果我明天死去，我也已经度过了愉快的一生。我能做的事都做了，想做的事都做了。</strong>”<br>　　<br>　　1980年5月18日早上8点40分，火山终于爆发了，其威力相当于一颗原子弹。巨量的岩浆流吞没了整个湖，埋葬了杜鲁门、他的猫和他的家。事后，他成了偶像——一个老头留在自己家里碰运气，在这种可能性似乎已经消失的年代，他按照自己的方式生活。</p>
<p><img src="/images/1920px-St_Helens_before_1980_eruption_horizon_fixed.jpg" alt="1920px-St_Helens_before_1980_eruption_horizon_fixed"></p>
</blockquote>
<p>相对书中的很多老人来说，这位老人的选择充满了勇气，他以决绝的选择来面对衰老和死亡，并没有经受医院的无尽折磨。年轻人看起来这算是是自杀吧，加缪认为自杀是唯一严肃的哲学问题，看来老人对此已经有了答案。能有多少人老了能还以自己喜欢的生活方式活着，并在最终告别的时候心里都是满足：我已经愉快地度过了一生。</p>
<p>孔子说『未知生<em>，</em>焉知死』，反过来如果没有认真思考过死这件事，人又能真的知道怎么活。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>最近大环境不太好，很多人都在纠结于今年能拿到多少年终，好多事情并不是个人所能决定，自己能最能把握的是自己的身体，珍惜生命、保护好自己，以免年纪轻轻落得一身病，年纪大了用钱换命。</p>
<p>最后推荐一个纪录片：《人世间》。每天都有无数的人在和疾病、死亡抗争，活着对很多人来说其实真不是件容易的事。</p>
<p>日子中很多艰辛和苦难，和生死比起来那就不是事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;坚持&quot;&gt;&lt;a href=&quot;#坚持&quot; class=&quot;headerlink&quot; title=&quot;坚持&quot;&gt;&lt;/a&gt;坚持&lt;/h4&gt;&lt;p&gt;最近在坚持养成每天尽量花一小时锻炼的习惯，因为我想在 2019 年有个更健康、有活力的身体。&lt;/p&gt;
&lt;p&gt;随着年纪的增长，身体的一些反馈还
    
    </summary>
    
    
      <category term="Notes" scheme="http://cyukang.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Rust 的 dbg! 宏</title>
    <link href="http://cyukang.com/2019/01/18/rust-dbg.html"/>
    <id>http://cyukang.com/2019/01/18/rust-dbg.html</id>
    <published>2019-01-17T16:23:24.000Z</published>
    <updated>2019-01-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在群里看到有人讨论 dbg! 宏已经在 Nightly 可以使用了，最近发布的 stable 版本 1.32.0 也可以使用了。 翻看了一下并玩了玩，这个简单的宏确实是调试好帮手，特别是适合我这样的喜欢打印调试的开发者。这个提议从 2017 年 10 月开始，从 <a href="https://github.com/rust-lang/rfcs/pull/2173" target="_blank" rel="external">https://github.com/rust-lang/rfcs/pull/2173</a> 可以看到，为了增加这个宏很多贡献者经过了无数次的讨论和回复。真是太佩服 Rust Team 的开发者，付出了这么多时间来增加这个看似很小又实用的功能。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>先看看这个调试宏是怎么使用的，目前使用这个宏需要切换到 Nightly 版本或者最新的稳定版，已经安装了 rustup 的话就很简单了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">rustup default nightly</div><div class="line">rustup update</div></pre></td></tr></table></figure>
<p>然后很简单就是把一个表达式当作参数传入:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">factorial</span></span>(n: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</div><div class="line">     <span class="keyword">if</span> dbg!(n &lt;= <span class="number">1</span>) &#123;</div><div class="line">         dbg!(<span class="number">1</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">         dbg!(n * factorial(n - <span class="number">1</span>))</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    dbg!(factorial(<span class="number">5</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">[src/main.rs:4] n &lt;= 1 = false</div><div class="line">[src/main.rs:4] n &lt;= 1 = false</div><div class="line">[src/main.rs:4] n &lt;= 1 = false</div><div class="line">[src/main.rs:4] n &lt;= 1 = false</div><div class="line">[src/main.rs:4] n &lt;= 1 = true</div><div class="line">[src/main.rs:5] 1 = 1</div><div class="line">[src/main.rs:7] n * factorial(n - 1) = 2</div><div class="line">[src/main.rs:7] n * factorial(n - 1) = 6</div><div class="line">[src/main.rs:7] n * factorial(n - 1) = 24</div><div class="line">[src/main.rs:7] n * factorial(n - 1) = 120</div><div class="line">[src/main.rs:12] factorial(5) = 120</div></pre></td></tr></table></figure>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>原理当然也就是把表达式和位置打印出来，但是这里有个技巧，在宏里面使用 match，这是为了避免参数被调用多次，因为宏在编译之前会被展开。Rust 的宏比较复杂，也不可避免会有些 hacky，对于喜欢爱折腾的程序员还是有吸引力。再看看这个宏是怎么实现的，代码很少。：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line"><span class="built_in">macro_rules!</span> dbg &#123;</div><div class="line">    ($val:expr) =&gt; &#123;</div><div class="line">        <span class="keyword">match</span> $val &#123;</div><div class="line">            tmp =&gt; &#123;</div><div class="line">                eprintln!(<span class="string">"[&#123;&#125;:&#123;&#125;] &#123;&#125; = &#123;:#?&#125;"</span>,</div><div class="line">                          <span class="built_in">file!</span>(), <span class="built_in">line!</span>(), <span class="built_in">stringify!</span>($val), &amp;tmp);</div><div class="line">                tmp</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到目前这个实现是只支持一个参数的，如果传入的参数类型没有实现 Copy Trait，可以传入引用。另外如果想同时打印多个参数，可以使用类似这样的做法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><div class="line">dbg!((exp1, exp2))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在群里看到有人讨论 dbg! 宏已经在 Nightly 可以使用了，最近发布的 stable 版本 1.32.0 也可以使用了。 翻看了一下并玩了玩，这个简单的宏确实是调试好帮手，特别是适合我这样的喜欢打印调试的开发者。这个提议从 2017 年 10 月开始，从 &lt;a
    
    </summary>
    
    
      <category term="Rust" scheme="http://cyukang.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>《见识》阅读笔记</title>
    <link href="http://cyukang.com/2019/01/10/book-review-wujun.html"/>
    <id>http://cyukang.com/2019/01/10/book-review-wujun.html</id>
    <published>2019-01-10T15:22:40.000Z</published>
    <updated>2019-01-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>到年底小组内还有多余的预算，于是大家都在网上选书。看到吴军出了两本新书，出于对作者的信任就直接下单了。上个周末就花了些时间很快地看完了两本。内容稍微有些重合，主要是有的例子会拿来阐述多个道理。所以两本连着看会有些作者凑书的感受。当然两本都还是不错的，读完《态度》对于我这个新手爸爸来说也是收获不少。个人更推荐《见识》这本书。</p>
<p>《见识》更多关注个人成长、看待问题的视角、工作职场中的一些经验。其中几个主题：</p>
<h3 id="人生是一条河"><a href="#人生是一条河" class="headerlink" title="人生是一条河"></a>人生是一条河</h3><p>每个人都希望自己这条河能够更宽一点、更深一点、更长一点。只有给予才能带来幸福感。</p>
<p>认识到生命是有限的，应该挑重要的事做，向死而生。</p>
<h3 id="人生需要做减法"><a href="#人生需要做减法" class="headerlink" title="人生需要做减法"></a>人生需要做减法</h3><p>不做选择的幸福，从另外一个角度去解释为什么印度人在硅谷更容易成功。我觉得是有一定道理的，印度人因为名族的阶级观念，在生活工作中少了一些选择，却能一直在某个领域坚持数十年。第一份工作的过程中，接触了不少印度人。其中一位从印度到硅谷，一直都是在一个公司工作了 14 年左右，我问他为什么不跳槽，他倒觉得无所谓，安家乐业地每天过得很稳。少了选择就不容易思前想后，一门子扎进去了。在工作上，很多人都不能坚持一直耕耘于某个特定的领域，坚持下来的就成了。</p>
<p>做人与作诗：这章讲的道理类似于『出世』与『入世』，让我想起《月亮和六便士》里的画家。</p>
<p>要会做减法，为“做重要的事”服务，同时认清什么是重要的事。</p>
<h3 id="西瓜与芝麻"><a href="#西瓜与芝麻" class="headerlink" title="西瓜与芝麻"></a>西瓜与芝麻</h3><p>想起骚年的时候总是花时间去找些破解软件，舍不得一点钱买些软件或者工具，渐渐地意识到了这就是为了芝麻丢西瓜的事。类似的还有很多，现在则改变了认知，能付费节约时间则付费，能花钱买到更好的则花钱。</p>
<h3 id="生也有涯-知也无涯"><a href="#生也有涯-知也无涯" class="headerlink" title="生也有涯 知也无涯"></a>生也有涯 知也无涯</h3><p>正因为如此，生活、学习、工作中需要聚焦，别分散精力。人能在某一段时间内做好一件事，并且做得比其他人好，好到自己觉得不能更好为止。也正是因为『知也无涯』，不要为了自己的未知而焦虑，因为这是再正常不过的了，自己学起来就好，别丢掉好奇心。</p>
<h3 id="我们一定比-18-世纪的人过得幸福么？"><a href="#我们一定比-18-世纪的人过得幸福么？" class="headerlink" title="我们一定比 18 世纪的人过得幸福么？"></a>我们一定比 18 世纪的人过得幸福么？</h3><p>显然，当代人并不幸福，特别是我们这些年轻的一代。物质上倒谈不上匮乏，而是没有自己的时间，然后则是人到中年必不可免的生活压力和焦虑。EB的说唱里有段歌词『所有人都忙着想要更多的东西 所以得到之后就没有精力去珍惜 情歌越来越多 真情却越来越少 巧克力的保质期越来越长 爱情的保质期却越来越短 生活变得越来越丰富多彩 于是越来越多的人变得分不清黑白』。</p>
<h3 id="我们与天才差多远"><a href="#我们与天才差多远" class="headerlink" title="我们与天才差多远"></a>我们与天才差多远</h3><p>我们绝大部分人成长过程中，迟早会意识到自己不过是芸芸众生中的普通人。硅谷中，我认为有一种气氛特别好，就是对聪明人的崇敬。之前的老板应该已经算是又聪明又勤奋的那种，谈话中总是会说起自己碰见过的聪明人，聪明到如何程度，以及一些小故事。有的生理上的差异是解释不清的，比如有的人就是善于计算，有的人精于细节。不过天才的见识、勇气、或者方法上有的是值得学习的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到年底小组内还有多余的预算，于是大家都在网上选书。看到吴军出了两本新书，出于对作者的信任就直接下单了。上个周末就花了些时间很快地看完了两本。内容稍微有些重合，主要是有的例子会拿来阐述多个道理。所以两本连着看会有些作者凑书的感受。当然两本都还是不错的，读完《态度》对于我这个新
    
    </summary>
    
    
      <category term="Books" scheme="http://cyukang.com/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>使用 Markown 编辑公众号方法</title>
    <link href="http://cyukang.com/2019/01/06/wechat-tools.html"/>
    <id>http://cyukang.com/2019/01/06/wechat-tools.html</id>
    <published>2019-01-06T15:48:39.000Z</published>
    <updated>2019-01-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>技术人员很多都喜欢使用 Markdown 格式来编辑文档，但是公众号后台默认不支持。</p>
<p>所以关于工具和流程，最近我摸索出来目前最适合自己的一套是：</p>
<p>还是维护之前 Hexo 那套，像代码那样使用 Git 管理，内容会上传到 Github 上。</p>
<p>继续使用 Typora 编辑 Markdown 文件。注意使用图片工具 IPic 来方便地把图片上传到图床上，其实免费的微博图床就足够。然后使用在线的转换工具<a href="http://md.codingpy.com/" target="_blank" rel="external">md.codingpy.com</a>即可很方便地把 Markdown 转成适合公众号的内容，复制粘贴到后台编辑器里。</p>
<p>这样在个人网站和公众号里都会有相同的内容，而且格式之类的都比较统一。</p>
<p>这里再次推荐 Typora: <a href="https://typora.io/" target="_blank" rel="external">https://typora.io/</a> 这个工具，会让人特别有写东西的冲动。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyxb4230duj310u0kmjs7.jpg" alt="image-20190106235957370"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;技术人员很多都喜欢使用 Markdown 格式来编辑文档，但是公众号后台默认不支持。&lt;/p&gt;
&lt;p&gt;所以关于工具和流程，最近我摸索出来目前最适合自己的一套是：&lt;/p&gt;
&lt;p&gt;还是维护之前 Hexo 那套，像代码那样使用 Git 管理，内容会上传到 Github 上。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开始写公众号</title>
    <link href="http://cyukang.com/2019/01/04/try-wechat-blog.html"/>
    <id>http://cyukang.com/2019/01/04/try-wechat-blog.html</id>
    <published>2019-01-04T14:57:24.000Z</published>
    <updated>2019-01-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018 过得很快，对于自己来说有点颓废、也很辛苦。说是颓废因为花了一些时间在游戏上，还有不少焦虑。最近看书，翻到胡适 1932 年一篇《寄语即将毕业的大学生》中写到，人到社会容易丢掉求知的欲望、抛弃学生时代的理想追求，为了防止堕落文中给出三点建议。读来觉得颇有道理，这三点建议放在现在也合适： </p>
<blockquote>
<p>总得时时寻一两个值得研究的问题</p>
<p>总得多发展一点非职业的兴趣</p>
<p>你总得有一点信心</p>
</blockquote>
<p>新的一年想着尝试做些改变，逼着自己再做一些其他尝试，不然生活除了工作和日常，真是过得有些索然无趣了。业余写些东西是很好的积累，从 2006 年左右开始一直都有写博文的习惯，从搜狐、Yo2、WordPress， 一直到后来的  Hexo 托管到 Github 上。个人域名 <a href="http://cyukang.com">http://cyukang.com</a> 用了多年，其中的文章大概也有 140 来篇。在这么多年写博客的过程中收获不少，认识了一些朋友，也锻炼了自己的文字能力。</p>
<p>平台和工具一直在变化，文字只是一种表达的方式，能写出来还是得靠自己平时所想、所做。之前写的技术类的文章偏多，因此一直觉得公众号这种生态圈有些封闭，不利于检索。不过终究是大众的选择，公众号里好的内容也很多。如果要逼着自己写，有些人看、有些互动自然是更好的。不求有多少关注，但愿自己能坚持多写写而已。</p>
<p>关于写什么，我也还不太清楚。在技术方面可能涉猎较多，精通的不算多。总之算得上技术爱好者，还未丢掉这块兴趣。所以这里多是关于工作、技术的一些学习总结、实践等。把技术相关的东西写得通俗易懂绝非易事，希望在这方面能有更多进步。另外我更想拓展自己在其他方面的知识和积累，所以公众号上会写更多读书笔记和思考。『构成我们学习的最大阻碍是已知的东西，而非未知』，局限于技术角度并非好事。</p>
<p>关于公众号名字『递归说』，这是乱想的，刚好在取名的时候想到了而已。听起来比较好念，而且递归真是计算机里一个很简洁、优美的概念，也是解决问题的一种方法，还可以延伸理解为『自我进化』吧。人这一辈子不也像一个递归么，过一年就像过了一个迭代，而且都是有终点的。</p>
<p>先写起来再继续摸索找方向吧，总得对自己有些信心。</p>
<p>扫描关注： </p>
<p><img src="/images/wechat-qr-code.png" alt="wechat-qr"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 过得很快，对于自己来说有点颓废、也很辛苦。说是颓废因为花了一些时间在游戏上，还有不少焦虑。最近看书，翻到胡适 1932 年一篇《寄语即将毕业的大学生》中写到，人到社会容易丢掉求知的欲望、抛弃学生时代的理想追求，为了防止堕落文中给出三点建议。读来觉得颇有道理，这三点
    
    </summary>
    
    
      <category term="WeChat" scheme="http://cyukang.com/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>使用 peco 飞起 zsh</title>
    <link href="http://cyukang.com/2019/01/04/peco-for-zsh.html"/>
    <id>http://cyukang.com/2019/01/04/peco-for-zsh.html</id>
    <published>2019-01-04T14:55:22.000Z</published>
    <updated>2019-01-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="peco"><a href="#peco" class="headerlink" title="peco"></a>peco</h3><p><a href="https://github.com/peco/peco" target="_blank" rel="external">peco</a> 是一个能做交互式 filte 的工具，是 <a href="https://github.com/mooz/percol" target="_blank" rel="external">percol</a> 的 Go 实现。特别适合在 shell 里做一些过滤操作，当然适合做日志方面的过滤。典型的使用方法是：</p>
<p><img src="https://camo.githubusercontent.com/6ed15cca08fd6972d12e67ee1f1fe84caa14744b/687474703a2f2f7065636f2e6769746875622e696f2f696d616765732f7065636f2d64656d6f2d70732e676966" alt="gif"></p>
<h3 id="zsh-配置"><a href="#zsh-配置" class="headerlink" title="zsh 配置"></a>zsh 配置</h3><p>下面这个配置主要增强了 zsh 的 history 补全，以及<code>pwdf</code>可以用来迅速找一个文件，并拷贝其全路径：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><div class="line"><span class="keyword">function</span> exists &#123; which <span class="variable">$1</span> &amp;&gt; /dev/null &#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> exists peco; then</div><div class="line">    <span class="keyword">function</span> peco_select_history() &#123;</div><div class="line">        local tac</div><div class="line">        exists gtac &amp;&amp; tac=<span class="string">"gtac"</span> || &#123; exists tac &amp;&amp; tac=<span class="string">"tac"</span> || &#123; tac=<span class="string">"tail -r"</span> &#125; &#125;</div><div class="line">        BUFFER=$(fc -l -n <span class="number">1</span> | eval <span class="variable">$tac</span> | peco --query <span class="string">"<span class="variable">$LBUFFER</span>"</span> --layout=bottom-up)</div><div class="line">        CURSOR=$<span class="comment">#BUFFER         # move cursor</span></div><div class="line">        zle -R -c               <span class="comment"># refresh</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    zle -N peco_select_history</div><div class="line">    bindkey <span class="string">'^R'</span> peco_select_history</div><div class="line">fi</div><div class="line"></div><div class="line">OS_NAME=`uname`</div><div class="line"><span class="keyword">function</span> pclip() &#123;</div><div class="line">    <span class="keyword">if</span> [ <span class="variable">$OS_NAME</span> = <span class="string">"CYGWIN"</span> ]; then</div><div class="line">	      putclip <span class="string">"$@"</span>;</div><div class="line">    elif [ <span class="variable">$OS_NAME</span> = <span class="string">"Darwin"</span> ]; then</div><div class="line">	      pbcopy <span class="string">"$@"</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">	      <span class="keyword">if</span> [ -x /usr/bin/xsel ]; then</div><div class="line">	          xsel -ib <span class="string">"$@"</span>;</div><div class="line">	      <span class="keyword">else</span></div><div class="line">	          <span class="keyword">if</span> [ -x /usr/bin/xclip ]; then</div><div class="line">		            xclip -selection c <span class="string">"$@"</span>;</div><div class="line">	          <span class="keyword">else</span></div><div class="line">		            echo <span class="string">"Neither xsel or xclip is installed!"</span></div><div class="line">	          fi</div><div class="line">	      fi</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> pwdf() &#123;</div><div class="line">    local current_dir=`pwd`</div><div class="line">    local copied_file=`find <span class="variable">$current_dir</span> -type f -print | peco --layout=bottom-up`</div><div class="line">    echo -n <span class="variable">$copied_file</span> |pclip;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;peco&quot;&gt;&lt;a href=&quot;#peco&quot; class=&quot;headerlink&quot; title=&quot;peco&quot;&gt;&lt;/a&gt;peco&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/peco/peco&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
    
      <category term="Linux" scheme="http://cyukang.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>编译脚本到二进制</title>
    <link href="http://cyukang.com/2019/01/01/compile-script-to-binary-for-obfuscation.html"/>
    <id>http://cyukang.com/2019/01/01/compile-script-to-binary-for-obfuscation.html</id>
    <published>2019-01-01T14:55:22.000Z</published>
    <updated>2018-12-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>因为自己习惯使用 expect 脚本登录各种服务器，有一段时间因为要登录的服务器太多了，所以之前写过一个程序来管理各种 expect 脚本。实现思路是根据配置文件，用一个程序来动态生成脚本，执行完之后再删除。这样临时生成的文件里也是包含密码等信息的。最近突然想是不是可以直接写一个程序，把所有脚本类的程序转换为二进制可执行文件<a href="https://www.slideshare.net/LizBaillie/rustconf-2016-illustrated-adventure-guide-65894363" target="_blank" rel="external">^image</a>。我不想把密码之类的直接写在固定的脚本里面，所以密码也是被编译在可执行的二进制文件里的，这样能达到一些代码混淆的目的。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fyuxr5d6y5j30yg0j6gsy.jpg" alt="image-20190101234053094"></p>
<h3 id="rshc-的开发"><a href="#rshc-的开发" class="headerlink" title="rshc 的开发"></a>rshc 的开发</h3><p>这个程序看起来有些好玩，所以先我先搜了一下是否之前有其他人这样做过。于是找到了 <a href="https://github.com/neurobin/shc" target="_blank" rel="external">shc</a> 这个开源程序，这个最初版本是 96 年用 C 写的，最终执行的时候还是用 execvp 调用解释器执行各种脚本。我使用了一下发现居然不支持 expect 之类的。然后想着自己写个玩玩，顺便再动手用用最近看得又心痒的 Rust，最后用搞出来一个初版: <a href="https://github.com/chenyukang/rshc" target="_blank" rel="external">rhsc</a>。</p>
<p>目前我这个程序只是能把脚本程序，转换为 Rust 代码，然后使用 rustc 来编译为二进制，为了做一些代码混淆，其中也类似 shc 使用了 RC4 算法来做了一个简单的转换，加密用的 key 是随机生成的。然后也做了另外一个增加密码的模式，这样可以为任何脚本增加密码校验功能，最终使用 <a href="https://doc.rust-lang.org/beta/std/process/struct.Command.html" target="_blank" rel="external">Process</a> 来执行解释器。当然也谈不上多安全，如果要破解可以使用一些类似 ptrace 或者<a href="https://github.com/neurobin/shc/issues/63" target="_blank" rel="external">其他方式</a>来试试。以后我会继续完善这方面的防御。另外，为了在生成代码之后尽量减少依赖，所以目前密码输入时还未做到隐藏输入。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>使用方式非常简单，先安装：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">cargo install rshc</div></pre></td></tr></table></figure>
<p>然后使用命令： </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">rshc -f demo.sh -o demo.rs</div><div class="line"></div><div class="line">/<span class="regexp">/ add a passowrd when compile it, </span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ then binary will prompt for correct password before execution</span></div><div class="line"><span class="regexp">rshc -f demo.sh -o demo.rs -p</span></div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>时隔两年再用 Rust 写一些小项目，发现整个语言还是成熟很多：</p>
<ul>
<li>工具链很好用，特别是 cargo 之类的，<a href="https://crates.io/crates/rshc" target="_blank" rel="external">从开发到发布都非常方便</a></li>
<li>相关的库和文档也多了起来，相对来说更加容易上手写一些东西了</li>
<li>编译器的错误提示特别好，可以通过错误索引号找到示例</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h3&gt;&lt;p&gt;因为自己习惯使用 expect 脚本登录各种服务器，有一段时间因为要登录的服务器太多了，所以之前写过一个程序来管理各种 expect 脚本。
    
    </summary>
    
    
      <category term="Rust" scheme="http://cyukang.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>SQL Injection attack</title>
    <link href="http://cyukang.com/2018/03/10/sql-injection-attack.html"/>
    <id>http://cyukang.com/2018/03/10/sql-injection-attack.html</id>
    <published>2018-03-10T12:51:40.000Z</published>
    <updated>2018-03-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h3><p>SQL注入一直是 Web 应用的一大安全隐患，注入的基本原理是通过修改输入的参数来操作后台执行的 SQL，注入可能会导致数据库被恶意修改、数据被恶意读取等严重行为。所以如果一个参数有漏洞，通过小心的构造注入点即可利用，这里的<a href="https://paper.seebug.org/15/" target="_blank" rel="external">渗透攻防Web篇-SQL注入攻击初级</a>有一些编写注入点的教程。</p>
<p>最初的时候我在一个用 C 写后台的项目里待过，现在回想起来我们当时根本没注意SQL 注入，C 拼接处 SQL 的字符串很常见。不过现在大多数 Web 框架都已经有 ORM 了，ORM 可以在很大程度上避免注入的产生，因为程序员通常来说不用写纯的 SQL 了， 在最佳实践的前提下 ORM 会生成安全的 SQL。当然什么工具最终还是依赖程序员，比如下面的 Ruby 代码即会有问题: </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">User.where(<span class="string">"email = <span class="subst">#&#123;params[<span class="symbol">:email</span>]&#125;</span>"</span>).first</div></pre></td></tr></table></figure>
<p>更多作死的办法可以参考： <a href="https://rails-sqli.org/" target="_blank" rel="external">https://rails-sqli.org/</a></p>
<h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>通常我们会使用一些 WAF 来阻挡 一些SQL 注入，但是 WAF 也有其局限性。WAF 一般是通用的，不会局限于某个特定的框架。我们可以实现在 Nginx 上，或者使用一些商用的 WAF，通常来说对于应用也不用修改其代码。不过 WAF 的问题在于其实基于规则的，而 SQL 本省是比较复杂的，可以看看<a href="https://github.com/ronsavage/SQL/blob/master/sql-2003-2.bnf" target="_blank" rel="external">2003 SQL BNF</a> 的描述有多么的长。所以 WAF 的规则大多数是一大堆较难维护的正则表达式，比如： <a href="https://github.com/unixhot/waf/blob/master/waf/rule-config/args.rule" target="_blank" rel="external">Nginx Waf示例</a>，注意这个项目用不太成熟，初步看会有比较严重的<a href="https://github.com/unixhot/waf/issues/12" target="_blank" rel="external">性能问题</a>。正因为规则是固定的，会导致存在很多误拦截的情况，所以我在 Kong 上实现的 WAF 就还不敢用起来。例如现实情况中出现过<a href="https://store.dji.com/select" target="_blank" rel="external">包含select的 uri</a>被拦的情况，一脸忧伤。</p>
<h3 id="静态代码扫描"><a href="#静态代码扫描" class="headerlink" title="静态代码扫描"></a>静态代码扫描</h3><p>静态代码扫描会发现一些 SQL 注入，比如  Brakeman 之类的。不过通常静态代码扫描的问题也是分析得不够精准，会漏报、也会出现误报比较多，扫描的结果需要进行人工审计。当然这些工具也在逐步改进。</p>
<h3 id="RASP-工具"><a href="#RASP-工具" class="headerlink" title="RASP 工具"></a>RASP 工具</h3><p>RASP 的意思是<a href="https://www.veracode.com/security/runtime-application-self-protection-rasp" target="_blank" rel="external">Runtime Application Self Protection</a>，这个概念近些年才提出，目前已经有一些安全公司做出了对应的产品，比如<a href="http://www.sqreen.io" target="_blank" rel="external">Sqreen</a>, 百度最近也新开一个开源项目叫做<a href="https://github.com/baidu/openrasp" target="_blank" rel="external">OpenRASP</a>，目前来说只支持 Java，开发者可以自己使用 Javascript 编写自己的插件。RASP 除了自己的规则还会依据请求时候的上下文来进行分析，这篇文章里有<a href="https://blog.sqreen.io/block-sql-injections-not-customers/" target="_blank" rel="external">一些描述</a>，这样误报的问题会大大减少。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;注入原理&quot;&gt;&lt;a href=&quot;#注入原理&quot; class=&quot;headerlink&quot; title=&quot;注入原理&quot;&gt;&lt;/a&gt;注入原理&lt;/h3&gt;&lt;p&gt;SQL注入一直是 Web 应用的一大安全隐患，注入的基本原理是通过修改输入的参数来操作后台执行的 SQL，注入可能会导致数据
    
    </summary>
    
    
      <category term="security" scheme="http://cyukang.com/tags/security/"/>
    
  </entry>
  
</feed>
