<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyukang.github.io/"/>
  <updated>2021-11-23T11:05:03.520Z</updated>
  <id>http://chenyukang.github.io/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的知识管理工具和经验</title>
    <link href="http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html"/>
    <id>http://chenyukang.github.io/2021/11/23/my-notes-taking-tools-and-experience.html</id>
    <published>2021-11-23T00:21:58.000Z</published>
    <updated>2021-11-23T11:05:03.520Z</updated>
    
    <content type="html"><![CDATA[<p>知识管理是近些年出来的逼格称呼，通俗点说就是写笔记或者写作，讲究一点可以说成“打造第二大脑”，英文可以诗意地称之为 “Digital Garden”。看看，同样一个事怎么说出来格局完全不同了。</p><p>近两年笔记软件这个领域出现了两个很重要的革新：</p><p>一个是双向链接，开山鼻祖是 <a href="https://roamresearch.com/" target="_blank" rel="noopener">roam research</a> ，一个是一切皆对象的设计，也就是 <a href="https://www.notion.so/" target="_blank" rel="noopener">Notion</a>。</p><p>因为这两个大方向上的创新，现在笔记类软件和系统百发齐放，这是真是最好的时代了。</p><p>作为程序员我分享一下自己在这类工具上的使用经验、感受以及建议。</p><p>大概十多年前，还在学校的时候，博客文化刚兴起，所以很多记录类的东西我都写在博客里了。那些常见的博客系统我基本都用过，后来很多都倒闭了。当然 Wordpress 现在在非程序员中都非常流行。</p><p>后来很长一段时间我都是用 Evernote ，国内版本叫做印象笔记。用的人多了各种周边的工具也非常多，比如浏览器插件之类的。这类笔记软件也非常多。</p><p>后来我又渐渐不使用印象笔记了，因为我用了很多年 Emacs，所以尝试了 org-mode。这东西结合 GTD 可玩的方式可太多了。 org-mode 日程管理，日志，文档都在本地，一切都是纯文本的 org 格式，我通过 Github 来做数据存储。一切都是文本并且本地化就可以自动化，我可以自己写一些脚本，自己定义各种模板等等。虽然是纯文本的格式，我也可以很方便地到导出成 PDF , 甚至是做演示。很多人是为了使用 org-mode 才一直用 Emacs，我也曾经认为自己找到了以后一直用的记录工具和方式。</p><p>在这段时间，我养成的一个很好的习惯是使用  Github 来存储自己的数据。Github 已经成为最基础的互联网设施，我信任这个平台胜过其他服务。Joe Armstrong 在去世前一年，把自己的文章迁移到 Github， <a href="https://laike9m.com/blog/people-die-but-long-live-github,122/" target="_blank" rel="noopener">People Die, but Long Live GitHub - laike9m’s blog</a>。</p><p>但是，我因为换工作的原因不怎么使用 Emacs了。最近一年工作内容变了，自己日常开发和业务时间使用 Windows 更多。业余时间基本是用的 WSL ，配合 VsCode 日常开发体验很棒。 而 Emacs 在 Windows 上使用体验很不好，我也没找到合适的移动端解决方案。虽然最近 WSL 也支持 Linux Gui 了，但我已经懒得折腾，因为我已经离不开 VS Code 。</p><p>我需要重新找一个笔记类工具。我的需求是：</p><ol><li>本地存储文件</li><li>足够的自定义</li><li>支持 Markdown</li><li>支持双向链接</li></ol><p>这个需求其实满足了绝大部分程序员用户，一个文件夹加 Typora 估计都差不多了，但是我觉得双链这个设计确实有一些价值，所以也变成刚需了。</p><p>在摸索的过程中我试过 Notion，Wolai，Logseq，Obsidian。</p><p>Notion 确实有耳目一新的感觉，而且 UI 的审美很好，用户做出来的笔记可以很美观整洁。而内嵌 Database 可以打造出来很多好玩的东西，甚至可以用来做站点。缺点是服务器在国外，不太稳定。</p><p>Wolai 提供 Notion 类似的块编辑以及大部分功能，而且很早就有双链接，服务器在国内所以速度上也很快。版本更新很快，有很多针对中文用户的细节优化。如果不想折腾用 Wolai 也挺好的。</p><p>Logseq 是 roam research 的模仿品，但是提供本地存储的方式，也有桌面版软件。很多人赞赏 roam research ，不过我没有觉得 roam research 的方式完全适合我。 roam research 的正常方式是每天都在日志页面记录，然后写的过程中加上适合的链接，这样你的文档渐渐构成一个网络。如果你日常中经常用到的概念，自然就会经常被链接，那么就会是网络中的一个密集点。所以即使你不建文件目录，这种文档之间的关系也会自然而然形成，并且比目录这种单线的关系更符合直觉。</p><p><img src="/images/ob_Pasted_image_20211120225233.png" alt="/images/ob_Pasted_image_20211120225233.png"></p><p>最终我一直保持使用的是 Obsidian。Obsidian 支持本地存储数据的方式（也可选择付费远程同步）。我使用一个 Git 的插件自动同步到 Github。Obsidian 的的客户端做得如此出色，而且扩张性极好，已经形成很成熟的插件生态。这是我的记录汇成的网状。</p><p><img src="/images/ob_Pasted_image_20211120225329.png" alt="/images/ob_Pasted_image_20211120225329.png"></p><p>在使用 Obsidian 一段时间后我又体验了 Flomo，这是一个不错的软件让我们迅速把日常的想法记录下来。我想如果 Flomo 的数据能够同步到 Obsidian 就好了。</p><p>看了一下 Flomo 的接口，我觉得干脆还不如自己动手重新实现来练练手。我就动手自己实现了一个 Web 单页应用 <a href="https://github.com/chenyukang/obweb" target="_blank" rel="noopener">obweb</a>，然后部署在自己的服务器上。这个应用提供一个简单的页面来记录日常的想法，文字或者图片都能迅速提交。数据提交后同步到 GitHub。这个 SPA 页面可以内嵌在微信浏览器，所以使用体验和一个小程序差不多。</p><p>而后我又增加了搜索的接口，这样我所有 Obsidian 的数据都可以在手机端检索和查看，而且我也能做一些简单的编辑。这真的比一个独立的手机应用更方便。</p><p>最近我又新增了一个 Rss 阅读的功能，后台会自动根据我的订阅列表抓取 Feed，甚至会尝试把网页和图片都下载下来，这样即使是一些’内网’不能直接访问的文章也可以在手机端无障碍阅读。</p><p>在这个过程中我学会了 svelte 这个前端框架和 Rust 写服务端接口这些东西。虽然我的前端技能和 UI 设计简直就是渣渣，但是这就是完全贴合我的使用习惯的软件，我可以做到所有细节的定制化。</p><p><img src="/images/ob_Pasted_image_20211120234708.png" alt="/images/ob_Pasted_image_20211120234708.png"></p><p>这是一种渐进式的开发体验，每隔一段时间我会在使用过程中摸索一个需求，然后我会稍微等一等，如果这个需求还是存在并且我考虑好了如何实现，我就会加上去。</p><p>折腾这么多年这类软件后，我的感受是工具的使用都是非常私人化的选择，作为程序员我们有能力使用自己的技术来定制化工具来提高效率。最近看到这篇文章 <a href="https://www.swyx.io/make-your-own-tools/" target="_blank" rel="noopener">You’re Allowed To Make Your Own Tools</a> 很好的阐述了这个观念。</p><p>所以在文档和写作这块，数据本地纯文本的方式是对程序员更好的方式，你可以自己写程序来处理这些数据，而不是完全依靠软件或者第三方的功能。比如这篇文章就是我在陪小孩上课的过程中，用手机在 obweb上敲出来，服务器上的脚本会自动转成 Hexo 文件，提交发布到我的博客。</p><p>这就像是住房子一样，如果你自己是设计师，估计不会满足房地产商提供的统一装修，而是根据自己的喜好和习惯来重新设计。房子也不是越富丽堂皇就越好，简单但实用即可。</p><p>最后，我们现在有很多华丽的工具来用，也要避免让自己变成一个纯粹信息的收藏者。’数字花园’不是一股脑地往后院搬东西就行，需要花时间精心打理和修剪。工具并不能本质地解决问题，难的是日复一日坚持记录自己的想法和理解，整理知识。柳比歇夫使用纸和笔记录了自己奇特的一生，并且完成大量研究工作。</p><p>记录的过程并不是学习本身，而是思考。通过记录这种形式，把自己的理解写下来促进思考，才能产生最大的价值。</p><hr><p>题外画:</p><p>一个有趣的事是，除了 Roam Research 和大厂的传统产品，目前兴起的这些笔记类软件和服务大多是中国人开发的，包括 Notion、Obsidian、Logseq 等。我们可能真的比较喜欢这类东西，“好记性不如烂笔头” 乃民族真传。</p><p>另一个事实，Roam Research，Logseq，以及另外一个开源的类似产品 athens research 都使用了 Clojure 这门编程语言来实现。Clojure 作为一门 JVM 上的 Lisp，其热度还没进过前 30 吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识管理是近些年出来的逼格称呼，通俗点说就是写笔记或者写作，讲究一点可以说成“打造第二大脑”，英文可以诗意地称之为 “Digital Garden”。看看，同样一个事怎么说出来格局完全不同了。&lt;/p&gt;
&lt;p&gt;近两年笔记软件这个领域出现了两个很重要的革新：&lt;/p&gt;
&lt;p&gt;一个
      
    
    </summary>
    
    
      <category term="工具" scheme="http://chenyukang.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发" scheme="http://chenyukang.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>最好的学习是输出</title>
    <link href="http://chenyukang.github.io/2021/09/07/learning-by-contribute.html"/>
    <id>http://chenyukang.github.io/2021/09/07/learning-by-contribute.html</id>
    <published>2021-09-07T21:49:24.000Z</published>
    <updated>2021-09-11T01:00:04.293Z</updated>
    
    <content type="html"><![CDATA[<p>之前我设想如果有了足够多时间，会做这些事：到处逛逛，锻炼英文写作，​投入到开源社区中。最近一年有了一些空余时间来做这些。我通常是十点到公司，下午五点半左右到六点之间离开公司。晚上陪小孩，洗漱哄睡完毕之后大概是九点钟。所以每天早上、晚上，加上周末，我都有一段时间可以用来自己安排。</p><p>​这半年时间我参与了好几个开源项目，基本是顺着自己感兴趣的领域来的：</p><ol start="0"><li><p>3 月左右，微软有个 FHL(Fix/Hack/Learning) 活动，基本有两周左右时间可以做自己感兴趣的项目，或者是学习点什么技术。那段时间我在琢磨怎么下好五子棋，因为和老婆经常比赛赌输赢。所以我写了个程序来下五子棋 <a href="https://github.com/chenyukang/gomoku" target="_blank" rel="noopener">gomoku</a>，顺便学了一些技术相关的，比如 Rust，WebAssembly，Azure function，monte carlo，minimax 算法等。可能是我很久没从头到尾写个项目的原因，这个项目写得很来劲，顺便掉入 WebAssembly 的坑里。</p></li><li><p>接触到了 WebAssembly 发现有些意思, 所以看了很多相关的内容。然后我参与到了 wamser.io。这是一个 Rust 写的 WebAssembly Runtime，还包括各种语言的 SDK 之类的。我开始从一些简单的 <a href="https://github.com/wasmerio/wasmer/pulls?q=is%3Apr+author%3Achenyukang+is%3Aclosed" target="_blank" rel="noopener">PR 到一些 Bug 修复</a>。通过这些投入我大概也熟悉了这个项目的代码。这个项目 Star 数目虽然有1W+，但是其实日常维护者已经只有两位了，其背后是一个公司在支撑。这公司之前是在 YC 孵化的，但是据我观察是没找到合适的商业化途径。当年 Docker 是找不到合适的盈利方式，所以最终选择开源。不过短短几年，现在这些技术型创业公司，基本都是默认开始干开源的，比如那些开源数据库之类的项目。</p></li><li><p>帮 <a href="https://github.com/WasmEdge/WasmEdge" target="_blank" rel="noopener">WasmEdge</a> 做了一些和 <a href="https://dapr.io/" target="_blank" rel="noopener">Dapr</a> 的集成 Demo，花了大概两周的业余时间来学习 Dapr 和 WasmEdge 相关的技术，最终完成项目 <a href="https://github.com/second-state/dapr-wasm" target="_blank" rel="noopener">dapr-wasm</a>。这也是我第一次尝试收费帮人做开源，虽然不多但是也算是个不错的开头。既能赚钱又能学点新东西，何乐不为。</p></li><li><p>玩了一段时间 K8S 和 Linkerd 之后，我对容器相关技术又有一些兴趣。仍然记得 2014 年刚接触到 Docker 时的震撼，所以我想看看容器到底是怎么做的。后来找到了 Rust 实现的 Container Runtime <a href="https://github.com/containers/youki" target="_blank" rel="noopener">youki</a>。这个项目主要是一群日本年轻人在开发，项目发起人还是 96 年的。真是后生可畏! 我陆陆续续大概提交了十来个 PR，主要是改进一些测试脚本、参考 runc 来实现一些功能，通过容器的基准测试等。在 discord 偶尔和项目发起者聊聊天，交流一些中日的 IT 相关感受也挺有意思。贡献了<a href="https://github.com/containers/youki/pulls?q=is%3Apr+author%3Achenyukang+is%3Aclosed" target="_blank" rel="noopener">几个 PR</a> 之后，他邀请我成为项目的 maintainer。我觉得这是一个很好的锻炼、提高自己的机会，所以就欣然接受了。其实容器底层都是一些什么权限管理，namespace，cgroup，file system 等基于操作系统的抽象层做了隔离，跑起来就是进程而已。在开发容器的过程中，有时候会把自己的 Host OS 搞跪，所以最好是在 wsl 或者 VM 里面开发。</p></li><li><p>最近在使用 Rust 过程中，发现 lint 会重复报告某些提示。经过搜索发现已经有人提出了同样的问题。我曾经好几次尝试过看看 Rust 的源码，但一直没沉下心有所得。这个 Bug 看起来并不难排查，也许是一个很好的契机。我花了大概几个小时时间从理解 lint 相关的逻辑，到复现这个 Bug，找到代码里的问题，然后做出一个初步修复。这个过程中，感觉比较困难的是编译一次 Rust 代码库大概需要半个小时，跑测试则需要更久。另外通过 gdb 虽然可以调试代码，但是还是有某些限制。提交了 PR 之后才只是开始，后来又经过了一周多时间和子模块维护者讨论更细节的问题，来回 20 多 comments 才最终完成了<a href="https://github.com/rust-lang/rust/pull/88493" target="_blank" rel="noopener">修复</a>。</p></li></ol><p>从 2011 年开始使用 Github，这些年一直在 Github 上做一些自己的开源小项目。只有最近大半年才比较多地参与到一些大的开源项目。这个过程收获很多。</p><p>最好的学习方式是贡献和输出。不管是在公司、或者是在开源社区做出贡献才是技术的价值。看书、看资料能学会一些，但是只有实践才能提高自己的能力。比如我学 Rust，肯定不花时间去看 Rust quiz 之类的东西，因为日常开发中常用到的语言特性并不是那些细节。很多领域更重要或者更有价值的是领域知识，编程语言在使用过程中不懂再去看就行了。</p><p>有了足够的业余时间，以及纯粹的爱好，才静下心来持续投入到免费的开源中。996 肯定是不行的。做开源很多人都是在 “用爱发电”。很多开发者大多是有一份本职工作，做开源也算是眼望星空吧。但是确实因为热爱，所以代码质量反而比公司代码高。工作中看多了十多年的历史代码，看点优秀的开源代码有洗眼效果。</p><p>Github 现在开始在某些国家支持 <a href="https://github.com/sponsors" target="_blank" rel="noopener">Sponsor</a> 项目，可是中国不在试用范围内。我认为这是一个很好的趋势，做开源的程序员如果创造出来价值，应该得到一些资金上的支持。这使得有些程序员可以为了自己的项目，依赖这些资金全职投入到开发中，比如 <a href="https://github.com/sponsors/cart" target="_blank" rel="noopener">Bevy 的作者</a>，来不及等到筹集 7000 美金一个月的筹款就辞职投入了。</p><p>在投入到开源的过程中，除了自己能力的提升，也可以获得精神上的满足感。即使修复是一个小问题，其他人也会因为自己的投入而受益。而因为开源以及其带来的共同协作模式，程序员的学习、生产资料都极大丰富。这真是个好时代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前我设想如果有了足够多时间，会做这些事：到处逛逛，锻炼英文写作，​投入到开源社区中。最近一年有了一些空余时间来做这些。我通常是十点到公司，下午五点半左右到六点之间离开公司。晚上陪小孩，洗漱哄睡完毕之后大概是九点钟。所以每天早上、晚上，加上周末，我都有一段时间可以用来自己安
      
    
    </summary>
    
    
      <category term="Programming" scheme="http://chenyukang.github.io/tags/Programming/"/>
    
      <category term="Rust" scheme="http://chenyukang.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>案例分析-程序员如何站着赚钱</title>
    <link href="http://chenyukang.github.io/2020/10/27/programmer-out-of-normal-job.html"/>
    <id>http://chenyukang.github.io/2020/10/27/programmer-out-of-normal-job.html</id>
    <published>2020-10-27T21:57:00.000Z</published>
    <updated>2021-07-02T15:36:31.143Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://twitter.com/dvassallo" target="_blank" rel="noopener">Daniel Vassallo</a> 是我最近一年都在关注的一个推特用户，我几乎看了他发的所有 Twitter 和文章。</p><p>这位程序员去年离开了亚马逊的一份轻松而多金的工作。他在亚马逊干了 8 年，尽管不断获得晋升、薪酬、表彰和表扬等奖励，薪水从 7.5w 刀一路涨到 50w 刀，但他没有足够的动力再干一年。</p><p>至于为什么离开亚马逊，他写了一篇很好的文章来解释：<a href="https://danielvassallo.com/only-intrinsic-motivation-lasts/" target="_blank" rel="noopener">只有内在动力才能持续</a>.</p><p>主要原因是随着级别的提高，工作的自由度减少了，得平衡各方利益，说服其他人来完成特定的目标。这很正常，在大公司工作有很多固有的限制，关于如何做工作，做什么工作，设定什么目标，以及什么业务值得追求。很多时候会迫使我们去做不想做的事情，而想做的可能也无法施展。</p><p>总之，在公司赚钱肯定是比较稳定，收入也不错。只是时间、精神上谈不上自由。为大公司工作是一种稳定的状态，就像是围城一样。</p><p>如何站着把钱挣了？</p><h2 id="什么动力才能持久？"><a href="#什么动力才能持久？" class="headerlink" title="什么动力才能持久？"></a>什么动力才能持久？</h2><p>动力分为<em>外部动力</em>和<em>内部动力</em>：</p><p>外部动力可以称之为棒子或者萝卜。举例来说，缴税是棒子，虽然我们不想做，但是必须得完成。为了买一辆豪车，努力加班加点赚钱，这就是萝卜。两者都是外在因素迫使我们不断地有『动力』去执行。</p><p>内部动力是持久动力，就是自己心甘情愿去做，并且乐于其中。这位程序员的兴趣在于写代码，卖自己的作品。而互联网时代就是最好的舞台，个人可以专注于自己专业领域，完成自己的作品，并获取关注和收入。当然最重要的是作品的质量，以及推销的手法。</p><h2 id="找到自己的切入点"><a href="#找到自己的切入点" class="headerlink" title="找到自己的切入点"></a>找到自己的切入点</h2><p>通过自己的作品来赚钱，听起来很简单，但实现起来难度其实是巨大的。</p><p>辞职后开始做的一个项目叫做 <a href="https://userbase.com/" target="_blank" rel="noopener">Userbase</a>， 为静态网站增加持久化存储。另外开始和朋友做的是一本电子书：<a href="https://gumroad.com/l/aws-good-parts/dv" target="_blank" rel="noopener">The Good Parts of AWS</a>。售价25美金一份。10个月总共花费 3w 多美金推广，收入 25w 美金。</p><p><img src="/images/image-20201030073721363.png" alt="image-20201030073721363"></p><p>这本电子书包含一些经验性的东西，对基于 AWS 做技术架构的人挺有用的。对于在 AWS 上工作了10多年的人写出这样一本小册子肯定是不难的，但是难的是如何做推广。</p><p>这也是作者做得挺好的一点，在 Twitter 上经营固定的读者。他每天都会发一些作为 Indie 的一些感想，关于工作、生活、经济、创业方面的。14 个月时间从 150 的 follower 涨到了 49000 多。他经常会把一些自己项目的数据贴出来给大家分享，这样显得特别真实、真诚。这种推广套路营造出一种类似《楚门的世界》的观感效果，读者看着他从第一天辞职，然后不断经营自己的项目，就会有动力一直去关注后面的进展。</p><p>然后作者把自己最近一年左右的 Twitter 推广实践经验又录成了视频： <a href="https://gumroad.com/l/twitter-audience/dv" target="_blank" rel="noopener">Everyone Can Build a Twitter Audience</a>， 售价 50 美金。这一连贯手法真是越来越溜了。</p><p>当然，除了营销外之外能力是最重要的，这位同志的写作能力一流。可以从第一篇辞职撰文可以看出，用词、表达清晰有据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有人可能认为，这赚得看起来还没他自己上班多啊！</p><p>但是，为自己工作的自由度、成就感、安全感是完全不同的，而且这还只是一个开始。</p><p>很多人丢掉了自己的全职工作之后，完全不知道如何打造自己的另外一份收入，陷入等米下锅的状态。总结起来都是很简单的道理，只是做到的人很少：</p><ul><li>跳出自己的舒适区，向自己期望的生活方式改变</li><li>找到自己的兴趣点和优势，寻找自己能满足的实际需求</li><li>相信时间的复利效应，做有积累的事情</li><li>付费意识还是挺重要的，这点不可否认英文环境相对来说会更好一些</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://twitter.com/dvassallo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Daniel Vassallo&lt;/a&gt; 是我最近一年都在关注的一个推特用户，我几乎看了他发的所有 Twitter 和文章。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DHH - 关于软件开发的少数派</title>
    <link href="http://chenyukang.github.io/2020/10/10/dhh-on-software-dev.html"/>
    <id>http://chenyukang.github.io/2020/10/10/dhh-on-software-dev.html</id>
    <published>2020-10-10T22:50:38.000Z</published>
    <updated>2021-07-02T15:36:31.139Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/" target="_blank" rel="noopener">David Heinemeier Hansson, Software Contrarian</a> 是 Podcast 频道 corecursive 在 2020.2.1 发布的一个 DHH 关于软件开发相关的访谈。</p><p>DHH 不用介绍了，Rails 创始人。</p><p>可以说之前 Ruby 的流行很大程度上依赖于 Rails 的兴起。Rails 确实影响了很多后来的 Web 框架的设计和实现，并给软件开发带了一些全新的理念。</p><p>这期是我之前当作练习英语的材料来听的。DHH 的口音非常清晰，表达方式也是非常直接。因此这期听起来有一种类似 Rap 的快感。</p><p><img src="/images/2020_10_01_dhh-software-contrarian.org_20201009_220930.png" alt="file:img/2020_10_01_dhh-software-contrarian.org_20201009_220930.png"></p><h2 id="为什么-Rails-成功了"><a href="#为什么-Rails-成功了" class="headerlink" title="为什么 Rails 成功了"></a>为什么 Rails 成功了</h2><p>Rails 的出现改变了软件开发，至少在 2006 年，当 Java，C# 大行其道的年代。Rails 以其优异的开发效率震惊了不少开发者。Rails 的成功无非是在恰好的时机做了恰当的事情。</p><p>DHH 总结了从 Java、PHP 的开发经验。Java 阵营里都是聪明人，有很多好想法，但是他们却在一个糟糕的开发环境里工作，不容易让新人轻易上手。而 PHP 却很简单明了，你直接把一个文件拖入特定的文件夹，就可以生成对应的网页。Rails 的第三个元素就是 Ruby，Ruby 是极其容易安装，容易上手而直接的编程语言。DHH 当时正在写 Basecamp，所以一切都是从实际使用出发的，自己构建工具，然后再用这个工具构建 Basecamp。</p><p>而且 DHH 当时也是一个 Ruby 新手(那时的 Ruby 老手估计也没几个?)</p><p>新手的好处在于，他不知道 Ruby 的极限在哪里，哪里可能面临挑战。这样可以随着自己的性子，满足自己的期望来构建 Rails 了。在写 Rails 的过程中，DHH 更关注的是作为用户的感受是什么？编程就像是做菜一样，厨子需要关注的色香味俱全。</p><p>Ruby 最大的洞见是: 程序员不仅仅是程序员，同时也是人。</p><p>依据这个原则，在设计 Ruby 中最重要的事情和设计标准就是：编程语言使程序员更快乐。</p><h2 id="最开始如何开始接触-Ruby"><a href="#最开始如何开始接触-Ruby" class="headerlink" title="最开始如何开始接触 Ruby"></a>最开始如何开始接触 Ruby</h2><p>Ruby 是日本人 Matz 于 1995。但是直到 2003，这门编程语言仍然是非常小众而神秘的。DHH 也是那段时间在看到些 Martin Fowler 和 Dave Thomas 写的技术文章，他们俩个都选择了 Ruby 作为编程语言介绍一些概念。这引起了 DHH 的兴趣，所以开始关注 Ruby，并去参加了 Ruby 2004 Conf。</p><p>那届 Conf 大约也就 42 人吧….</p><p>但是随后几年的 Rails Conf 就开始有 2500 人了。</p><h2 id="关于编程语言的选择"><a href="#关于编程语言的选择" class="headerlink" title="关于编程语言的选择"></a>关于编程语言的选择</h2><p><strong>很多程序员因为喜欢上编程，就是刚好碰到了符合自己口味的编程语言，并激发对编程的巨大乐趣</strong>。所以，语言的选择说不重要也不对。如果你还没找到自己的最爱，继续尝试吧。</p><p>但并不意味着，在一个小众的编程语言过多投资可能会带来其他的回报。语言的流行有很多其他的因素。Rails 的初衷并不是完全用来满足自己的创造轮子的快感的，而是依据自己的实际项目出发的。</p><p>这给我们的不错启示：从实际的需求出发，使用新的工具造轮子。</p><h2 id="关于微服务的吐槽"><a href="#关于微服务的吐槽" class="headerlink" title="关于微服务的吐槽"></a>关于微服务的吐槽</h2><p>DHH 对微服务保持否定态度，认为业界这么流行微服务其实是有害的。</p><p>大多数情况下，一个人可以完全理解、部署的单一应用，比微服务更容易维护。</p><p>微服务的优势在于，如果团队足够地大，我们需要给开发者一些界限。</p><p>不要盲目地沿用大公司的套路，因为解决的问题不同！</p><h2 id="关于-TDD"><a href="#关于-TDD" class="headerlink" title="关于 TDD"></a>关于 TDD</h2><p>TDD 也是 Rails 社区很流行和推崇的，但是 DHH 其实对此并不太感冒。并不是 TDD 就能写出更好的，更健壮的软件。</p><p>事先写测试用例还是事后写并不重要，重要的是自动化测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Heinemeier Hanss
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络相关</title>
    <link href="http://chenyukang.github.io/2020/09/08/networking-notes.html"/>
    <id>http://chenyukang.github.io/2020/09/08/networking-notes.html</id>
    <published>2020-09-08T20:59:08.000Z</published>
    <updated>2021-07-02T15:36:31.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h1><p>分为递归解析和迭代解析</p><p><a href="https://blog.csdn.net/lycb_gz/article/details/11720247" target="_blank" rel="noopener">https://blog.csdn.net/lycb_gz/article/details/11720247</a></p><h1 id="APR-欺骗"><a href="#APR-欺骗" class="headerlink" title="APR 欺骗"></a>APR 欺骗</h1><p>ARP 欺骗是一种在局域网中常用的攻击手段，目的是让局域网中指定的（或全部）的目标机器的数据包都通过攻击者主机进行转发，是实现中间人攻击的常用手段，从而实现数据监听、篡改、重放、钓鱼等攻击方式。</p><h1 id="TCP-IP-报文长度和格式"><a href="#TCP-IP-报文长度和格式" class="headerlink" title="TCP/IP 报文长度和格式"></a>TCP/IP 报文长度和格式</h1><p>IP 头部信息：头部长度：通常 20 字节，有选项时更长，总共不超过 60 字节。IP 数据报长度：65535 字节。</p><p><img src="/images/networking.org_20190731_120051.png" width="70%" hegiht="70%" align="center"></p><p>TCP 协议，在传输层。特点：可靠性。通过连接管理（三握四挥），序列号，确认号，拥塞控制，重传控制来保证可靠性。头部长度：一般为 20 字节，选项最多 40 字节，限制 60 字节。</p><p><img src="/images/networking.org_20190731_120147.png" width="60%" hegiht="60%" align="center"></p><h1 id="TCP-最大报文长度-MSS"><a href="#TCP-最大报文长度-MSS" class="headerlink" title="TCP 最大报文长度 (MSS)"></a>TCP 最大报文长度 (MSS)</h1><p><a href="https://blog.csdn.net/codejoker/article/details/5437141" target="_blank" rel="noopener">https://blog.csdn.net/codejoker/article/details/5437141</a></p><p>TCP 提供的是一种面向连接的，可靠的字节流服务，TCP 提供可靠性的一种重要的方式就是 MSS。通过MSS，应用数据被分割成 TCP 认为最适合发送的数 据块，由 TCP 传递给 IP 的信息单位称为报文段或段(segment)。代表一个 TCP socket 的结构体 struct tcp_sock 中有多个成员用于确定应用数据被分割成最大为多大的数据块较为合适(最大报文段长度 MSS)。我们不难联想到，跟最大报文段长度最为相关的一个参数是网络设备接口的 MTU，以太网的 MTU 是 1500，基本 IP 首部长度为 20，TCP 首部是20，所 以 MSS 的值可达 1460(MSS 不包括协议首部，只包含应用数据)。</p><p>本地以太网中 MSS 为 1460 的说法并不正确，它还会动态变化，如果 IP 首部和 TCP 首部中出现选项，则 MSS 要相应的减小，一般 TCP 首部中会 有 12 字节的时间戳选项(外加两字节的填充选项)，这时的 MSS 就等于 1448。MSS 的主要作用是限制另一端主机发送的数据的长度，同时，主机本身也控制自己发送数据报的长度，这将使以较小 MTU 连接到一个网络上的主机避免分段。</p><h1 id="如果使用-TCP-希望传输一个复杂的对象应该怎么传输？"><a href="#如果使用-TCP-希望传输一个复杂的对象应该怎么传输？" class="headerlink" title="如果使用 TCP 希望传输一个复杂的对象应该怎么传输？"></a>如果使用 TCP 希望传输一个复杂的对象应该怎么传输？</h1><p>TCP 中的流是指流入进程或者从进程中流出的字节序列。所以向 Java/golang 等高级语言在进行 TCP通信是都需要将相应的实体序列化才能进行传输。</p><h1 id="TCP-IP-中如何解决粘包问题？如果一直传输数据怎么拆包"><a href="#TCP-IP-中如何解决粘包问题？如果一直传输数据怎么拆包" class="headerlink" title="TCP/IP 中如何解决粘包问题？如果一直传输数据怎么拆包?"></a>TCP/IP 中如何解决粘包问题？如果一直传输数据怎么拆包?</h1><p>应用层协议，不管是标准的还是自己定义的。“粘包”问题是伪问题。</p><p><a href="http://www.hchstudio.cn/article/2018/d5b3/" target="_blank" rel="noopener">http://www.hchstudio.cn/article/2018/d5b3/</a></p><p><a href="https://img.hchstudio.cn/TCP.gif" target="_blank" rel="noopener">https://img.hchstudio.cn/TCP.gif</a></p><h1 id="TCP-连接和断开的状态图"><a href="#TCP-连接和断开的状态图" class="headerlink" title="TCP 连接和断开的状态图"></a>TCP 连接和断开的状态图</h1><p>connect:</p><p><img src="/images/networking.org_20190802_115508.png" width="60%" hegiht="60%" align="center"></p><p>disconnect:</p><p><img src="/images/networking.org_20190802_115604.png" width="60%" hegiht="60%" align="center"></p><p>为什么 TCP 连接断开的时候要<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">进行四次握手</a>：</p><h1 id="TCP-四次挥手的-TIME-WAIT"><a href="#TCP-四次挥手的-TIME-WAIT" class="headerlink" title="TCP 四次挥手的 TIME_WAIT"></a>TCP 四次挥手的 TIME_WAIT</h1><p>时间段长为 2MSL（报文段最大生存时间）</p><ul><li>TIME_WAIT 存在的理由之一是尽可能护送最后的 ACK 达到对端，保证可靠地终止 TCP 链接。</li><li>假设 tcp 连接是： A(1.2.3.4:8888)——B(6.7.8.9:9999), 这就是一个 tcp 四元组。当 tcp 连接关闭后， 四元组释放。TIME_WAIT 存在的理由之二是新旧四元组互不干扰。</li></ul><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC（Remote Procedure Call）—远程过程调用 ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发分布式程序就像开发本地程序一样简单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS-域名解析&quot;&gt;&lt;a href=&quot;#DNS-域名解析&quot; class=&quot;headerlink&quot; title=&quot;DNS 域名解析&quot;&gt;&lt;/a&gt;DNS 域名解析&lt;/h1&gt;&lt;p&gt;分为递归解析和迭代解析&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员如何提高英文写作</title>
    <link href="http://chenyukang.github.io/2019/11/07/improve-english-writing-as-progammer.html"/>
    <id>http://chenyukang.github.io/2019/11/07/improve-english-writing-as-progammer.html</id>
    <published>2019-11-07T08:45:53.000Z</published>
    <updated>2021-07-02T15:36:31.139Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个月坚持了一段时间英文写作，兴趣和自信心都大为增强。为什么突然想锻炼自己的英文写作能力呢，是因为工作中要写个什么英文的白皮书，然后发现懂技术的不太会写，会写英文的不太懂技术。最后找了团队中的一个留学生帮忙，大家跌跌撞撞把工作完成了。仔细想想这就是稀缺能力啊，按照刻意练习的套路，我应该好好提高一下自己的英文写作能力。</p><p><img src="/images/image-20191107195802111.png" alt="image-20191107195802111"></p><p>然后，我就开始在一些社区，比如 dev.to 写技术文章，在 Quora 上回答问题等，这些坚持了两个月左右，自我感觉收获不少。至少，现在让我写一篇英文类的长文，我是好无压力并且有些享受的(可能还处于自我感觉良好的时期的缘故)。</p><p>下面总结一下关于英文写作的一些自我心得。 </p><h2 id="抛去恐惧心理"><a href="#抛去恐惧心理" class="headerlink" title="抛去恐惧心理"></a>抛去恐惧心理</h2><p>这是很多人要克服的第一关，想着中文都写不溜，英文如何写？写作这个东西就是需要不断练习的，即使文笔不行，首先要做到的是写出来，并且简明扼要。文章最重要的目的是表达自己，并且让人易懂，更高的要求才是让人产生读的乐趣。对于绝大部分科技类的写作来说，准确是第一要素。 </p><p>如何抛去恐惧心理？唯一的办法就是多读、多写，并且让大家看，收集反馈然后不断改进。 </p><h2 id="在哪里写"><a href="#在哪里写" class="headerlink" title="在哪里写"></a>在哪里写</h2><p>像我刚才说的，有很多不错的技术社区，比如 Github、StackOverflow、Quora, 这些都是英文表达的场所，也是一个很好的锻炼自己英文写作的平台。从小处开始，可以写一个英文的 README，代码中使用良好的英文注释？在 Quora 上回答问题是更好的方式，因为这是一个互动的平台，你的回答会被多个人看到，这样可能会有一些反馈。</p><p>比如这个找 Quora 里的回答，题主问的是学习编程是否需要很多数据技巧？这对于我们这样的多年程序员来说，自然是有一些心得的，然后我就写了一些自己的想法作为回答。后面有一位朋友写了另外一个回答： </p><p>“题主，数学技能是次要的，你应该好好学学英文写作，这样至少不会让你像上面这位回答者这一样犯一些低级的错误。” </p><p>没多久我就看到了这条回答，然后看了看自己真的是犯了一些很明显的语法错误，修正后再回复了一下这位朋友，他表示自己也有点刻薄了，哈哈。其实大家对这种“助人助己”的学习方法是很乐于接受的，只要是给社区提供有用的东西。 </p><p><img src="/images/pic3.png" alt="pic3"></p><p>在 Quora 上还碰到另外一个瑞典的伙计，也帮我提出了一些建议。然后第二天还帮我一句一句做了一个修改版本，发到了我的邮箱。英语不是母语的人写的文章，如果不是让英语为第一语言的朋友阅读，这些表达方面的问题是不容易看出来的。</p><p><img src="/images/image-20191107194028413.png" alt="image-20191107194028413"></p><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h3><p>很多人对于自己的词汇量没有信心，觉得词汇量不够不足以表达自己的想法。这是不对的，其实你看看大部分技术类英文文章，对于接受过大学教育的技术人人员来说，应该是 95% 以上的单词都是认识的。对于不认识的单词来说也可以根据上下文来推测的，所以至少词汇不会构成阅读障碍。对于英文写作来说，基于简明表达自己的要求，我们那点四六级词汇也很够玩的。词汇在于平时积累，我现在也在着重注意积累一些词汇。日常使用过程中，多注意一些应文的惯用词汇。有一个 Chrome 插件叫做“单词小卡片”，可以把日常浏览网页的过程中发现的不太熟悉的单词加入列表，可以日后以便回顾。 </p><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p><img src="/images/pic1.png" alt="pic1"></p><p>阅读和写作是分不开的，只有多读才会发现更多套路。上面提到的那些社区都有很多不错的英文内容可以读，另外要特别提到一个的是 medium.com，类比为国内的简书。不过个人感觉质量比简书的内容好很多，可能是我阅读了付费内容的缘故。这个付费也挺便宜的，一个月 5 美金。 </p><p>作为程序员，另外要多阅读就是技术类的书籍。这些年我买了不少英文类的技术书籍，大多是翻过的，而且有少部分是精读完了。其实只要你能坚持阅读完一本 300 页左右的技术书籍，第二本就很简单了。如果是非技术类的英文文章，要数量阅读就需要提高词汇。 </p><h3 id="撰写"><a href="#撰写" class="headerlink" title="撰写"></a>撰写</h3><p>其实写作无非是表达自己，中文和英文写作有很多都是相通的。 </p><p>撰写过程中需要时刻明白，写的东西是给其他人看的。所以排版也很很重要，如果文章比较长，需要让人看得不至于疲累。适当地配一些贴近情景的图片也非常有助于提高可读性。段落要分明，不要某些段落太长。</p><p>最后，即使是英语是母语的人也很容一些常见的语法错误。所以我们需要工具来减少这类问题，grammarly.com 就是非常有用的工具，即使是免费版本对于日常使用来说也是足够了的。 </p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>不断练习，收集反馈，持续改进。唯此而已。 有两本书可以看看。</p><ol><li><a href="https://book.douban.com/subject/27122346/" target="_blank" rel="noopener">《七十二堂写作课》</a></li><li><a href="https://book.douban.com/subject/1451400/" target="_blank" rel="noopener">《风格的要素》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近几个月坚持了一段时间英文写作，兴趣和自信心都大为增强。为什么突然想锻炼自己的英文写作能力呢，是因为工作中要写个什么英文的白皮书，然后发现懂技术的不太会写，会写英文的不太懂技术。最后找了团队中的一个留学生帮忙，大家跌跌撞撞把工作完成了。仔细想想这就是稀缺能力啊，按照刻意练
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C 语言的 typecheck</title>
    <link href="http://chenyukang.github.io/2019/08/06/type_check_in_c.html"/>
    <id>http://chenyukang.github.io/2019/08/06/type_check_in_c.html</id>
    <published>2019-08-06T01:31:18.000Z</published>
    <updated>2021-07-02T15:36:31.147Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类型保证"><a href="#类型保证" class="headerlink" title="类型保证"></a>类型保证</h4><p>强类型的编程语言通常编译器自带一些类型检查，保证代码编译后不会出现类型方面的错误，比如 Rust 之类的甚至做了变量的生命周期检查，以防止内存出错或者未定义行为。常见的变成语言类型如下：</p><p><img src="/images/2019_08_06.org_20190806_012652.png" width="70%" hegiht="70%" align="center"></p><h4 id="typecheck"><a href="#typecheck" class="headerlink" title="typecheck"></a>typecheck</h4><p> 但是 C 为弱类型语言，弱类型语言，类型检查更不严格，如偏向于容忍隐式类型转换。譬如说 C 语言的 int 可以变成 double。 这样的结果是：容易产生 forbidden behaviours。为了解决类似问题，Linux 内核中的这个宏比较有技巧。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> typecheck(type,x)                       \</span></span><br><span class="line">  (&#123;  type __dummy;                             \</span><br><span class="line">  typeof(x) __dummy2;                           \</span><br><span class="line">  (<span class="keyword">void</span>)(&amp;__dummy == &amp;__dummy2);                \</span><br><span class="line">  <span class="number">1</span>;                                            \</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p> 使用的时候可以保证某些变量为特定的类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">typecheck(<span class="keyword">char</span>, a);</span><br></pre></td></tr></table></figure><p> 这样就会报出一个编译错误：</p><p><img src="/images/2019_08_06.org_20190806_011627.png" width="70%" hegiht="70%" align="center"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类型保证&quot;&gt;&lt;a href=&quot;#类型保证&quot; class=&quot;headerlink&quot; title=&quot;类型保证&quot;&gt;&lt;/a&gt;类型保证&lt;/h4&gt;&lt;p&gt;强类型的编程语言通常编译器自带一些类型检查，保证代码编译后不会出现类型方面的错误，比如 Rust 之类的甚至做了变量的生命周
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My org-mode stuff</title>
    <link href="http://chenyukang.github.io/2019/08/01/org_mode_stuff.html"/>
    <id>http://chenyukang.github.io/2019/08/01/org_mode_stuff.html</id>
    <published>2019-08-01T19:31:24.000Z</published>
    <updated>2021-07-02T15:36:31.143Z</updated>
    
    <content type="html"><![CDATA[<p> I switched to org-mode from EverNote recently, and the experience imrpoved much for note and journal writing, especially for technical notes. After the whole tool is set appropriately, I am even addicted to writing. During my setting up for org-mode and related tools, I found these code snippets are really handy, so let’s have a share.</p><h3 id="Insert-Pic-from-paste"><a href="#Insert-Pic-from-paste" class="headerlink" title="Insert Pic from paste"></a>Insert Pic from paste</h3><p> You need to install <strong>pngpaste</strong> first, then with this elisp function, we can copy the picture from paste very quickly, the picture will store on current directory’s img sub-directory, it will create it if img directory is not exists.</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> org-insert-image ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">path</span> (<span class="name">concat</span> default-directory <span class="string">"img/"</span>))</span><br><span class="line">         (<span class="name">image-file</span> (<span class="name">concat</span></span><br><span class="line">                      path</span><br><span class="line">                      (<span class="name">buffer-name</span>)</span><br><span class="line">                      (<span class="name">format-time-string</span> <span class="string">"_%Y%m%d_%H%M%S.png"</span>))))</span><br><span class="line">    (<span class="name">if</span> (<span class="name">not</span> (<span class="name">file-exists-p</span> path))</span><br><span class="line">        (<span class="name">mkdir</span> path))</span><br><span class="line">    (<span class="name">shell-command</span> (<span class="name">concat</span> <span class="string">"pngpaste "</span> image-file))</span><br><span class="line">    (<span class="name">org-insert-link</span> <span class="literal">nil</span> (<span class="name">concat</span> <span class="string">"file:"</span> image-file) <span class="string">""</span>))</span><br><span class="line">    <span class="comment">;; (org-display-inline-images) ;; show inline picture</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="Using-org-ruby-for-Hexo-publishing"><a href="#Using-org-ruby-for-Hexo-publishing" class="headerlink" title="Using org-ruby for Hexo publishing"></a>Using org-ruby for Hexo publishing</h3><p> I using Hexo for blogging, the default format is markdown in Hexo, so I need to convert org format to markdown format very conveniently, and finally org-ruby solve it. I did some dirty hacks on the codebase, <a href="https://github.com/chenyukang/org-ruby/pull/1/files" target="_blank" rel="noopener">please have a look at this PR</a>, this PR solve three issues.</p><ul><li>Add title and path attributes in org file, and the ruby script will extract it for dumping markdown file.</li><li>Fix the fill paragraph problem, I don’t need the blanks which will broken the paragraph layout.</li><li>Copy the images to proper directory for Hexo, support image size attributes.</li></ul><p> Then I added an elisp function for auto publish it after saving file whenever “#MD_TITLE:” is founded in buffer:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> org-publish-to-hexo ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">shell-command</span> (<span class="name">concat</span></span><br><span class="line">                  <span class="string">"org-ruby "</span> <span class="string">"--translate "</span> <span class="string">"markdown "</span> <span class="string">"-a "</span></span><br><span class="line">                  (<span class="name">buffer-name</span>))))</span><br><span class="line">(<span class="name">defalias</span> 'op 'org-publish-to-hexo)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> buffer-contains-substring (<span class="name">string</span>)</span><br><span class="line">  (<span class="name">save-excursion</span></span><br><span class="line">    (<span class="name">save-match-data</span></span><br><span class="line">      (<span class="name">goto-char</span> (<span class="name">point-min</span>))</span><br><span class="line">      (<span class="name">search-forward</span> string <span class="literal">nil</span> <span class="literal">t</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> org-auto-publish-save-hook ()</span><br><span class="line">  (<span class="name">when</span> (<span class="name">and</span> (<span class="name">eq</span> major-mode 'org-mode)</span><br><span class="line">             (<span class="name">buffer-contains-substring</span> <span class="string">"#+MD_TITLE:"</span>)</span><br><span class="line">             (<span class="name">buffer-contains-substring</span> <span class="string">"#+MD_PATH:"</span>))</span><br><span class="line">    (<span class="name">message</span> <span class="string">"publishing to Hexo markdown"</span>)</span><br><span class="line">    (<span class="name">org-publish-to-hexo</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> 'after-save-hook #'org-auto-publish-save-hook)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> org-before-save-hook ()</span><br><span class="line">  (<span class="name">when</span> (<span class="name">eq</span> major-mode 'org-mode)</span><br><span class="line">    (<span class="name">message</span> <span class="string">"saving org-file"</span>)</span><br><span class="line">    (<span class="name">pangu-spacing-space-current-buffer</span>)</span><br><span class="line">    <span class="comment">;;(fill-region (point-min) (point-max))</span></span><br><span class="line">    ))</span><br><span class="line">(<span class="name">add-hook</span> 'before-save-hook #'org-before-save-hook)</span><br></pre></td></tr></table></figure><h3 id="pangu-spacing"><a href="#pangu-spacing" class="headerlink" title="pangu-spacing"></a>pangu-spacing</h3><p> This package will add spacing between Chinese word and English word, so I hooked it before save org file:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'pangu-spacing)</span><br><span class="line">(<span class="name">global-pangu-spacing-mode</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;;(setq pangu-spacing-real-insert-separtor t)</span></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> org-before-save-hook ()</span><br><span class="line">  (<span class="name">when</span> (<span class="name">eq</span> major-mode 'org-mode)</span><br><span class="line">    (<span class="name">message</span> <span class="string">"saving org-file"</span>)</span><br><span class="line">    (<span class="name">pangu-spacing-space-current-buffer</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> 'before-save-hook #'org-before-save-hook)</span><br></pre></td></tr></table></figure><h3 id="org-capture"><a href="#org-capture" class="headerlink" title="org-capture"></a>org-capture</h3><p> And the best thing is org-capture, with this we can write all kinds of tempaltes, for journal writing, I need to generate file according to date and time:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> create-code-file ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">name</span> (<span class="name">concat</span> (<span class="name">format-time-string</span> <span class="string">"%Y_%m_%d_"</span>)</span><br><span class="line">                       (<span class="name">read-string</span> <span class="string">"file-name: "</span>))))</span><br><span class="line">    (<span class="name">expand-file-name</span> (<span class="name">format</span> <span class="string">"%s.org"</span> name) <span class="string">"~/Dropbox/org/snippets/"</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> gen-date-file ()</span><br><span class="line">  <span class="string">"Create an org file in ~/notes/snippets."</span></span><br><span class="line">  (<span class="name">format-time-string</span> <span class="string">"~/Dropbox/org/journals/%Y_%m_%d.org"</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> org-capture-templates</span><br><span class="line">      '((<span class="string">"t"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/work.org"</span>)</span><br><span class="line">         <span class="string">"** TODO %?\n  %i\n "</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"x"</span> <span class="string">"Task"</span> entry (file+datetree <span class="string">"~/Dropbox/org/work.org"</span>)</span><br><span class="line">         <span class="string">"** TODO %^&#123;priority|[#A]|[#B]|[#C]&#125; %?\n"</span>)</span><br><span class="line">        (<span class="string">"e"</span> <span class="string">"Task"</span> entry (file+datetree <span class="string">"~/Dropbox/org/life.org"</span>)</span><br><span class="line">         <span class="string">"** TODO %^&#123;priority|[#A]|[#B]|[#C]&#125; %?\n"</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"l"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/learn.org"</span>)</span><br><span class="line">         <span class="string">"** TODO %?\nEntered on %U\n  %i\n\n "</span> :kill-buffer <span class="literal">t</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"k"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/learn.org"</span>)</span><br><span class="line">         <span class="string">"* TODO %?\n  %i\n %f\n %a"</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"j"</span> <span class="string">"Journal"</span> entry (file+datetree <span class="string">"~/Dropbox/org/_journal.org"</span> )</span><br><span class="line">         <span class="string">"** %?\nEntered on %U\n  %i\n"</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"J"</span> <span class="string">"Journal"</span> entry (file gen-date-file)</span><br><span class="line">         <span class="string">"** %?\nEntered on %U\n  %i\n"</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"c"</span> <span class="string">"Code snippet"</span> entry (file+headline <span class="string">"~/Dropbox/org/_code.org"</span> <span class="string">"Code"</span>)</span><br><span class="line">         <span class="string">"** %^&#123;desc&#125;\n#+BEGIN_SRC %^&#123;language|ruby|shell|c|rust|emacs-lisp&#125;\n%?\n#+END_SRC"</span> </span><br><span class="line">          :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"C"</span> <span class="string">"Notes"</span> entry (file create-code-file)</span><br><span class="line">         <span class="string">"** %^&#123;desc&#125;\n#+BEGIN_SRC %^&#123;language|ruby|shell|c|rust|emacs-lisp&#125;\n%?\n#+END_SRC"</span> </span><br><span class="line">          :empty-lines <span class="number">1</span>)</span><br><span class="line">        ))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; I switched to org-mode from EverNote recently, and the experience imrpoved much for note and journal writing, especially for technical n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>满足感源自细节</title>
    <link href="http://chenyukang.github.io/2019/07/31/details_matter.html"/>
    <id>http://chenyukang.github.io/2019/07/31/details_matter.html</id>
    <published>2019-07-31T23:40:03.000Z</published>
    <updated>2021-07-02T15:36:31.139Z</updated>
    
    <content type="html"><![CDATA[<p>最近自我感觉生活质量提高了不少，并不是突然撞大运发大财了，总结下来居然都是一些小细节，奇怪正是这些小细节每次都会让我会心一笑。</p><p><img src="/images/2019_07_26.org_20190727_085906.png" width="70%" hegiht="70%" align="center"></p><h4 id="org-mode"><a href="#org-mode" class="headerlink" title="org-mode"></a>org-mode</h4><p>作为一个近十二年的 Emacs 用户，最近开始使用 org-mode 了。之前一直偶尔看到说什么单独为了org-mode 而花时间熟悉 Emacs 也是值得的，不过我一直没认真看，因为我认为在 Emacs 下不太适合大量编辑中文，快捷键太多在中文输入的过程中会有一些影响。</p><p>最近因为杂事比较多，我特别想要一个结合了日程管理和文档管理的软件。之前用过 Bear，这款软件的好处在于其编辑支持得特别好，但是 Bear 没有日程管理。后来又重新用回 EverNote，这东西的文字编辑支持有点弱，日程管理就是个最基本的清单。还有一些代码嵌入方面的问题，拷贝进去支持再拷贝出来居然其中嵌了部分中文符号。</p><p>最后我终于花了点时间来看看这个传说中的 org-mode 到底神奇在何处。结果真的符合了好香定律，我怎么不一开始用 Emacs 就着手用这呢，后悔万千！</p><p>其实不管日程管理也好，日志、技术笔记等也好，本质上都是文字。org-mode 的日程和笔记都是存储的最原始的文本格式，而 org-mode 的编辑模式类似 Bear，写起来非常容易上手。和 Markdown 类似属于「易读易写」的轻量级标签格式。</p><p>日程管理也有一些记录时间、统计时间，培养习惯的打卡类日程计划。配合 org-agenda 的各种视图，org-capture 的可定制的模板，用起来真是简洁而又迅速。自己再定制一些函数和脚本，实现从剪切板拷贝图片，使用修改过的 <a href="https://github.com/chenyukang/org-ruby/tree/block-version" target="_blank" rel="noopener">org-ruby</a> 自动从 org 转换为 Markdown，反正只要是文本其可塑性就非常强。</p><p><img src="/images/2019_07_26.org_20190727_003933.png" width="70%" hegiht="70%" align="center"></p><p>这才是对程序员最友好、最强大的文档和日程管理工具，<strong>其满足点在于『可定制』</strong>。</p><h4 id="全屏中小红点"><a href="#全屏中小红点" class="headerlink" title="全屏中小红点"></a>全屏中小红点</h4><p>当我开始大量使用 org-mode 记录之后，就不可避免地需要在全屏的 Emacs 下输入中文。而这经常会被打乱，总结一下发现其实是因为全屏状态下我经常会不知道目前是否启用了中文输入法。全屏模式下看不到输入法的任何图标，Baidu 的 Mac 输入法这个浮动状态栏不会在 Emacs 全屏的模式下显示，而且那个辐条本身看起来也太占空间了。在没有图标的情况下只有靠 Shift 或者 Ctrl blank 瞎切换了，非常让人厌烦。</p><p>这个困扰很久的问题最近也终于解决了， 这个 <a href="https://github.com/tekezo/ShowyEdge" target="_blank" rel="noopener">ShowEdge</a> 工具可以根据不同的输入法，配置不同的颜色，而且在任何全屏状态都根据输入法显示颜色。我的屏幕顶部就配置了这么一个小红点：</p><p><img src="/images/CAPTURE-2019_07_26.org_20190727_000238.png" alt="file:img/CAPTURE-2019_07_26.org_20190727_000238.png"></p><p>从此输入中文的体验大幅提高！虽然这是非常细节的一个地方，但是当你想到折磨自己的问题，其他人也关注到了，并且用了极其符合自己使用习惯的开源软件解决了，顿时觉得世界真美好！</p><p><strong>这里的满足点在于『可控性』</strong>。</p><h4 id="黑暗中的黄色光"><a href="#黑暗中的黄色光" class="headerlink" title="黑暗中的黄色光"></a>黑暗中的黄色光</h4><p>这东西犹如黑暗中的萤火虫，让人温暖，哈哈，其实就是小米的一款感应夜灯。我对小米的这种小的智能家电比较感兴趣，比如小爱同学也不错。这款夜灯的好处在于自动感应，进洗手间自己就亮，我每次都是比较晚才去洗漱刷牙，这灯不太亮也不太暗，而且可以根据声音、移动、和自然光亮度自动开关。其实功能很简单，符合软件设计中的哲学：专注唯一功能，但是功能做到极致。</p><p><img src="/images/2019_07_26.org_20190727_004316.png" width="350" hegiht="400" align="center"></p><p><strong>这应该是简单地满足了『确定性』的心理需求</strong>，为什么像语音助手这类东西虽然看起来比较炫酷，但用的人并不多，因为语音识别在日常使用过程中还是会存在各种干扰，最终造成使用过程中存在一些不确定性，从而影响了根本的使用体验。</p><p>Entered on [2019-07-26 五 23:31]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近自我感觉生活质量提高了不少，并不是突然撞大运发大财了，总结下来居然都是一些小细节，奇怪正是这些小细节每次都会让我会心一笑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_07_26.org_20190727_085906.png&quot; width=&quot;70%&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>保存 kmacro </title>
    <link href="http://chenyukang.github.io/2019/06/23/2019-06-23-random-notes.html"/>
    <id>http://chenyukang.github.io/2019/06/23/2019-06-23-random-notes.html</id>
    <published>2019-06-23T23:48:42.000Z</published>
    <updated>2021-07-02T15:36:31.135Z</updated>
    
    <content type="html"><![CDATA[<p>宏是很强大的编辑方法，如果要长久保存一些宏可以使用下面的办法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">M-x start-kbd-macro</span><br></pre></td></tr></table></figure><p>开始记录宏，通常快捷键为”C-x (“, 结束的快捷键为 “C-x )”。</p><p> 然后使用命令: </p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">M-x kmacro-name-last-macro</span><br></pre></td></tr></table></figure><p>  可以把这条宏给命名，如果要保存这个宏以便日后使用，需要打开 init.el 继续使用命令： </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">M-x insert-kbd-macro</span><br></pre></td></tr></table></figure><p>选中命名的宏，这样就在 init.el 里面插入了刚才的宏，这个名字也就可以当作日常命令使用了。</p><p>例如我新建一个宏，作用是查找测试文件中的 “#[ignore]”，并删除掉那行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(fset &apos;rust-ignore</span><br><span class="line">      (lambda (&amp;optional arg) &quot;Keyboard macro.&quot; (interactive &quot;p&quot;)</span><br><span class="line">        (kmacro-exec-ring-item</span><br><span class="line">         (quote ([12 115 101 97 114 99 104 return 35 91 105 103 110 111 114 101 return 1 11 11 14] 0 &quot;%d&quot;)) arg)))</span><br></pre></td></tr></table></figure><p>如果要重复执行，则需要运行： </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C-x z</span><br></pre></td></tr></table></figure><p>当然后面可以连续按 z z z …. ， 执行多遍。</p><p> 参考: <a href="https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function" target="_blank" rel="noopener">https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宏是很强大的编辑方法，如果要长久保存一些宏可以使用下面的办法：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;M-x start-kbd-mac
      
    
    </summary>
    
    
      <category term="Notes" scheme="http://chenyukang.github.io/tags/Notes/"/>
    
      <category term="Emacs" scheme="http://chenyukang.github.io/tags/Emacs/"/>
    
  </entry>
  
</feed>
