<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yukang&#39;s Page</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chenyukang.github.io/"/>
  <updated>2021-07-02T15:36:31.143Z</updated>
  <id>http://chenyukang.github.io/</id>
  
  <author>
    <name>Yukang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>案例分析-程序员如何站着赚钱</title>
    <link href="http://chenyukang.github.io/2020/10/27/programmer-out-of-normal-job.html"/>
    <id>http://chenyukang.github.io/2020/10/27/programmer-out-of-normal-job.html</id>
    <published>2020-10-27T21:57:00.000Z</published>
    <updated>2021-07-02T15:36:31.143Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://twitter.com/dvassallo" target="_blank" rel="noopener">Daniel Vassallo</a> 是我最近一年都在关注的一个推特用户，我几乎看了他发的所有 Twitter 和文章。</p><p>这位程序员去年离开了亚马逊的一份轻松而多金的工作。他在亚马逊干了 8 年，尽管不断获得晋升、薪酬、表彰和表扬等奖励，薪水从 7.5w 刀一路涨到 50w 刀，但他没有足够的动力再干一年。</p><p>至于为什么离开亚马逊，他写了一篇很好的文章来解释：<a href="https://danielvassallo.com/only-intrinsic-motivation-lasts/" target="_blank" rel="noopener">只有内在动力才能持续</a>.</p><p>主要原因是随着级别的提高，工作的自由度减少了，得平衡各方利益，说服其他人来完成特定的目标。这很正常，在大公司工作有很多固有的限制，关于如何做工作，做什么工作，设定什么目标，以及什么业务值得追求。很多时候会迫使我们去做不想做的事情，而想做的可能也无法施展。</p><p>总之，在公司赚钱肯定是比较稳定，收入也不错。只是时间、精神上谈不上自由。为大公司工作是一种稳定的状态，就像是围城一样。</p><p>如何站着把钱挣了？</p><h2 id="什么动力才能持久？"><a href="#什么动力才能持久？" class="headerlink" title="什么动力才能持久？"></a>什么动力才能持久？</h2><p>动力分为<em>外部动力</em>和<em>内部动力</em>：</p><p>外部动力可以称之为棒子或者萝卜。举例来说，缴税是棒子，虽然我们不想做，但是必须得完成。为了买一辆豪车，努力加班加点赚钱，这就是萝卜。两者都是外在因素迫使我们不断地有『动力』去执行。</p><p>内部动力是持久动力，就是自己心甘情愿去做，并且乐于其中。这位程序员的兴趣在于写代码，卖自己的作品。而互联网时代就是最好的舞台，个人可以专注于自己专业领域，完成自己的作品，并获取关注和收入。当然最重要的是作品的质量，以及推销的手法。</p><h2 id="找到自己的切入点"><a href="#找到自己的切入点" class="headerlink" title="找到自己的切入点"></a>找到自己的切入点</h2><p>通过自己的作品来赚钱，听起来很简单，但实现起来难度其实是巨大的。</p><p>辞职后开始做的一个项目叫做 <a href="https://userbase.com/" target="_blank" rel="noopener">Userbase</a>， 为静态网站增加持久化存储。另外开始和朋友做的是一本电子书：<a href="https://gumroad.com/l/aws-good-parts/dv" target="_blank" rel="noopener">The Good Parts of AWS</a>。售价25美金一份。10个月总共花费 3w 多美金推广，收入 25w 美金。</p><p><img src="/images/image-20201030073721363.png" alt="image-20201030073721363"></p><p>这本电子书包含一些经验性的东西，对基于 AWS 做技术架构的人挺有用的。对于在 AWS 上工作了10多年的人写出这样一本小册子肯定是不难的，但是难的是如何做推广。</p><p>这也是作者做得挺好的一点，在 Twitter 上经营固定的读者。他每天都会发一些作为 Indie 的一些感想，关于工作、生活、经济、创业方面的。14 个月时间从 150 的 follower 涨到了 49000 多。他经常会把一些自己项目的数据贴出来给大家分享，这样显得特别真实、真诚。这种推广套路营造出一种类似《楚门的世界》的观感效果，读者看着他从第一天辞职，然后不断经营自己的项目，就会有动力一直去关注后面的进展。</p><p>然后作者把自己最近一年左右的 Twitter 推广实践经验又录成了视频： <a href="https://gumroad.com/l/twitter-audience/dv" target="_blank" rel="noopener">Everyone Can Build a Twitter Audience</a>， 售价 50 美金。这一连贯手法真是越来越溜了。</p><p>当然，除了营销外之外能力是最重要的，这位同志的写作能力一流。可以从第一篇辞职撰文可以看出，用词、表达清晰有据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有人可能认为，这赚得看起来还没他自己上班多啊！</p><p>但是，为自己工作的自由度、成就感、安全感是完全不同的，而且这还只是一个开始。</p><p>很多人丢掉了自己的全职工作之后，完全不知道如何打造自己的另外一份收入，陷入等米下锅的状态。总结起来都是很简单的道理，只是做到的人很少：</p><ul><li>跳出自己的舒适区，向自己期望的生活方式改变</li><li>找到自己的兴趣点和优势，寻找自己能满足的实际需求</li><li>相信时间的复利效应，做有积累的事情</li><li>付费意识还是挺重要的，这点不可否认英文环境相对来说会更好一些</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://twitter.com/dvassallo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Daniel Vassallo&lt;/a&gt; 是我最近一年都在关注的一个推特用户，我几乎看了他发的所有 Twitter 和文章。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DHH - 关于软件开发的少数派</title>
    <link href="http://chenyukang.github.io/2020/10/10/dhh-on-software-dev.html"/>
    <id>http://chenyukang.github.io/2020/10/10/dhh-on-software-dev.html</id>
    <published>2020-10-10T22:50:38.000Z</published>
    <updated>2021-07-02T15:36:31.139Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/" target="_blank" rel="noopener">David Heinemeier Hansson, Software Contrarian</a> 是 Podcast 频道 corecursive 在 2020.2.1 发布的一个 DHH 关于软件开发相关的访谈。</p><p>DHH 不用介绍了，Rails 创始人。</p><p>可以说之前 Ruby 的流行很大程度上依赖于 Rails 的兴起。Rails 确实影响了很多后来的 Web 框架的设计和实现，并给软件开发带了一些全新的理念。</p><p>这期是我之前当作练习英语的材料来听的。DHH 的口音非常清晰，表达方式也是非常直接。因此这期听起来有一种类似 Rap 的快感。</p><p><img src="/images/2020_10_01_dhh-software-contrarian.org_20201009_220930.png" alt="file:img/2020_10_01_dhh-software-contrarian.org_20201009_220930.png"></p><h2 id="为什么-Rails-成功了"><a href="#为什么-Rails-成功了" class="headerlink" title="为什么 Rails 成功了"></a>为什么 Rails 成功了</h2><p>Rails 的出现改变了软件开发，至少在 2006 年，当 Java，C# 大行其道的年代。Rails 以其优异的开发效率震惊了不少开发者。Rails 的成功无非是在恰好的时机做了恰当的事情。</p><p>DHH 总结了从 Java、PHP 的开发经验。Java 阵营里都是聪明人，有很多好想法，但是他们却在一个糟糕的开发环境里工作，不容易让新人轻易上手。而 PHP 却很简单明了，你直接把一个文件拖入特定的文件夹，就可以生成对应的网页。Rails 的第三个元素就是 Ruby，Ruby 是极其容易安装，容易上手而直接的编程语言。DHH 当时正在写 Basecamp，所以一切都是从实际使用出发的，自己构建工具，然后再用这个工具构建 Basecamp。</p><p>而且 DHH 当时也是一个 Ruby 新手(那时的 Ruby 老手估计也没几个?)</p><p>新手的好处在于，他不知道 Ruby 的极限在哪里，哪里可能面临挑战。这样可以随着自己的性子，满足自己的期望来构建 Rails 了。在写 Rails 的过程中，DHH 更关注的是作为用户的感受是什么？编程就像是做菜一样，厨子需要关注的色香味俱全。</p><p>Ruby 最大的洞见是: 程序员不仅仅是程序员，同时也是人。</p><p>依据这个原则，在设计 Ruby 中最重要的事情和设计标准就是：编程语言使程序员更快乐。</p><h2 id="最开始如何开始接触-Ruby"><a href="#最开始如何开始接触-Ruby" class="headerlink" title="最开始如何开始接触 Ruby"></a>最开始如何开始接触 Ruby</h2><p>Ruby 是日本人 Matz 于 1995。但是直到 2003，这门编程语言仍然是非常小众而神秘的。DHH 也是那段时间在看到些 Martin Fowler 和 Dave Thomas 写的技术文章，他们俩个都选择了 Ruby 作为编程语言介绍一些概念。这引起了 DHH 的兴趣，所以开始关注 Ruby，并去参加了 Ruby 2004 Conf。</p><p>那届 Conf 大约也就 42 人吧….</p><p>但是随后几年的 Rails Conf 就开始有 2500 人了。</p><h2 id="关于编程语言的选择"><a href="#关于编程语言的选择" class="headerlink" title="关于编程语言的选择"></a>关于编程语言的选择</h2><p><strong>很多程序员因为喜欢上编程，就是刚好碰到了符合自己口味的编程语言，并激发对编程的巨大乐趣</strong>。所以，语言的选择说不重要也不对。如果你还没找到自己的最爱，继续尝试吧。</p><p>但并不意味着，在一个小众的编程语言过多投资可能会带来其他的回报。语言的流行有很多其他的因素。Rails 的初衷并不是完全用来满足自己的创造轮子的快感的，而是依据自己的实际项目出发的。</p><p>这给我们的不错启示：从实际的需求出发，使用新的工具造轮子。</p><h2 id="关于微服务的吐槽"><a href="#关于微服务的吐槽" class="headerlink" title="关于微服务的吐槽"></a>关于微服务的吐槽</h2><p>DHH 对微服务保持否定态度，认为业界这么流行微服务其实是有害的。</p><p>大多数情况下，一个人可以完全理解、部署的单一应用，比微服务更容易维护。</p><p>微服务的优势在于，如果团队足够地大，我们需要给开发者一些界限。</p><p>不要盲目地沿用大公司的套路，因为解决的问题不同！</p><h2 id="关于-TDD"><a href="#关于-TDD" class="headerlink" title="关于 TDD"></a>关于 TDD</h2><p>TDD 也是 Rails 社区很流行和推崇的，但是 DHH 其实对此并不太感冒。并不是 TDD 就能写出更好的，更健壮的软件。</p><p>事先写测试用例还是事后写并不重要，重要的是自动化测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://corecursive.com/045-david-heinemeier-hansson-software-contrarian/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;David Heinemeier Hanss
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络相关</title>
    <link href="http://chenyukang.github.io/2020/09/08/networking-notes.html"/>
    <id>http://chenyukang.github.io/2020/09/08/networking-notes.html</id>
    <published>2020-09-08T20:59:08.000Z</published>
    <updated>2021-07-02T15:36:31.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h1><p>分为递归解析和迭代解析</p><p><a href="https://blog.csdn.net/lycb_gz/article/details/11720247" target="_blank" rel="noopener">https://blog.csdn.net/lycb_gz/article/details/11720247</a></p><h1 id="APR-欺骗"><a href="#APR-欺骗" class="headerlink" title="APR 欺骗"></a>APR 欺骗</h1><p>ARP 欺骗是一种在局域网中常用的攻击手段，目的是让局域网中指定的（或全部）的目标机器的数据包都通过攻击者主机进行转发，是实现中间人攻击的常用手段，从而实现数据监听、篡改、重放、钓鱼等攻击方式。</p><h1 id="TCP-IP-报文长度和格式"><a href="#TCP-IP-报文长度和格式" class="headerlink" title="TCP/IP 报文长度和格式"></a>TCP/IP 报文长度和格式</h1><p>IP 头部信息：头部长度：通常 20 字节，有选项时更长，总共不超过 60 字节。IP 数据报长度：65535 字节。</p><p><img src="/images/networking.org_20190731_120051.png" width="70%" hegiht="70%" align="center"></p><p>TCP 协议，在传输层。特点：可靠性。通过连接管理（三握四挥），序列号，确认号，拥塞控制，重传控制来保证可靠性。头部长度：一般为 20 字节，选项最多 40 字节，限制 60 字节。</p><p><img src="/images/networking.org_20190731_120147.png" width="60%" hegiht="60%" align="center"></p><h1 id="TCP-最大报文长度-MSS"><a href="#TCP-最大报文长度-MSS" class="headerlink" title="TCP 最大报文长度 (MSS)"></a>TCP 最大报文长度 (MSS)</h1><p><a href="https://blog.csdn.net/codejoker/article/details/5437141" target="_blank" rel="noopener">https://blog.csdn.net/codejoker/article/details/5437141</a></p><p>TCP 提供的是一种面向连接的，可靠的字节流服务，TCP 提供可靠性的一种重要的方式就是 MSS。通过MSS，应用数据被分割成 TCP 认为最适合发送的数 据块，由 TCP 传递给 IP 的信息单位称为报文段或段(segment)。代表一个 TCP socket 的结构体 struct tcp_sock 中有多个成员用于确定应用数据被分割成最大为多大的数据块较为合适(最大报文段长度 MSS)。我们不难联想到，跟最大报文段长度最为相关的一个参数是网络设备接口的 MTU，以太网的 MTU 是 1500，基本 IP 首部长度为 20，TCP 首部是20，所 以 MSS 的值可达 1460(MSS 不包括协议首部，只包含应用数据)。</p><p>本地以太网中 MSS 为 1460 的说法并不正确，它还会动态变化，如果 IP 首部和 TCP 首部中出现选项，则 MSS 要相应的减小，一般 TCP 首部中会 有 12 字节的时间戳选项(外加两字节的填充选项)，这时的 MSS 就等于 1448。MSS 的主要作用是限制另一端主机发送的数据的长度，同时，主机本身也控制自己发送数据报的长度，这将使以较小 MTU 连接到一个网络上的主机避免分段。</p><h1 id="如果使用-TCP-希望传输一个复杂的对象应该怎么传输？"><a href="#如果使用-TCP-希望传输一个复杂的对象应该怎么传输？" class="headerlink" title="如果使用 TCP 希望传输一个复杂的对象应该怎么传输？"></a>如果使用 TCP 希望传输一个复杂的对象应该怎么传输？</h1><p>TCP 中的流是指流入进程或者从进程中流出的字节序列。所以向 Java/golang 等高级语言在进行 TCP通信是都需要将相应的实体序列化才能进行传输。</p><h1 id="TCP-IP-中如何解决粘包问题？如果一直传输数据怎么拆包"><a href="#TCP-IP-中如何解决粘包问题？如果一直传输数据怎么拆包" class="headerlink" title="TCP/IP 中如何解决粘包问题？如果一直传输数据怎么拆包?"></a>TCP/IP 中如何解决粘包问题？如果一直传输数据怎么拆包?</h1><p>应用层协议，不管是标准的还是自己定义的。“粘包”问题是伪问题。</p><p><a href="http://www.hchstudio.cn/article/2018/d5b3/" target="_blank" rel="noopener">http://www.hchstudio.cn/article/2018/d5b3/</a></p><p><a href="https://img.hchstudio.cn/TCP.gif" target="_blank" rel="noopener">https://img.hchstudio.cn/TCP.gif</a></p><h1 id="TCP-连接和断开的状态图"><a href="#TCP-连接和断开的状态图" class="headerlink" title="TCP 连接和断开的状态图"></a>TCP 连接和断开的状态图</h1><p>connect:</p><p><img src="/images/networking.org_20190802_115508.png" width="60%" hegiht="60%" align="center"></p><p>disconnect:</p><p><img src="/images/networking.org_20190802_115604.png" width="60%" hegiht="60%" align="center"></p><p>为什么 TCP 连接断开的时候要<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">进行四次握手</a>：</p><h1 id="TCP-四次挥手的-TIME-WAIT"><a href="#TCP-四次挥手的-TIME-WAIT" class="headerlink" title="TCP 四次挥手的 TIME_WAIT"></a>TCP 四次挥手的 TIME_WAIT</h1><p>时间段长为 2MSL（报文段最大生存时间）</p><ul><li>TIME_WAIT 存在的理由之一是尽可能护送最后的 ACK 达到对端，保证可靠地终止 TCP 链接。</li><li>假设 tcp 连接是： A(1.2.3.4:8888)——B(6.7.8.9:9999), 这就是一个 tcp 四元组。当 tcp 连接关闭后， 四元组释放。TIME_WAIT 存在的理由之二是新旧四元组互不干扰。</li></ul><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC（Remote Procedure Call）—远程过程调用 ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 协议假定某些传输协议的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发分布式程序就像开发本地程序一样简单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS-域名解析&quot;&gt;&lt;a href=&quot;#DNS-域名解析&quot; class=&quot;headerlink&quot; title=&quot;DNS 域名解析&quot;&gt;&lt;/a&gt;DNS 域名解析&lt;/h1&gt;&lt;p&gt;分为递归解析和迭代解析&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员如何提高英文写作</title>
    <link href="http://chenyukang.github.io/2019/11/07/improve-english-writing-as-progammer.html"/>
    <id>http://chenyukang.github.io/2019/11/07/improve-english-writing-as-progammer.html</id>
    <published>2019-11-07T08:45:53.000Z</published>
    <updated>2021-07-02T15:36:31.139Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个月坚持了一段时间英文写作，兴趣和自信心都大为增强。为什么突然想锻炼自己的英文写作能力呢，是因为工作中要写个什么英文的白皮书，然后发现懂技术的不太会写，会写英文的不太懂技术。最后找了团队中的一个留学生帮忙，大家跌跌撞撞把工作完成了。仔细想想这就是稀缺能力啊，按照刻意练习的套路，我应该好好提高一下自己的英文写作能力。</p><p><img src="/images/image-20191107195802111.png" alt="image-20191107195802111"></p><p>然后，我就开始在一些社区，比如 dev.to 写技术文章，在 Quora 上回答问题等，这些坚持了两个月左右，自我感觉收获不少。至少，现在让我写一篇英文类的长文，我是好无压力并且有些享受的(可能还处于自我感觉良好的时期的缘故)。</p><p>下面总结一下关于英文写作的一些自我心得。 </p><h2 id="抛去恐惧心理"><a href="#抛去恐惧心理" class="headerlink" title="抛去恐惧心理"></a>抛去恐惧心理</h2><p>这是很多人要克服的第一关，想着中文都写不溜，英文如何写？写作这个东西就是需要不断练习的，即使文笔不行，首先要做到的是写出来，并且简明扼要。文章最重要的目的是表达自己，并且让人易懂，更高的要求才是让人产生读的乐趣。对于绝大部分科技类的写作来说，准确是第一要素。 </p><p>如何抛去恐惧心理？唯一的办法就是多读、多写，并且让大家看，收集反馈然后不断改进。 </p><h2 id="在哪里写"><a href="#在哪里写" class="headerlink" title="在哪里写"></a>在哪里写</h2><p>像我刚才说的，有很多不错的技术社区，比如 Github、StackOverflow、Quora, 这些都是英文表达的场所，也是一个很好的锻炼自己英文写作的平台。从小处开始，可以写一个英文的 README，代码中使用良好的英文注释？在 Quora 上回答问题是更好的方式，因为这是一个互动的平台，你的回答会被多个人看到，这样可能会有一些反馈。</p><p>比如这个找 Quora 里的回答，题主问的是学习编程是否需要很多数据技巧？这对于我们这样的多年程序员来说，自然是有一些心得的，然后我就写了一些自己的想法作为回答。后面有一位朋友写了另外一个回答： </p><p>“题主，数学技能是次要的，你应该好好学学英文写作，这样至少不会让你像上面这位回答者这一样犯一些低级的错误。” </p><p>没多久我就看到了这条回答，然后看了看自己真的是犯了一些很明显的语法错误，修正后再回复了一下这位朋友，他表示自己也有点刻薄了，哈哈。其实大家对这种“助人助己”的学习方法是很乐于接受的，只要是给社区提供有用的东西。 </p><p><img src="/images/pic3.png" alt="pic3"></p><p>在 Quora 上还碰到另外一个瑞典的伙计，也帮我提出了一些建议。然后第二天还帮我一句一句做了一个修改版本，发到了我的邮箱。英语不是母语的人写的文章，如果不是让英语为第一语言的朋友阅读，这些表达方面的问题是不容易看出来的。</p><p><img src="/images/image-20191107194028413.png" alt="image-20191107194028413"></p><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h3><p>很多人对于自己的词汇量没有信心，觉得词汇量不够不足以表达自己的想法。这是不对的，其实你看看大部分技术类英文文章，对于接受过大学教育的技术人人员来说，应该是 95% 以上的单词都是认识的。对于不认识的单词来说也可以根据上下文来推测的，所以至少词汇不会构成阅读障碍。对于英文写作来说，基于简明表达自己的要求，我们那点四六级词汇也很够玩的。词汇在于平时积累，我现在也在着重注意积累一些词汇。日常使用过程中，多注意一些应文的惯用词汇。有一个 Chrome 插件叫做“单词小卡片”，可以把日常浏览网页的过程中发现的不太熟悉的单词加入列表，可以日后以便回顾。 </p><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p><img src="/images/pic1.png" alt="pic1"></p><p>阅读和写作是分不开的，只有多读才会发现更多套路。上面提到的那些社区都有很多不错的英文内容可以读，另外要特别提到一个的是 medium.com，类比为国内的简书。不过个人感觉质量比简书的内容好很多，可能是我阅读了付费内容的缘故。这个付费也挺便宜的，一个月 5 美金。 </p><p>作为程序员，另外要多阅读就是技术类的书籍。这些年我买了不少英文类的技术书籍，大多是翻过的，而且有少部分是精读完了。其实只要你能坚持阅读完一本 300 页左右的技术书籍，第二本就很简单了。如果是非技术类的英文文章，要数量阅读就需要提高词汇。 </p><h3 id="撰写"><a href="#撰写" class="headerlink" title="撰写"></a>撰写</h3><p>其实写作无非是表达自己，中文和英文写作有很多都是相通的。 </p><p>撰写过程中需要时刻明白，写的东西是给其他人看的。所以排版也很很重要，如果文章比较长，需要让人看得不至于疲累。适当地配一些贴近情景的图片也非常有助于提高可读性。段落要分明，不要某些段落太长。</p><p>最后，即使是英语是母语的人也很容一些常见的语法错误。所以我们需要工具来减少这类问题，grammarly.com 就是非常有用的工具，即使是免费版本对于日常使用来说也是足够了的。 </p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>不断练习，收集反馈，持续改进。唯此而已。 有两本书可以看看。</p><ol><li><a href="https://book.douban.com/subject/27122346/" target="_blank" rel="noopener">《七十二堂写作课》</a></li><li><a href="https://book.douban.com/subject/1451400/" target="_blank" rel="noopener">《风格的要素》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近几个月坚持了一段时间英文写作，兴趣和自信心都大为增强。为什么突然想锻炼自己的英文写作能力呢，是因为工作中要写个什么英文的白皮书，然后发现懂技术的不太会写，会写英文的不太懂技术。最后找了团队中的一个留学生帮忙，大家跌跌撞撞把工作完成了。仔细想想这就是稀缺能力啊，按照刻意练
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C 语言的 typecheck</title>
    <link href="http://chenyukang.github.io/2019/08/06/type_check_in_c.html"/>
    <id>http://chenyukang.github.io/2019/08/06/type_check_in_c.html</id>
    <published>2019-08-06T01:31:18.000Z</published>
    <updated>2021-07-02T15:36:31.147Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类型保证"><a href="#类型保证" class="headerlink" title="类型保证"></a>类型保证</h4><p>强类型的编程语言通常编译器自带一些类型检查，保证代码编译后不会出现类型方面的错误，比如 Rust 之类的甚至做了变量的生命周期检查，以防止内存出错或者未定义行为。常见的变成语言类型如下：</p><p><img src="/images/2019_08_06.org_20190806_012652.png" width="70%" hegiht="70%" align="center"></p><h4 id="typecheck"><a href="#typecheck" class="headerlink" title="typecheck"></a>typecheck</h4><p> 但是 C 为弱类型语言，弱类型语言，类型检查更不严格，如偏向于容忍隐式类型转换。譬如说 C 语言的 int 可以变成 double。 这样的结果是：容易产生 forbidden behaviours。为了解决类似问题，Linux 内核中的这个宏比较有技巧。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> typecheck(type,x)                       \</span></span><br><span class="line">  (&#123;  type __dummy;                             \</span><br><span class="line">  typeof(x) __dummy2;                           \</span><br><span class="line">  (<span class="keyword">void</span>)(&amp;__dummy == &amp;__dummy2);                \</span><br><span class="line">  <span class="number">1</span>;                                            \</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p> 使用的时候可以保证某些变量为特定的类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">typecheck(<span class="keyword">char</span>, a);</span><br></pre></td></tr></table></figure><p> 这样就会报出一个编译错误：</p><p><img src="/images/2019_08_06.org_20190806_011627.png" width="70%" hegiht="70%" align="center"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类型保证&quot;&gt;&lt;a href=&quot;#类型保证&quot; class=&quot;headerlink&quot; title=&quot;类型保证&quot;&gt;&lt;/a&gt;类型保证&lt;/h4&gt;&lt;p&gt;强类型的编程语言通常编译器自带一些类型检查，保证代码编译后不会出现类型方面的错误，比如 Rust 之类的甚至做了变量的生命周
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My org-mode stuff</title>
    <link href="http://chenyukang.github.io/2019/08/01/org_mode_stuff.html"/>
    <id>http://chenyukang.github.io/2019/08/01/org_mode_stuff.html</id>
    <published>2019-08-01T19:31:24.000Z</published>
    <updated>2021-07-02T15:36:31.143Z</updated>
    
    <content type="html"><![CDATA[<p> I switched to org-mode from EverNote recently, and the experience imrpoved much for note and journal writing, especially for technical notes. After the whole tool is set appropriately, I am even addicted to writing. During my setting up for org-mode and related tools, I found these code snippets are really handy, so let’s have a share.</p><h3 id="Insert-Pic-from-paste"><a href="#Insert-Pic-from-paste" class="headerlink" title="Insert Pic from paste"></a>Insert Pic from paste</h3><p> You need to install <strong>pngpaste</strong> first, then with this elisp function, we can copy the picture from paste very quickly, the picture will store on current directory’s img sub-directory, it will create it if img directory is not exists.</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> org-insert-image ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">path</span> (<span class="name">concat</span> default-directory <span class="string">"img/"</span>))</span><br><span class="line">         (<span class="name">image-file</span> (<span class="name">concat</span></span><br><span class="line">                      path</span><br><span class="line">                      (<span class="name">buffer-name</span>)</span><br><span class="line">                      (<span class="name">format-time-string</span> <span class="string">"_%Y%m%d_%H%M%S.png"</span>))))</span><br><span class="line">    (<span class="name">if</span> (<span class="name">not</span> (<span class="name">file-exists-p</span> path))</span><br><span class="line">        (<span class="name">mkdir</span> path))</span><br><span class="line">    (<span class="name">shell-command</span> (<span class="name">concat</span> <span class="string">"pngpaste "</span> image-file))</span><br><span class="line">    (<span class="name">org-insert-link</span> <span class="literal">nil</span> (<span class="name">concat</span> <span class="string">"file:"</span> image-file) <span class="string">""</span>))</span><br><span class="line">    <span class="comment">;; (org-display-inline-images) ;; show inline picture</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="Using-org-ruby-for-Hexo-publishing"><a href="#Using-org-ruby-for-Hexo-publishing" class="headerlink" title="Using org-ruby for Hexo publishing"></a>Using org-ruby for Hexo publishing</h3><p> I using Hexo for blogging, the default format is markdown in Hexo, so I need to convert org format to markdown format very conveniently, and finally org-ruby solve it. I did some dirty hacks on the codebase, <a href="https://github.com/chenyukang/org-ruby/pull/1/files" target="_blank" rel="noopener">please have a look at this PR</a>, this PR solve three issues.</p><ul><li>Add title and path attributes in org file, and the ruby script will extract it for dumping markdown file.</li><li>Fix the fill paragraph problem, I don’t need the blanks which will broken the paragraph layout.</li><li>Copy the images to proper directory for Hexo, support image size attributes.</li></ul><p> Then I added an elisp function for auto publish it after saving file whenever “#MD_TITLE:” is founded in buffer:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> org-publish-to-hexo ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">shell-command</span> (<span class="name">concat</span></span><br><span class="line">                  <span class="string">"org-ruby "</span> <span class="string">"--translate "</span> <span class="string">"markdown "</span> <span class="string">"-a "</span></span><br><span class="line">                  (<span class="name">buffer-name</span>))))</span><br><span class="line">(<span class="name">defalias</span> 'op 'org-publish-to-hexo)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> buffer-contains-substring (<span class="name">string</span>)</span><br><span class="line">  (<span class="name">save-excursion</span></span><br><span class="line">    (<span class="name">save-match-data</span></span><br><span class="line">      (<span class="name">goto-char</span> (<span class="name">point-min</span>))</span><br><span class="line">      (<span class="name">search-forward</span> string <span class="literal">nil</span> <span class="literal">t</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> org-auto-publish-save-hook ()</span><br><span class="line">  (<span class="name">when</span> (<span class="name">and</span> (<span class="name">eq</span> major-mode 'org-mode)</span><br><span class="line">             (<span class="name">buffer-contains-substring</span> <span class="string">"#+MD_TITLE:"</span>)</span><br><span class="line">             (<span class="name">buffer-contains-substring</span> <span class="string">"#+MD_PATH:"</span>))</span><br><span class="line">    (<span class="name">message</span> <span class="string">"publishing to Hexo markdown"</span>)</span><br><span class="line">    (<span class="name">org-publish-to-hexo</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> 'after-save-hook #'org-auto-publish-save-hook)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> org-before-save-hook ()</span><br><span class="line">  (<span class="name">when</span> (<span class="name">eq</span> major-mode 'org-mode)</span><br><span class="line">    (<span class="name">message</span> <span class="string">"saving org-file"</span>)</span><br><span class="line">    (<span class="name">pangu-spacing-space-current-buffer</span>)</span><br><span class="line">    <span class="comment">;;(fill-region (point-min) (point-max))</span></span><br><span class="line">    ))</span><br><span class="line">(<span class="name">add-hook</span> 'before-save-hook #'org-before-save-hook)</span><br></pre></td></tr></table></figure><h3 id="pangu-spacing"><a href="#pangu-spacing" class="headerlink" title="pangu-spacing"></a>pangu-spacing</h3><p> This package will add spacing between Chinese word and English word, so I hooked it before save org file:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'pangu-spacing)</span><br><span class="line">(<span class="name">global-pangu-spacing-mode</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;;(setq pangu-spacing-real-insert-separtor t)</span></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> org-before-save-hook ()</span><br><span class="line">  (<span class="name">when</span> (<span class="name">eq</span> major-mode 'org-mode)</span><br><span class="line">    (<span class="name">message</span> <span class="string">"saving org-file"</span>)</span><br><span class="line">    (<span class="name">pangu-spacing-space-current-buffer</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> 'before-save-hook #'org-before-save-hook)</span><br></pre></td></tr></table></figure><h3 id="org-capture"><a href="#org-capture" class="headerlink" title="org-capture"></a>org-capture</h3><p> And the best thing is org-capture, with this we can write all kinds of tempaltes, for journal writing, I need to generate file according to date and time:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> create-code-file ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">name</span> (<span class="name">concat</span> (<span class="name">format-time-string</span> <span class="string">"%Y_%m_%d_"</span>)</span><br><span class="line">                       (<span class="name">read-string</span> <span class="string">"file-name: "</span>))))</span><br><span class="line">    (<span class="name">expand-file-name</span> (<span class="name">format</span> <span class="string">"%s.org"</span> name) <span class="string">"~/Dropbox/org/snippets/"</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> gen-date-file ()</span><br><span class="line">  <span class="string">"Create an org file in ~/notes/snippets."</span></span><br><span class="line">  (<span class="name">format-time-string</span> <span class="string">"~/Dropbox/org/journals/%Y_%m_%d.org"</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> org-capture-templates</span><br><span class="line">      '((<span class="string">"t"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/work.org"</span>)</span><br><span class="line">         <span class="string">"** TODO %?\n  %i\n "</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"x"</span> <span class="string">"Task"</span> entry (file+datetree <span class="string">"~/Dropbox/org/work.org"</span>)</span><br><span class="line">         <span class="string">"** TODO %^&#123;priority|[#A]|[#B]|[#C]&#125; %?\n"</span>)</span><br><span class="line">        (<span class="string">"e"</span> <span class="string">"Task"</span> entry (file+datetree <span class="string">"~/Dropbox/org/life.org"</span>)</span><br><span class="line">         <span class="string">"** TODO %^&#123;priority|[#A]|[#B]|[#C]&#125; %?\n"</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"l"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/learn.org"</span>)</span><br><span class="line">         <span class="string">"** TODO %?\nEntered on %U\n  %i\n\n "</span> :kill-buffer <span class="literal">t</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"k"</span> <span class="string">"Todo"</span> entry (file+datetree <span class="string">"~/Dropbox/org/learn.org"</span>)</span><br><span class="line">         <span class="string">"* TODO %?\n  %i\n %f\n %a"</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"j"</span> <span class="string">"Journal"</span> entry (file+datetree <span class="string">"~/Dropbox/org/_journal.org"</span> )</span><br><span class="line">         <span class="string">"** %?\nEntered on %U\n  %i\n"</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"J"</span> <span class="string">"Journal"</span> entry (file gen-date-file)</span><br><span class="line">         <span class="string">"** %?\nEntered on %U\n  %i\n"</span> :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"c"</span> <span class="string">"Code snippet"</span> entry (file+headline <span class="string">"~/Dropbox/org/_code.org"</span> <span class="string">"Code"</span>)</span><br><span class="line">         <span class="string">"** %^&#123;desc&#125;\n#+BEGIN_SRC %^&#123;language|ruby|shell|c|rust|emacs-lisp&#125;\n%?\n#+END_SRC"</span> </span><br><span class="line">          :empty-lines <span class="number">1</span>)</span><br><span class="line">        (<span class="string">"C"</span> <span class="string">"Notes"</span> entry (file create-code-file)</span><br><span class="line">         <span class="string">"** %^&#123;desc&#125;\n#+BEGIN_SRC %^&#123;language|ruby|shell|c|rust|emacs-lisp&#125;\n%?\n#+END_SRC"</span> </span><br><span class="line">          :empty-lines <span class="number">1</span>)</span><br><span class="line">        ))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; I switched to org-mode from EverNote recently, and the experience imrpoved much for note and journal writing, especially for technical n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>满足感源自细节</title>
    <link href="http://chenyukang.github.io/2019/07/31/details_matter.html"/>
    <id>http://chenyukang.github.io/2019/07/31/details_matter.html</id>
    <published>2019-07-31T23:40:03.000Z</published>
    <updated>2021-07-02T15:36:31.139Z</updated>
    
    <content type="html"><![CDATA[<p>最近自我感觉生活质量提高了不少，并不是突然撞大运发大财了，总结下来居然都是一些小细节，奇怪正是这些小细节每次都会让我会心一笑。</p><p><img src="/images/2019_07_26.org_20190727_085906.png" width="70%" hegiht="70%" align="center"></p><h4 id="org-mode"><a href="#org-mode" class="headerlink" title="org-mode"></a>org-mode</h4><p>作为一个近十二年的 Emacs 用户，最近开始使用 org-mode 了。之前一直偶尔看到说什么单独为了org-mode 而花时间熟悉 Emacs 也是值得的，不过我一直没认真看，因为我认为在 Emacs 下不太适合大量编辑中文，快捷键太多在中文输入的过程中会有一些影响。</p><p>最近因为杂事比较多，我特别想要一个结合了日程管理和文档管理的软件。之前用过 Bear，这款软件的好处在于其编辑支持得特别好，但是 Bear 没有日程管理。后来又重新用回 EverNote，这东西的文字编辑支持有点弱，日程管理就是个最基本的清单。还有一些代码嵌入方面的问题，拷贝进去支持再拷贝出来居然其中嵌了部分中文符号。</p><p>最后我终于花了点时间来看看这个传说中的 org-mode 到底神奇在何处。结果真的符合了好香定律，我怎么不一开始用 Emacs 就着手用这呢，后悔万千！</p><p>其实不管日程管理也好，日志、技术笔记等也好，本质上都是文字。org-mode 的日程和笔记都是存储的最原始的文本格式，而 org-mode 的编辑模式类似 Bear，写起来非常容易上手。和 Markdown 类似属于「易读易写」的轻量级标签格式。</p><p>日程管理也有一些记录时间、统计时间，培养习惯的打卡类日程计划。配合 org-agenda 的各种视图，org-capture 的可定制的模板，用起来真是简洁而又迅速。自己再定制一些函数和脚本，实现从剪切板拷贝图片，使用修改过的 <a href="https://github.com/chenyukang/org-ruby/tree/block-version" target="_blank" rel="noopener">org-ruby</a> 自动从 org 转换为 Markdown，反正只要是文本其可塑性就非常强。</p><p><img src="/images/2019_07_26.org_20190727_003933.png" width="70%" hegiht="70%" align="center"></p><p>这才是对程序员最友好、最强大的文档和日程管理工具，<strong>其满足点在于『可定制』</strong>。</p><h4 id="全屏中小红点"><a href="#全屏中小红点" class="headerlink" title="全屏中小红点"></a>全屏中小红点</h4><p>当我开始大量使用 org-mode 记录之后，就不可避免地需要在全屏的 Emacs 下输入中文。而这经常会被打乱，总结一下发现其实是因为全屏状态下我经常会不知道目前是否启用了中文输入法。全屏模式下看不到输入法的任何图标，Baidu 的 Mac 输入法这个浮动状态栏不会在 Emacs 全屏的模式下显示，而且那个辐条本身看起来也太占空间了。在没有图标的情况下只有靠 Shift 或者 Ctrl blank 瞎切换了，非常让人厌烦。</p><p>这个困扰很久的问题最近也终于解决了， 这个 <a href="https://github.com/tekezo/ShowyEdge" target="_blank" rel="noopener">ShowEdge</a> 工具可以根据不同的输入法，配置不同的颜色，而且在任何全屏状态都根据输入法显示颜色。我的屏幕顶部就配置了这么一个小红点：</p><p><img src="/images/CAPTURE-2019_07_26.org_20190727_000238.png" alt="file:img/CAPTURE-2019_07_26.org_20190727_000238.png"></p><p>从此输入中文的体验大幅提高！虽然这是非常细节的一个地方，但是当你想到折磨自己的问题，其他人也关注到了，并且用了极其符合自己使用习惯的开源软件解决了，顿时觉得世界真美好！</p><p><strong>这里的满足点在于『可控性』</strong>。</p><h4 id="黑暗中的黄色光"><a href="#黑暗中的黄色光" class="headerlink" title="黑暗中的黄色光"></a>黑暗中的黄色光</h4><p>这东西犹如黑暗中的萤火虫，让人温暖，哈哈，其实就是小米的一款感应夜灯。我对小米的这种小的智能家电比较感兴趣，比如小爱同学也不错。这款夜灯的好处在于自动感应，进洗手间自己就亮，我每次都是比较晚才去洗漱刷牙，这灯不太亮也不太暗，而且可以根据声音、移动、和自然光亮度自动开关。其实功能很简单，符合软件设计中的哲学：专注唯一功能，但是功能做到极致。</p><p><img src="/images/2019_07_26.org_20190727_004316.png" width="350" hegiht="400" align="center"></p><p><strong>这应该是简单地满足了『确定性』的心理需求</strong>，为什么像语音助手这类东西虽然看起来比较炫酷，但用的人并不多，因为语音识别在日常使用过程中还是会存在各种干扰，最终造成使用过程中存在一些不确定性，从而影响了根本的使用体验。</p><p>Entered on [2019-07-26 五 23:31]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近自我感觉生活质量提高了不少，并不是突然撞大运发大财了，总结下来居然都是一些小细节，奇怪正是这些小细节每次都会让我会心一笑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_07_26.org_20190727_085906.png&quot; width=&quot;70%&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>保存 kmacro </title>
    <link href="http://chenyukang.github.io/2019/06/23/2019-06-23-random-notes.html"/>
    <id>http://chenyukang.github.io/2019/06/23/2019-06-23-random-notes.html</id>
    <published>2019-06-23T23:48:42.000Z</published>
    <updated>2021-07-02T15:36:31.135Z</updated>
    
    <content type="html"><![CDATA[<p>宏是很强大的编辑方法，如果要长久保存一些宏可以使用下面的办法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">M-x start-kbd-macro</span><br></pre></td></tr></table></figure><p>开始记录宏，通常快捷键为”C-x (“, 结束的快捷键为 “C-x )”。</p><p> 然后使用命令: </p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">M-x kmacro-name-last-macro</span><br></pre></td></tr></table></figure><p>  可以把这条宏给命名，如果要保存这个宏以便日后使用，需要打开 init.el 继续使用命令： </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">M-x insert-kbd-macro</span><br></pre></td></tr></table></figure><p>选中命名的宏，这样就在 init.el 里面插入了刚才的宏，这个名字也就可以当作日常命令使用了。</p><p>例如我新建一个宏，作用是查找测试文件中的 “#[ignore]”，并删除掉那行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(fset &apos;rust-ignore</span><br><span class="line">      (lambda (&amp;optional arg) &quot;Keyboard macro.&quot; (interactive &quot;p&quot;)</span><br><span class="line">        (kmacro-exec-ring-item</span><br><span class="line">         (quote ([12 115 101 97 114 99 104 return 35 91 105 103 110 111 114 101 return 1 11 11 14] 0 &quot;%d&quot;)) arg)))</span><br></pre></td></tr></table></figure><p>如果要重复执行，则需要运行： </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C-x z</span><br></pre></td></tr></table></figure><p>当然后面可以连续按 z z z …. ， 执行多遍。</p><p> 参考: <a href="https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function" target="_blank" rel="noopener">https://emacs.stackexchange.com/questions/70/how-to-save-a-keyboard-macro-as-a-lisp-function</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宏是很强大的编辑方法，如果要长久保存一些宏可以使用下面的办法：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;M-x start-kbd-mac
      
    
    </summary>
    
    
      <category term="Notes" scheme="http://chenyukang.github.io/tags/Notes/"/>
    
      <category term="Emacs" scheme="http://chenyukang.github.io/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>2019，愿你也健康</title>
    <link href="http://chenyukang.github.io/2019/01/23/2019-wishes.html"/>
    <id>http://chenyukang.github.io/2019/01/23/2019-wishes.html</id>
    <published>2019-01-23T23:48:42.000Z</published>
    <updated>2021-07-02T15:36:31.135Z</updated>
    
    <content type="html"><![CDATA[<h4 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h4><p>最近在坚持养成每天尽量花一小时锻炼的习惯，因为我想在 2019 年有个更健康、有活力的身体。</p><p>随着年纪的增长，身体的一些反馈还是如实地告诉自己在变老。衰老就是能力不断地退化、消失。之前打球能蹦蹦跳跳的，现在多跑跑就会喘气；之前精力更好、更喜欢到处走动，现在更倾向于静静休息。去年有的时候身体感觉不太好，有段时间特别疲劳，甚至也体验过一段低迷的至暗时刻。大概是因为生活不规律，而且基本没有怎么锻炼，体重也不断上升。因为在 2017 年初打篮球的时候把膝盖伤了，后来也不能激烈打球了。现在比较适合自己的运动方式就是跑步、游泳、散步之类的。</p><hr><h4 id="人总是会忘掉这件事"><a href="#人总是会忘掉这件事" class="headerlink" title="人总是会忘掉这件事"></a>人总是会忘掉这件事</h4><p>当然锻炼养生也不能抵抗衰老，这是个自然过程，锻炼至少能有助于健康。健康是所有幸福的最大基础，比什么都重要，俗话说『宁做健康的乞丐，也比做病恹恹的国王快活得多』。人更无法逃避的是死亡，这是所有生物的最终归宿和命运。只是人总会渐渐忘记自己会死，梁文道说的一个故事：</p><blockquote><p>很多年前，一位德国摄影师跟一个记者合作的拍摄计划，很有意思。那个摄影师去很多的临终病房，拍摄一些快要死去的人，趁他们还在世的时候，拍下他们的遗照。然后他们刚刚离开，合上眼睛的时候，又为他们再拍一张照片，两张照片放在同一版上，前面则是文字记者做的采访。</p><p>在这一系列的采访跟摄影当中，其中一个已死的老太太，在她的采访里面说的一句话，他一辈子都不会忘记。她说什么呢？她跟文字记者说，“你看，你看”，就指着病房玻璃外面楼下对面马路的一个超级市场，她指着那个超级市场跟摄影师和记者说：“<strong>你看那里头的人们，天天进进出出买东西，买面包、买肉、买卫生纸，你看他们的样子，他们好像从来不觉得自己会死。</strong>”</p></blockquote><h4 id="读《最后的告别》"><a href="#读《最后的告别》" class="headerlink" title="读《最后的告别》"></a>读《最后的告别》</h4><p>这本书很多人都推荐过，我最近刚好也看了一遍。这里面谈了一些人在最终衰老、告别时必须面对的问题和思考，其中也有一些作者所经历的老人故事，还有自己的父亲最后的抗争。其中有一个故事印象深刻，看完后我又查了查还真有这么个人和事。</p><blockquote><p>1980年3月，当附近火山已经开始冒水汽、隆隆作响时，这位83岁的老人却仍然拒绝撤离他在华盛顿奥林匹亚市附近圣海伦山脚的家。他是第一次世界大战时期的飞行员、禁酒时期的私酒制造者，已经在灵湖的这所房子里住了半个多世纪了。5年前，他成了鳏夫。所以，当时，在山脚这处300多亩的地盘上，只住着他和他的16只猫。三年前，他在屋顶铲雪的时候掉下来，摔断了腿。医生说他是个“该死的傻瓜”，在这样的年龄还爬到房顶去做事。<br>　　<br>　　“该死！”他给医生骂回去，“<strong>我都 80岁了！我有权做决定，有权做我想做的事。</strong>”</p><p>由于受到火山喷发的威胁，官方要求附近居民全部撤离，但是杜鲁门哪儿都不去。火山闷烧了两个多月，官方把撤离区域扩大到火山周围16千米。杜鲁门固执地不肯离开。</p><p>　“如果这个地方要毁灭，那我想跟它同归于尽，”他说，“反正如果失去它，我也会在一周之内结果我自己。”他直率、不和悦的讲话方式吸引了记者。他说起话来滔滔不绝，头戴一顶绿色的约翰·迪尔棒球帽，手拿一大高脚杯波旁威士忌和可乐。当地警察考虑为了他好而逮捕他，但是，由于他的年龄以及他们必须得承受的负面新闻，只好作罢。他们提出但凡有机会就带他离开，但他坚决予以拒绝。他告诉一位朋友：“<strong>如果我明天死去，我也已经度过了愉快的一生。我能做的事都做了，想做的事都做了。</strong>”<br>　　<br>　　1980年5月18日早上8点40分，火山终于爆发了，其威力相当于一颗原子弹。巨量的岩浆流吞没了整个湖，埋葬了杜鲁门、他的猫和他的家。事后，他成了偶像——一个老头留在自己家里碰运气，在这种可能性似乎已经消失的年代，他按照自己的方式生活。</p><p><img src="/images/1920px-St_Helens_before_1980_eruption_horizon_fixed.jpg" alt="1920px-St_Helens_before_1980_eruption_horizon_fixed"></p></blockquote><p>相对书中的很多老人来说，这位老人的选择充满了勇气，他以决绝的选择来面对衰老和死亡，并没有经受医院的无尽折磨。年轻人看起来这算是是自杀吧，加缪认为自杀是唯一严肃的哲学问题，看来老人对此已经有了答案。能有多少人老了能还以自己喜欢的生活方式活着，并在最终告别的时候心里都是满足：我已经愉快地度过了一生。</p><p>孔子说『未知生<em>，</em>焉知死』，反过来如果没有认真思考过死这件事，人又能真的知道怎么活。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>最近大环境不太好，很多人都在纠结于今年能拿到多少年终，好多事情并不是个人所能决定，自己能最能把握的是自己的身体，珍惜生命、保护好自己，以免年纪轻轻落得一身病，年纪大了用钱换命。</p><p>最后推荐一个纪录片：《人世间》。每天都有无数的人在和疾病、死亡抗争，活着对很多人来说其实真不是件容易的事。</p><p>日子中很多艰辛和苦难，和生死比起来那就不是事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;坚持&quot;&gt;&lt;a href=&quot;#坚持&quot; class=&quot;headerlink&quot; title=&quot;坚持&quot;&gt;&lt;/a&gt;坚持&lt;/h4&gt;&lt;p&gt;最近在坚持养成每天尽量花一小时锻炼的习惯，因为我想在 2019 年有个更健康、有活力的身体。&lt;/p&gt;
&lt;p&gt;随着年纪的增长，身体的一些反馈还
      
    
    </summary>
    
    
      <category term="Notes" scheme="http://chenyukang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Rust 的 dbg! 宏</title>
    <link href="http://chenyukang.github.io/2019/01/18/rust-dbg.html"/>
    <id>http://chenyukang.github.io/2019/01/18/rust-dbg.html</id>
    <published>2019-01-18T00:23:24.000Z</published>
    <updated>2021-07-02T15:36:31.147Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在群里看到有人讨论 dbg! 宏已经在 Nightly 可以使用了，最近发布的 stable 版本 1.32.0 也可以使用了。 翻看了一下并玩了玩，这个简单的宏确实是调试好帮手，特别是适合我这样的喜欢打印调试的开发者。这个提议从 2017 年 10 月开始，从 <a href="https://github.com/rust-lang/rfcs/pull/2173" target="_blank" rel="noopener">https://github.com/rust-lang/rfcs/pull/2173</a> 可以看到，为了增加这个宏很多贡献者经过了无数次的讨论和回复。真是太佩服 Rust Team 的开发者，付出了这么多时间来增加这个看似很小又实用的功能。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>先看看这个调试宏是怎么使用的，目前使用这个宏需要切换到 Nightly 版本或者最新的稳定版，已经安装了 rustup 的话就很简单了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup default nightly</span><br><span class="line">rustup update</span><br></pre></td></tr></table></figure><p>然后很简单就是把一个表达式当作参数传入:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">factorial</span></span>(n: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> dbg!(n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">         dbg!(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         dbg!(n * factorial(n - <span class="number">1</span>))</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    dbg!(factorial(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[src/main.rs:4] n &lt;= 1 = false</span><br><span class="line">[src/main.rs:4] n &lt;= 1 = false</span><br><span class="line">[src/main.rs:4] n &lt;= 1 = false</span><br><span class="line">[src/main.rs:4] n &lt;= 1 = false</span><br><span class="line">[src/main.rs:4] n &lt;= 1 = true</span><br><span class="line">[src/main.rs:5] 1 = 1</span><br><span class="line">[src/main.rs:7] n * factorial(n - 1) = 2</span><br><span class="line">[src/main.rs:7] n * factorial(n - 1) = 6</span><br><span class="line">[src/main.rs:7] n * factorial(n - 1) = 24</span><br><span class="line">[src/main.rs:7] n * factorial(n - 1) = 120</span><br><span class="line">[src/main.rs:12] factorial(5) = 120</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>原理当然也就是把表达式和位置打印出来，但是这里有个技巧，在宏里面使用 match，这是为了避免参数被调用多次，因为宏在编译之前会被展开。Rust 的宏比较复杂，也不可避免会有些 hacky，对于喜欢爱折腾的程序员还是有吸引力。再看看这个宏是怎么实现的，代码很少。：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> dbg &#123;</span><br><span class="line">    ($val:expr) =&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> $val &#123;</span><br><span class="line">            tmp =&gt; &#123;</span><br><span class="line">                eprintln!(<span class="string">"[&#123;&#125;:&#123;&#125;] &#123;&#125; = &#123;:#?&#125;"</span>,</span><br><span class="line">                          <span class="built_in">file!</span>(), <span class="built_in">line!</span>(), <span class="built_in">stringify!</span>($val), &amp;tmp);</span><br><span class="line">                tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到目前这个实现是只支持一个参数的，如果传入的参数类型没有实现 Copy Trait，可以传入引用。另外如果想同时打印多个参数，可以使用类似这样的做法：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">dbg!((exp1, exp2))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天在群里看到有人讨论 dbg! 宏已经在 Nightly 可以使用了，最近发布的 stable 版本 1.32.0 也可以使用了。 翻看了一下并玩了玩，这个简单的宏确实是调试好帮手，特别是适合我这样的喜欢打印调试的开发者。这个提议从 2017 年 10 月开始，从 &lt;a
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://chenyukang.github.io/tags/Rust/"/>
    
  </entry>
  
</feed>
