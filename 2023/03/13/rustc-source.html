<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="All about coding and writing">
  <meta name="keyword" content="Programming, Programming Languages, Algorithms, Tools">
  <meta property="og:site_name" content="程序员的喵">
  <meta property="og:title" content="Rust 编译器源码概要 | 程序员的喵" />
  <meta property="og:type" content="website" />
  <meta property="og:locale" content="" />
  <meta property="og:description" content="" />
  <meta property="og:image" content=" http://catcoding.me/css/images/logo.png " />
  <link rel="alternate" type="application/rss+xml" title="程序员的喵; Feed" href="https://catcoding.me/atom.xml" />

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/fonts.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/code.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/prism.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">

  
<script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
<script src="/js/jquery.min.js"></script>
<script src="/js/geopattern.min.js"></script>
<script src="/js/nprogress.min.js"></script>

  
  
  <link rel="shortcut icon" href="/css/images/favicon.ico">
  
  <title>
    
    Rust 编译器源码概要 |
    程序员的喵
    
  </title>

  <div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src="/css/images/logo.png" width='400px' height='400px' />
  </div>

  
  


  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-77282254-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'UA-77282254-1');
  </script>

<meta name="generator" content="Hexo 5.4.2"></head>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>程序员的喵</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/links/" class="item-link">Links</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      

        <li class="list-item" style="margin: 0">
       <a class="icon-small" href="/search">
        <span class="fa-stack fa-lg">
          <i class="fa fa-search fa-stack-1x fa-inverse" style="color:#8ccb8c"></i>
        </span>
       </a>
      </li>

       <li class="list-item" style="margin-left: 3px">
        <a class="icon-small" href="/atom.xml">
         <span class="fa-stack fa-lg">
           <i class="fa fa-rss fa-inverse" style="color:orange"></i>
         </span>
        </a>
       </li>
    </ul>
    
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/links/" class="menu-link">Links</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Rust 编译器源码概要</h2>
  <p class="post-date">2023-03-13</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>


<main class="app-body flex-box">


  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>一个 Rust 程序是如何从源文件编译为二进制文件的？</p>
<p>如果从头开始看 rustc 的源码会无从下手，我之前通过解决 issue 去读过部分模块的源码，就是 bottom-up 的方式，但我还未从整体上理解 rustc 的源码结构。</p>
<p>这篇文章主要是我在重看 <a target="_blank" rel="noopener" href="https://rustc-dev-guide.rust-lang.org/getting-started.html">Rust Compiler Development Guide</a> 的一些随手记录，还有些自己的动手实验，旨在厘清编译器的大致脉络，理解每个阶段做了些什么，如果你想看更为完整的文档请参考官方的手册。</p>
<p>Rust 编译器分为这几个主要的阶段，回顾我目前做的工作大多集中在 <code>MIR</code> 之前，分阶段从前到后接触得越少 😊</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>编译器是典型的输入输出系统，每个阶段都有对应的入和出。我们经常可以看到 <code>lowering</code> 这个术语，这个 <code>lowering</code> 的对象可以是源程序、AST、IR，不断地把程序中的抽象由高变低的过程，到 <code>MIR</code> 就已经是类似 <code>LLVM IR</code>  这个级别了。</p>
<p><img src="/images/ob_pasted-image-20230303200344.png" alt=""></p>
<p><strong>Lexing</strong>: 把源程序解析为 token 流。</p>
<p><strong>Parsing</strong>: 把 token 流转换为 AST（Abstract Syntax Tree），这期间很做宏扩展、AST 验证、名称解析和早期 linting。</p>
<p><strong>HIR lowering</strong>: 将 AST 转换为高级中间表示 HIR（High-level IR），这是一种对编译器更友好的 AST 表示，其中也涉及很多诸如循环和 <code>async fn</code> 之类的脱糖。然后我们使用 HIR 进行类型推断（type inference）、特征求解（trait solving）和类型检查（type checking）。</p>
<p><strong>MIR lowering</strong>: 将 HIR 转换到 MIR（Middle-level IR），用于借用检查和其他重要的基于数据流的检查，例如检查未初始化的值。在此过程中还构建了更加脱糖的 THIR（Typed HIR），THIR 主要用于 pattern checking 检查。</p>
<p><strong>Code generation</strong>: 主要基于 LLVM 做代码生成，也支持 Cranelift。</p>
<h2 id="编译入口"><a href="#编译入口" class="headerlink" title="编译入口"></a>编译入口</h2><p>当我们运行编译命令 <code>rustc main.rs</code> 时，编译器首先会通过 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_driver_impl/src/lib.rs">rustc_driver</a> 这个最上层的组件来处理输入参数，然后调用更基础的组件来启动编译行为。</p>
<p>编译器的入口在于 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/5983a3a99ea631da9d7d1ce510a6761913f92a89/compiler/rustc/src/main.rs#L64">rustc_driver::main</a>，接着调用：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token class-name">RunCompiler</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> callbacks<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>
<p>真正的跑编译流程的过程在于 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_driver_impl/src/lib.rs#L232">run_compiler</a>，主要流程还是 <code>Parsing</code>，<code>Analysising</code>，<code>Linking</code>。我们看到很多调用是从一个叫做 <code>queries</code> 的东西开始的，比如：</p>
<ul>
<li><code>queries.parse()</code>，</li>
<li><code>queries.global_ctxt()?.enter(|tcx| tcx.analysis(()))</code></li>
</ul>
<p>这是 Rust 编译器的一个特点，正在从传统的 <code>pass-based</code> 方式转向 <code>demand-driven</code>，按需编译的主要思路是既然编译是典型的输入输出系统，同一个输入的输出是一样的，所以适合用缓存来减少重复计算。这是算法设计中 <code>Memoization</code> 的思路，详细的设计文档在 <a target="_blank" rel="noopener" href="https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md">rustc-on-demand-and-incremental</a>。</p>
<p>好处主要在于增量编译时加快编译速度，结果就是用户更改的少量的代码，编译速度会更快。另外一个原因是这样方便并行编译。</p>
<p>但目前还有很多 <code>phase</code> 并没有完全实现这种按需处理的方式，目前只有 <code>HIR</code> 到 <code>LLVM IR</code> 之间的步骤是查询的。我们可以在这里看到默认的 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_interface/src/passes.rs#L626">query provider</a>:</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token constant">DEFAULT_QUERY_PROVIDERS</span><span class="token punctuation">:</span> <span class="token class-name">LazyLock</span><span class="token operator">&lt;</span><span class="token class-name">Providers</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">LazyLock</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> providers <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">Providers</span><span class="token punctuation">::</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    providers<span class="token punctuation">.</span>analysis <span class="token operator">=</span> analysis<span class="token punctuation">;</span>
    providers<span class="token punctuation">.</span>hir_crate <span class="token operator">=</span> <span class="token namespace">rustc_ast_lowering<span class="token punctuation">::</span></span>lower_to_hir<span class="token punctuation">;</span>
    providers<span class="token punctuation">.</span>output_filenames <span class="token operator">=</span> output_filenames<span class="token punctuation">;</span>
    providers<span class="token punctuation">.</span>resolver_for_lowering <span class="token operator">=</span> resolver_for_lowering<span class="token punctuation">;</span>
    <span class="token namespace">proc_macro_decls<span class="token punctuation">::</span></span><span class="token function">provide</span><span class="token punctuation">(</span>providers<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">...</span><span class="token punctuation">.</span>
    <span class="token namespace">rustc_codegen_ssa<span class="token punctuation">::</span></span><span class="token function">provide</span><span class="token punctuation">(</span>providers<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>providers
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意这些 <code>provider</code> 是按照 <code>crate</code> 这个维度来组织的，我在日常开发中经常碰到的一个问题是，如果我切换了 <code>compiler</code> 的代码分支，然后直接进行增量编译，最终链接的时候报错，这大概是因为某些 <code>crate</code> 的代码变了，而缓存的结果是老的，重新 <code>clean</code> 后编译就好了，以后再排查一下具体原因。</p>
<p><code>query</code> 引入的另外一个问题是导致错误堆栈特别长，在调试过程中经常碰到几百行的堆栈信息，我打算在这个 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/107910">Issue</a> 里尝试解决。</p>
<h2 id="Lexing"><a href="#Lexing" class="headerlink" title="Lexing"></a>Lexing</h2><p>Lexing 的过程和其他编译器类似，我们可以理解为给定字符串的源文件，输出一个 token 的数组。对应的代码在 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/5983a3a99ea631da9d7d1ce510a6761913f92a89/compiler/rustc_lexer/src/lib.rs#L326">compiler/rustc_lexer</a>，这个 <code>advance_token</code> 就是读取下一个 token。</p>
<p>但是 Rust lexing 过程中的特殊点在于输出为一个称之为 token 流的东西，<code>advance_token</code> 被一个叫做 <code>tokentrees.rs</code> 的模块调用，处理后的结果是 <code>TokenStream</code>，其实也就是一组 Token，只是定义为一个树形的结构：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">TokenStream</span><span class="token punctuation">(</span><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token class-name">Lrc</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">TokenTree</span><span class="token operator">>></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其定义为：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">TokenTree</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/// A single token.</span>
    <span class="token class-name">Token</span><span class="token punctuation">(</span><span class="token class-name">Token</span><span class="token punctuation">,</span> <span class="token class-name">Spacing</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">/// A delimited sequence of token trees.</span>
    <span class="token class-name">Delimited</span><span class="token punctuation">(</span><span class="token class-name">DelimSpan</span><span class="token punctuation">,</span> <span class="token class-name">Delimiter</span><span class="token punctuation">,</span> <span class="token class-name">TokenStream</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<p>至于为什么返回的是这个树形结构，可以参考这里 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40302026/what-does-the-tt-metavariable-type-mean-in-rust-macros">What does the tt metavariable type mean in Rust macros</a> 和 <a target="_blank" rel="noopener" href="https://danielkeep.github.io/tlborm/book/mbe-syn-source-analysis.html">TokenTrees</a> 简而言之就是为了处理宏。</p>
<p>为了看看这个 Lexing 的过程，我们可以写个简单的程序来看看中间结果：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a = &#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_parse/src/lexer/mod.rs#L65">parse_token_trees</a>修改代码来把 <code>TokenTree</code> 打印出来：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token keyword">ref</span> token_trees<span class="token punctuation">)</span> <span class="token operator">=</span> token_trees <span class="token punctuation">&#123;</span>
    <span class="token macro property">debug!</span><span class="token punctuation">(</span><span class="token string">"token_trees: &#123;:#?&#125;"</span><span class="token punctuation">,</span> token_trees<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过环境变量来把编译器运行过程中的中间结果打印出来，重定向到一个文件，运行命令：<br><pre class="line-numbers language-none"><code class="language-none">RUSTC_LOG&#x3D;debug rustc main.rs &gt; &#x2F;tmp&#x2F;r.log 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>
<p>我们可以看到这个程序的 <code>TokenTree</code> 是这样的：</p>
<p><img src="/images/ob_pasted-image-20230302081527.png" alt=""></p>
<p>也就是通过分隔符 <code>(...)</code> 、<code>&#123;...&#125;</code>、<code>[...]</code> 把 Token 分组，我最近对这个模块做了一些<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/pull/108297">改进和重构</a>，任何分隔符不匹配的问题会报错然后终止编译，主要原因是分隔符的不匹配会让 Parser 构造出完全错误的 <code>AST</code>，这样诊断信息就会非常多，而大多数对开发者没有用。</p>
<h2 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h2><p>Rust 使用的手写的递归下降（自上而下）方法进行语法分析，解析是按语义构造组织的，可以在 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse/src/parser">rust/compiler/rustc_parse/src/parser</a> 目录看到以下文件：</p>
<ul>
<li><code>expr.rs</code></li>
<li><code>pat.rs</code></li>
<li><code>ty.rs</code></li>
<li><code>stmt.rs</code></li>
</ul>
<p>我们可以使用以下命令来把整个程序的 <code>AST</code> 打印出来，这对于编译器开发阶段比较有帮助：</p>
<pre class="line-numbers language-console" data-language="console"><code class="language-console">rustc .&#x2F;p&#x2F;main.rs -Zunpretty&#x3D;ast-tree &gt; tree.log 2&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>另外，读这部代码结合 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/">Rust Reference</a> 会容易很多，因为 parser 很多时候就是 reference 的直译，看懂了 reference 就容易看懂 parsing。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>为什么 Rust 不用那些高级的 parsing 工具而采用手写的方式，我认为一个原因在于手写能给出更好的诊断信息，可以看到 <code>parser</code> 中很多代码在尝试从错误中恢复，比如用户写了下面这个程序：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">const</span> <span class="token constant">FOO</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当 Parser 处理到 <code>&#123;</code> 这个位置，这里看起来用户想写的是一个数组，但把 <code>[</code> 写成了 <code>&#123;</code>，<code>Parser</code> 中的这段代码会先把当前的状态存储为一个 <code>snapshot</code>，然后尝试 <code>1, 2, 3</code> 是否能 parse 成一个数组元素，如果是则能给出一个更为优化的诊断信息，如果不能则恢复到保存的 <code>snapshot</code>：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">maybe_suggest_brackets_instead_of_braces</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> lo<span class="token punctuation">:</span> <span class="token class-name">Span</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">P</span><span class="token operator">&lt;</span><span class="token class-name">Expr</span><span class="token operator">>></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> snapshot <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">create_snapshot_for_diagnostic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">match</span> snapshot<span class="token punctuation">.</span><span class="token function">parse_array_or_repeat_expr</span><span class="token punctuation">(</span><span class="token class-name">Delimiter</span><span class="token punctuation">::</span><span class="token class-name">Brace</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Ok</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// emit better error here</span>
            <span class="token punctuation">...</span>

            <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">restore_snapshot</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">mk_expr_err</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>span<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">None</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Parser</code> 中很多代码都在处理类似这种逻辑。错误处理也是一个很大的话题，在 <code>parsing</code> 这个阶段能做的都是明显的语法层面的处理。</p>
<h3 id="宏展开"><a href="#宏展开" class="headerlink" title="宏展开"></a>宏展开</h3><p>在 <code>Parsing</code> 的过程中会遇到宏，但宏处理需要在 <code>AST</code> 构建之后，所以在这个过程中所有的宏会通过占位符来特殊标识。</p>
<p>相对 <code>Parsing</code>，宏展开是一个更为复杂的过程，<code>AST</code> 有了之后会 <code>driver</code> 会通过一下调用路径来逐个 crate 展开宏：</p>
<pre><code>resolver_for_lowering -&gt; configure_and_expand -&gt; expand_crate -&gt; fully_expand_fragment
</code></pre><p><a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_expand/src/expand.rs#L409"><code>fully_expand_fragment</code></a> 这个函数是宏展开的主要算法，首先找到 AST 中的占位符，维护一个队列，然后不断地去展开直到所有的宏占位符都处理完毕，再统一加到 AST 中去，这是因为宏代码中也可能包含宏？如果某次迭代没有展开一个宏说明有语法问题。</p>
<h3 id="Name-resolution"><a href="#Name-resolution" class="headerlink" title="Name resolution"></a>Name resolution</h3><p><code>Name resolution</code> 就是解析 <code>AST</code> 中的所有名字，包括变量名、函数名、类型名、生命周期的命名等等。<br>在宏展开的过程中，我们只处理了 <code>import</code>，而并没有关注所有的名字解析，所有的命名需要等到宏展开处理了之后专门来解析名字，这也是这部分代码很多函数的名字叫做 <code>late_*</code>，很多逻辑在一个叫作 <code>late.rs</code> 的文件里。但我们并没有看到一个 <code>early.rs</code> 的文件，因为被拆分成了三个文件：<code>build_reduced_graph.rs</code>, <code>macros.rs</code> 和 <code>imports.rs</code>。</p>
<p>我们来写个程序包含一个明显的变量 <code>a</code> 未定义：<br><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p>
<p>编译器在编译的过程中肯定会报错，使用以下命令来把第一个错误信息当作一个 <code>bug</code>，这样我们就可以获得这个报错的调用堆栈，这是调试编译器一个很有用的小技巧：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rustc ./p/main.rs <span class="token parameter variable">-Z</span> treat-err-as-bug<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过查看堆栈我们可以看到错误是在这里出现的，因此我们找到了 <code>name resolving</code> 的入口在<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/compiler/rustc_resolve/src/lib.rs#L1483">resolve_crate</a>：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Entry point to crate resolution.</span>
 <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">resolve_crate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> krate<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Crate</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_crate"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>
         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"finalize_imports"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">finalize_imports</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                                 <span class="token class-name">EffectiveVisibilitiesVisitor</span><span class="token punctuation">::</span><span class="token function">compute_effective_visibilities</span><span class="token punctuation">(</span>sel          <span class="token punctuation">...</span>
         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"late_resolve_crate"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">late_resolve_crate</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_main"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">resolve_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_check_unused"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">check_unused</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span>sess<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_report_errors"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">report_errors</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">self</span><span class="token punctuation">.</span>tcx
             <span class="token punctuation">.</span>sess
             <span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"resolve_postprocess"</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">crate_loader</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>c<span class="token closure-punctuation punctuation">|</span></span> c<span class="token punctuation">.</span><span class="token function">postprocess</span><span class="token punctuation">(</span>krate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">// Make sure we don't mutate the cstore from here on.</span>
     <span class="token keyword">self</span><span class="token punctuation">.</span>tcx<span class="token punctuation">.</span><span class="token function">untracked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cstore<span class="token punctuation">.</span><span class="token function">leak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>self.late_resolve_crate(krate)</code> 就是按照 <code>crate</code> 逐个去解析里面的 <code>name</code>，而 <code>self.resolve_main()</code> 是找整个程序中是否存在 <code>main</code>。<code>LateResolutionVisitor</code> 就是用来递归地遍历 <code>AST</code> 里的元素，比如 <code>resolve_local</code>，<code>resolve_params</code> 等等。</p>
<p>这里有一个很重要的概念叫做 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_resolve/late/struct.Rib.html#"><code>rib</code></a>，我估计是 <code>Rust internal block</code> 的简称🤔，这里有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_resolve/late/enum.RibKind.html">各种类型的 <code>rib</code></a>，一个 <code>rib</code> 就是定义了一个命名空间和其对应的 <code>binding</code>:</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Rib</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">R</span> <span class="token operator">=</span> <span class="token class-name">Res</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">pub</span> bindings<span class="token punctuation">:</span> <span class="token class-name">IdentMap</span><span class="token operator">&lt;</span><span class="token class-name">R</span><span class="token operator">></span><span class="token punctuation">,</span>
    <span class="token keyword">pub</span> kind<span class="token punctuation">:</span> <span class="token class-name">RibKind</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>比如我们写代码中的一个大括号就会引入一个新的 <code>rib</code>，同样的一个函数或者模块的定义会引入对应的 <code>rib</code>。对于代码：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那如何能找到在 <code>println!</code> 的时候所用的变量 <code>a</code> 呢？因为变量是可以被覆盖的，可以想象这是一个按 scope 从里往外找的过程，从代码上也可以验证这个猜想，<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_resolve/src/ident.rs#L279">resolve_ident_in_lexical_scope</a> 函数就是这样实现的。</p>
<p>在名字解析的过程中，Rust 分别为 types、values、macros 保存了不同的命名空间，因此下面这样的代码虽然看起比较诡异但却是合法的 Rust 代码：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">type</span> <span class="token type-definition class-name">x</span> <span class="token operator">=</span> <span class="token keyword">u32</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> x<span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// See? x is still a type here.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>名字解析是非常复杂的部分，光 <code>late.rs</code> 这个文件就有 4000 行代码了。之前我做过一个关于<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/pull/104864/files">名字解析的 PR</a>，当一个变量没在当前 <code>scope</code> 里找到的情况下尝试去 <code>inner scope</code> 找，如果找到则给出建议。这虽然是个不复杂的 PR，但我通过这个 PR 理解了这块的大致逻辑。</p>
<h3 id="Ast-validation"><a href="#Ast-validation" class="headerlink" title="Ast validation"></a>Ast validation</h3><p>这个阶段没做什么特别复杂的检查，比如这种：</p>
<ul>
<li>no more than <code>u16::MAX</code> parameters;</li>
<li>c-variadic functions are declared with at least one named argument;</li>
<li>c-variadic argument goes the last in the declaration;</li>
<li>documentation comments aren’t applied to function parameters;</li>
</ul>
<p><code>AstValidator</code> 实现了各种 <code>check_*</code> 函数，通过 <code>visitor pattern</code> 在 AST 里逐个检查对应的元素，在编译器中最常用的设计模式就是 <code>visitor pattern</code> ，所以在 <code>rust_ast</code> 里定义了这个 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/13471d3b2046cce78181dde6cfc146c09f55e29e/compiler/rustc_ast/src/visit.rs#L111">Visitor</a> 的 <code>trait</code>：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Visitor</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'ast</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token class-name">Sized</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">visit_ident</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> _ident<span class="token punctuation">:</span> <span class="token class-name">Ident</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">visit_foreign_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">ForeignItem</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">walk_foreign_item</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">visit_item</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">walk_item</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">visit_local</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> l<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Local</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">walk_local</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">visit_block</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'ast</span> <span class="token class-name">Block</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">walk_block</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有的自定义 <code>Visitor</code> 只需要实现这个 <code>trait</code> 就行了：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token class-name">Visitor</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token keyword">for</span> <span class="token class-name">AstValidator</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">visit_attribute</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> attr<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Attribute</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token namespace">validate_attr<span class="token punctuation">::</span></span><span class="token function">check_attr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>session<span class="token punctuation">.</span>parse_sess<span class="token punctuation">,</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">visit_expr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> expr<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token class-name">Expr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">...</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="HIR"><a href="#HIR" class="headerlink" title="HIR"></a>HIR</h2><p>HIR 是 rustc 中使用的主要 IR，是在解析、宏扩展和命名解析之后生成的。HIR 的许多部分与 Rust 表面语法非常相似，除了 Rust 的一些表达式形式已被脱糖。例如， <code>for</code> 循环被转换为 <code>loop</code> 并且不出现在 HIR 中，这使得 HIR 比普通 AST 更易于分析。</p>
<p>我们可以使用以下命令来展示一个程序的 <code>HIR</code> :</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rustc main.rs <span class="token parameter variable">-Z</span> <span class="token assign-left variable">unpretty</span><span class="token operator">=</span>hir-tree <span class="token operator">></span> tree.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们可以看到即使一个非常简单的程序，生产的 <code>hir</code> 也是非常长的，因为带了很多编译器里面分析使用的字段，另外 <code>HIR</code> 中也带有对应的代码行，也包括 <code>Span</code> 等这些信息，对生成诊断非常重要。<code>rustc_hir/src/intravisit.rs</code>  定义了一些方便在 <code>HIR</code> 上遍历的 <code>visitor</code>。</p>
<p>HIR 和 AST 基本是一一对应的，所以整个转换的过程就是遍历一遍 AST，代码在 <code>rustc_ast_lowering</code>。注意 HIR 里的 <code>HirId</code> 非常重要，这个 ID 是后续使用 HIR 时候经常会用到的，所以必须是唯一的。在 lowering 的过程中通过 <code>next_id</code>这个函数来生成唯一的 ID。</p>
<p>我曾经尝试做过一个比较大的 PR 来保证父节点的 HIR_ID 一定比子节点的小，但是做到后来发现代码中的递归经常需要先创建子节点，然后再创建父节点，这样 HIR_ID 就很难保证顺序，否则代码就改得很难看。如果你感兴趣可以看看能否继续做下去 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/pull/103114/files">Assign HirIds in HIR traversal order</a>。</p>
<p>语法糖什么的都会在这时候处理掉。</p>
<h3 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h3><p>类型推断是自动检测表达式类型的过程，比如以下代码：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> things <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    things<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"thing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们并没有显示声明 things 的类型，但是因为后续代码中往 things 里写入了一个字符串，所以 things 的类型可以推断出是 <code>Vec&lt;&amp;str&gt;</code>。</p>
<p>Rust 使用的是一个改进版本的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner (HM)</a> 算法，该算法最先被实现在 ML 系的编程语言中，后来被广泛采用在各种函数式编程语言里。</p>
<p>这块我目前接触也比较少，记得之前做过一个 PR 尝试修复一个 type inference 的小问题，不过没做完  <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/pull/107567">Extend Infer ty for binary operators</a>，问题看起来也比较简单</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">myfunction</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> one <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment">// ok</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> two <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>
        <span class="token operator">!</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// cannot infer type</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> three <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>
        <span class="token operator">!</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// ok</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token function">one</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">two</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">three</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>变量 <code>two</code> 不能被推导出来是因为 <code>i</code> 没有类型，虽然我们知道 <code>a</code> 的类型是 <code>Vec&lt;bool&gt;</code> ，但不能保证 <code>a[i]</code>就是 <code>bool</code> 类型，如果你感兴趣可以试试看能否解决。</p>
<p>Type inference 有其局限性，2015 年 RFC <a target="_blank" rel="noopener" href="https://rust-lang.github.io/rfcs/0803-type-ascription.html">0803-type-ascription</a> 提出来作为补充，但这个 RFC 实现了之后一直没有稳定，最终社区又提出把这个功能给去掉，而这个工作也涉及到大量的改动：<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/101728">De-RFC 3307: Remove type ascription</a>。</p>
<h2 id="MIR"><a href="#MIR" class="headerlink" title="MIR"></a>MIR</h2><p>MIR 是比 HIR 更低层次的中间表示，从 HIR 构建。MIR 方便用于控制流分析和代码优化，其中也包括 Rust 特殊的 <strong>borrow checking</strong>。MIR 的关键特性：</p>
<p>MIR 的一些关键特性是：</p>
<ul>
<li>基于控制流图</li>
<li>没有嵌套表达式</li>
<li>MIR 中的所有类型都是完全显式的</li>
</ul>
<p>更深入了解可以读官方的这篇文章 <a target="_blank" rel="noopener" href="https://blog.rust-lang.org/2016/04/19/MIR.html">Introducing MIR</a>。MIR 都是一些比较原子性的操作，离 LLVM 的 IR 比较近，所以很方便后面代码生成部分。另外为了方便做 borrow checking MIR 也会在插入一些 scope 的标签。</p>
<p>我们可以通过 <a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=30074856e62e74e91f06abd19bd72ece">Rust Playground</a> 查看生成出来的 MIR，如何基于 MIR 做数据流分析可参考 <a target="_blank" rel="noopener" href="https://rustc-dev-guide.rust-lang.org/mir/dataflow.html">MIR dataflow</a>，在 MIR 上做 <a target="_blank" rel="noopener" href="https://rustc-dev-guide.rust-lang.org/borrow_check.html#major-phases-of-the-borrow-checker">borrow checking</a> 也会更精准，NLL(non-lexical lifetime) 就是这样解决的。</p>
<h2 id="Codegen-代码生成"><a href="#Codegen-代码生成" class="headerlink" title="Codegen 代码生成"></a>Codegen 代码生成</h2><p>一直到这里为止，编译都是在做数据转换，把代码变成中间层表示，然后抽象的等级越来越低，最后把 MIR 生成 LLVM IR，然后生成二进制文件。</p>
<p>Rust 后端可以是 LLVM、Cranelift 或者 GCC，这些都依赖于第三方库来实现，所以需要最大程度共享一些基础代码，Rust 编译器本身有自己的 LLVM 绑定包。</p>
<p>在这个阶段也做了如下这些事情：</p>
<ul>
<li>为范性类型替换成具体的类型</li>
<li>为具体类型生成代码称为单态化 (<em>monomorphization</em>)</li>
<li>MIR 转换为 codegen IR</li>
<li>调用 codegen 后端生成可执行文件</li>
</ul>
<p>代码生成的入口点是 <code>rustc_codegen_ssa::base::codegen_crate</code>。</p>
<hr>
<p>总的来说，我理解 Rust 是加了些便于做静态分析的语言特性，比如 lifetime 和 borrow checking 规则，编译器内部也集成了很多静态分析功能。</p>
<p>当然我们只是从很高的维度去快速过了一遍，里面还有些特殊的部分很复杂但我还没开始细看，比如 <code>trait solving</code> 。</p>
<p>后续继续更新 😁。</p>
</section>

    <p></p>
    <!-- 二维码 START -->
    
        <div class="qrcode">
            <img src="/images/wechat-qr-code.jpg" height="160" width="160">
            <figcaption>公号同步更新，欢迎关注👻</figcaption>
      </div>
    

    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#编程" >
    <span class="tag-code">编程</span>
  </a>

  <a href="/tags#Rust" >
    <span class="tag-code">Rust</span>
  </a>

  <a href="/tags#编译器" >
    <span class="tag-code">编译器</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/03/20/chatgpt-tools.html">
        <span class="nav-arrow">← </span>
        
          人类的终极工具
        
      </a>
    
    
      <a class="nav-right" href="/2023/03/06/apple-perf.html">
        
          苹果：为了安全让 M2 吃灰
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->

    <!-- 二维码 END -->
    
      <!-- No Comment -->
    



    <script src="https://utteranc.es/client.js"
      repo="chenyukang/chenyukang.github.io"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>


  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title"></strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-nav-text">整体架构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%BC%96%E8%AF%91%E5%85%A5%E5%8F%A3"><span class="toc-nav-text">编译入口</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Lexing"><span class="toc-nav-text">Lexing</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Parsing"><span class="toc-nav-text">Parsing</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-nav-text">错误处理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AE%8F%E5%B1%95%E5%BC%80"><span class="toc-nav-text">宏展开</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Name-resolution"><span class="toc-nav-text">Name resolution</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Ast-validation"><span class="toc-nav-text">Ast validation</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#HIR"><span class="toc-nav-text">HIR</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Type-Inference"><span class="toc-nav-text">Type Inference</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#MIR"><span class="toc-nav-text">MIR</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Codegen-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-nav-text">Codegen 代码生成</span></a></li></ol>
    
  </div>
</aside>

  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://catcoding.me/2023/03/13/rustc-source.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW * 3 / 4}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer" id="footer">
    <p class="copyright">
        &copy;
        2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a> with <a target="_blank" rel="noopener" href="https://github.com/yanm1ng/hexo-theme-vexo">Vexo</a>
    </p>
</footer>

<script>
    function async(u, c) {
        var d = document,
            t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) {
            o.addEventListener('load', function(e) {
                c(null, e);
            }, false);
        }
        s.parentNode.insertBefore(o, s);
    }
</script>
<script>
    async("//catcoding.me/js/fastclick.min.js", function() {
        FastClick.attach(document.body);
    })
</script>


<script src="/js/script.js"></script>

  </body>
</html>