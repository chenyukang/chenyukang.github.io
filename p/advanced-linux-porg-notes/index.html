<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="All about coding and writing">
  <meta name="keyword" content="Programming, Programming Languages, Algorithms, Tools">
  <meta property="og:site_name" content="CatCoding">
  <meta property="og:title" content="《Advanced linux progamming》笔记 | CatCoding" />
  <meta property="og:type" content="website" />
  <meta property="og:locale" content="" />
  <meta property="og:description" content="" />
  <meta property="og:image" content=" http://catcoding.me/css/images/logo.png " />
  <link rel="alternate" type="application/rss+xml" title="CatCoding; Feed" href="https://catcoding.me/atom.xml" />

  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/fonts.css">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/code.css">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/prism.css">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
<script src="/js/jquery.min.js"></script>
<script src="/js/geopattern.min.js"></script>
<script src="/js/nprogress.min.js"></script>

  
  <link rel="icon" href="/css/images/favicon.ico">
  
  <title>
    
    《Advanced linux progamming》笔记 |
    CatCoding
    
  </title>

  <div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src="/css/images/logo.png" width='400px' height='400px' />
  </div>

  
  



<script defer src="https://cloud.umami.is/script.js" data-website-id="9767b9c8-6554-4673-af8c-2d22e00617aa"></script>
</head>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CatCoding</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/ideas/" class="item-link">Ideas</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/links/" class="item-link">Links</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      

        <li class="list-item" style="margin: 0">
       <a class="icon-small" href="/search">
        <span class="fa-stack fa-lg">
          <i class="fa fa-search fa-stack-1x fa-inverse" style="color:#8ccb8c"></i>
        </span>
       </a>
      </li>

       <li class="list-item" style="margin-left: 3px">
        <a class="icon-small" href="/atom.xml">
         <span class="fa-stack fa-lg">
           <i class="fa fa-rss fa-inverse" style="color:orange"></i>
         </span>
        </a>
       </li>
    </ul>
    
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/ideas/" class="menu-link">Ideas</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/links/" class="menu-link">Links</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>《Advanced linux progamming》笔记</h2>
  <p class="post-date">2011-06-14</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>


<main class="app-body flex-box">


  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2>Writing and using Libraries</h2>
<p class="first">链接分为动态链接和静态链接。
<h3><a name="sec2" id="sec2"></a>
Archives</h3>
<p class="first">archive(静态链接) 为目标文件的集合，linker 从 archive 文件中找到 obj 文件进行链接。
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shell bash"><span class="token function-call shell"><span class="token variable function shell"><span class="token group expansion job shell"><span class="token punctuation definition variable job shell">%</span></span></span></span><span class="token function-call arguments shell"> ar cr libtest.a test1.o test2.o</span>
</span></code></pre>
<p>创建库文件 libtest.a(类似 windows 下 test.lib)，当 linker 处理 archive 文件的时候，将在库文件中查找当前已经处理但是还没定义的 symbols。所以库文件应该出现在命令的最后。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shell bash"><span class="token function-call shell"><span class="token variable function shell"><span class="token group expansion job shell"><span class="token punctuation definition variable job shell">%</span></span></span></span><span class="token function-call arguments shell"> gcc<span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>o</span> app app.o<span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>L</span>.<span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>ltest</span></span>
</span></code></pre><h3><a name="sec3" id="sec3"></a>
Shared Library</h3>
<p class="first">Shared lib 和 archive 的两个区别：1，当进行的是动态链接，最后得到的可执行程序中不包含实际库中的执行代码，只是一个对库的引用。所以动态链接最后得到的可执行程序要小一些。2 多个程序可以共享动态链接库，动态链接库不只是 obj 文件的集合，其中是单一的一个 obj 文件，包含了库中所有的信息，所以一个程序动态加载 shared lib 的时候是把库中所有的东西都加载了，而不是所引用的那部分。
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shell bash"><span class="token function-call shell"><span class="token variable function shell"><span class="token group expansion job shell"><span class="token punctuation definition variable job shell">%</span></span></span></span><span class="token function-call arguments shell"> gcc<span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>c</span><span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>fPIC</span> test1.c</span>
<span class="token function-call shell"><span class="token variable function shell"><span class="token group expansion job shell"><span class="token punctuation definition variable job shell">%</span></span></span></span><span class="token function-call arguments shell"> gcc<span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>shared</span> - fPIC libtest.so test1.o test2.o</span>
</span></code></pre>
<p>-fPIC 选项指编译为位置独立的执行代码，这样可以动态加载，产生 libtest.so 文件。</p>
<p>默认的库文件寻找路径变量：LD_LIBRARY_PATH
库文件之间的依赖关系：如果是动态链接，链接库会自动寻找到自己所依赖的其他库文件，如果是静态链接，必须为 linker 提供所有依赖的库文件名称。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shell bash"><span class="token function-call shell"><span class="token variable function shell"><span class="token group expansion job shell"><span class="token punctuation definition variable job shell">%</span></span></span></span><span class="token function-call arguments shell"> gcc<span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>static</span><span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>o</span> tifftest tifftest.c<span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>ltiff</span><span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>ljpeg</span><span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>lz</span><span class="token variable parameter option shell"><span class="token punctuation definition parameter shell"> -</span>lm</span></span>
</span></code></pre>
<p>上面例子中 tiff 依赖 jpeg 库，因为是-static 链接，必须指明所有依赖的库文件。</p>
<h3><a name="sec4" id="sec4"></a>
Pros and Cons</h3>
<p class="first">动态链接的优势：可以减少可执行文件的 size，如果库文件进行升级，原程序可以不用重新链接。如果是静态链接，库文件改变了程序要重新进行 link。
也有一些特殊情况必须使用 static link。
<h3><a name="sec5" id="sec5"></a>
动态加载和卸载库</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token keyword c">void</span><span class="token operator c">*</span> handle <span class="token operator assignment c">=</span> <span class="token function-call c"><span class="token variable function c">dlopen</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">“libtest<span class="token punctuation accessor c">.</span><span class="token variable other member c">so</span>”<span class="token punctuation separator c">,</span> RTLD_LAZY</span></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>

<span class="token function-call c"><span class="token variable function c">void</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token operator c">*</span>test</span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token group c"><span class="token punctuation section group begin c">(</span><span class="token punctuation section group end c">)</span></span> <span class="token operator assignment c">=</span> <span class="token function-call c"><span class="token variable function c">dlsym</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">handle<span class="token punctuation separator c">,</span> “my_function”</span></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
<span class="token group c"><span class="token punctuation section group begin c">(</span><span class="token operator c">*</span>test<span class="token punctuation section group end c">)</span></span><span class="token group c"><span class="token punctuation section group begin c">(</span><span class="token punctuation section group end c">)</span></span><span class="token punctuation terminator c">;</span>
<span class="token function-call c"><span class="token variable function c">dlclose</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">handle</span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
</span></code></pre>
<p>上面例子中打开 libtest.so 动态链接库，找到 my_function 定义，执行，然后卸载库文件。</p>
<h2><a name="sec6" id="sec6"></a>
进程</h2>
<h3><a name="sec7" id="sec7"></a>
创建进程</h3>
<h4>using system</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token preprocessor include c"><span class="token keyword import include c">#include</span> <span class="token string other lt-gt include c"><span class="token punctuation definition string begin c">&lt;</span>stdlib.h<span class="token punctuation definition string end c">&gt;</span></span>
</span><span class="token keyword c">int</span> <span class="token function c"><span class="token function c">main</span></span><span class="token function c"> </span><span class="token function parameters c"><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function parameters c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token function c">
</span><span class="token function c"><span class="token block c"><span class="token punctuation section block begin c">{</span></span></span><span class="token function c"><span class="token block c">
  <span class="token keyword c">int</span> return_value<span class="token punctuation terminator c">;</span>
  return_value <span class="token operator assignment c">=</span> <span class="token function-call c"><span class="token function C99 c">system</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token string double c"><span class="token punctuation definition string begin c">&quot;</span>ls -l /<span class="token punctuation definition string end c">&quot;</span></span></span></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
  <span class="token keyword c">return</span> return_value<span class="token punctuation terminator c">;</span>
</span></span><span class="token function c"><span class="token block c"><span class="token punctuation section block end c">}</span></span></span>
</span></code></pre>
<p>system 将执行/bin/sh，然后执行命令，因为不同系统中/bin/sh 所链接的 shell 不同，所以会导致执行差异，同时这种方式存在安全隐患。</p>
<h4>using fork and exec</h4>
<p class="first">fork 创建一个子进程，fork 的返回值用来区别父进程和子进程。子进程将和拷贝父进程一些信息，更详细的东西在这本书内没说明。
<p>exec 函数家族，fork 创建一个子进程，用 exec 在子进程中执行命令。</p>
<h4>process scheduling</h4>
<p class="first">nice 命令可以调节 process 的优先权值。
niceness value 越大，进程的优先权越低，越小进程的优先权越高。一般进程的 niceness value 为 0。只有 root 的进程可以减少一个进程的 niceness value。
<h3><a name="sec8" id="sec8"></a>
signal</h3>
<p class="first">signal is asynchronous:进程收到信号的时候会立即处理信号，处理信号的一般方式分为几类：忽略，执行默认处理，执行特定的处理程序。
因为信号处理是异步的，所以在信号处理程序中尽量不要执行 IO，或者调用库函数。信号处理函数应该作最少量的工作，尽快返回到主流程中，或者干脆结束掉程序。一般只是设置变量表明某个信号发生了，主程序定时检查变量再处理。SIGTERM 和 SIGKILL 区别，前一个可能被忽略，后一个不能被忽略。
改变 sig_atomic_t 的值的操作是原子性的。
<h3><a name="sec9" id="sec9"></a>
process exit</h3>
<p class="first">exit(int return_value) 函数退出一个进程，并把 exit_code 告诉父进车。kill(pid_t,KILL_TYPE) 向某个进程发送相应的退出信号。
wait 函数家族，让父进程等待某个子进程的结束。WIFEXITED 宏判断子进程是否正常退出或者是由于其他原因意外退出。
zombie process(僵死进程) 为一个进程已经退出，但是没有进行善后处理。一个父进程有责任处理子进程的善后处理，wait 函数即为此用，父进程调用 wait 一直被阻塞 (当子进程没有退出的时候),子进程退出后 wait 函数返回。如果父进程没有为已经退出的子进程处理善后，子进程将变为 init 的子进程，然后被处理删除。
一种更好的处理方法是当子进程退出的时候发信号通知父进程，有几种方式可以实现 (进程间通信),其中一种比较方便的方式是父进程处理 SIGCHLD 信号。
<h2><a name="sec10" id="sec10"></a>
Threads</h2>
<p class="first">线程作为亲量级进程，切换引起的开销更小，一个进程的多个子线程共享进程的资源。
<h3>create thread</h3>
<p>创建线程：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token function-call c"><span class="token variable function c">pthread_create</span><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token operator c">&amp;</span>thread_id<span class="token punctuation separator c">,</span> <span class="token boolean c">NULL</span><span class="token group c"><span class="token punctuation section group begin c">(</span>pointer_to_thread_info<span class="token punctuation section group end c">)</span></span><span class="token punctuation separator c">,</span> 
               <span class="token operator c">&amp;</span>thread_func<span class="token punctuation separator c">,</span> <span class="token boolean c">NULL</span><span class="token group c"><span class="token punctuation section group begin c">(</span>argument<span class="token punctuation section group end c">)</span></span></span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span>
</span></code></pre>
<p>线程的执行顺序是异步的，不能假设其执行顺序。向 thread 传递数据：可以通过 pthread_create 的地四个参数，传递一个 void* 的指针，指针指向一个数据结构体。注意在多线程中的数据空间的销毁。</p>
<p>More about thread_id:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token keyword c">if</span> <span class="token group c"><span class="token punctuation section group begin c">(</span><span class="token operator arithmetic c">!</span><span class="token function-call c"><span class="token variable function c">pthread_equal</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token function-call c"><span class="token variable function c">pthread_self</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation separator c">,</span> other_thread</span></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation section group end c">)</span></span>
  <span class="token function-call c"><span class="token variable function c">pthread_join</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">other_thread<span class="token punctuation separator c">,</span> <span class="token boolean c">NULL</span></span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
</span></code></pre>
<p>Thread Attributes，为了设定线程的某些属性，detach 线程退出后自动回首资源，joinable 则等到另一个线程调用 pthread_jion 获得其返回值。</p>
<p>Thread-specific data:每个线程都有一份自己的拷贝，修改自己的数据不会影响到其他线程。</p>
<p>Cleanup Handlers:使用 pthread_cleanup_push(function,param) 和 pthread_cleanup_pop(int) 在线程退出的时候自动调用清理函数，释放资源。</p>
<p>多线程程序可能出现的问题：竞争，需要使用 atomic 操作。</p>
<h3><a name="sec11" id="sec11"></a>
互斥锁</h3>
<p class="first">只有一个线程能够拥有，此时其他线程访问互斥锁将被阻塞。
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token class-name pthread c">pthread_mutex_t</span> mutex<span class="token punctuation terminator c">;</span>
<span class="token function-call c"><span class="token variable function c">pthread_mutex_init</span><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token operator c">&amp;</span>mutex<span class="token punctuation separator c">,</span><span class="token boolean c">NULL</span></span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>

<span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>或者 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
</span><span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>线程中使用 pthread_mutex_lock 和 pthread_mutex_unlock 来锁住和解锁互斥锁，
</span>
<span class="token operator comparison c">&lt;</span>h3<span class="token operator comparison c">&gt;</span><span class="token operator comparison c">&lt;</span>a name<span class="token operator assignment c">=</span><span class="token string double c"><span class="token punctuation definition string begin c">&quot;</span>sec12<span class="token punctuation definition string end c">&quot;</span></span> id<span class="token operator assignment c">=</span><span class="token string double c"><span class="token punctuation definition string begin c">&quot;</span>sec12<span class="token punctuation definition string end c">&quot;</span></span><span class="token operator comparison c">&gt;</span><span class="token operator comparison c">&lt;</span><span class="token operator arithmetic c">/</span>a<span class="token operator comparison c">&gt;</span>
Semaphores for Threads<span class="token operator comparison c">&lt;</span><span class="token operator arithmetic c">/</span>h3<span class="token operator comparison c">&gt;</span>

<span class="token operator comparison c">&lt;</span>p class<span class="token operator assignment c">=</span><span class="token string double c"><span class="token punctuation definition string begin c">&quot;</span>first<span class="token punctuation definition string end c">&quot;</span></span><span class="token operator comparison c">&gt;</span>sem_t 可以作为一个 share counter 来使用，

```c
sem_t job_queue_count<span class="token punctuation terminator c">;</span>

<span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>initialize
</span><span class="token function-call c"><span class="token variable function c">sem_init</span><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token operator c">&amp;</span>job_queue_count<span class="token punctuation separator c">,</span><span class="token number c">0</span><span class="token punctuation separator c">,</span><span class="token number c">0</span></span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>

<span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>wait for
</span><span class="token function-call c"><span class="token variable function c">sem_wait</span><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token operator c">&amp;</span>job_queue_count</span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
<span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>lock mutext
</span><span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>and do somethting
</span><span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>unlock
</span>
<span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>new job
</span><span class="token function-call c"><span class="token variable function c">sem_post</span><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token operator c">&amp;</span>job_queue_count</span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span>
</span></code></pre><h3><a name="sec13" id="sec13"></a>
Threads VS Process</h3>
<p class="first">Guidelines:
<p>1，所有线程所执行的指令必须是在一个可执行文件里面，而多进程可以执行多个命令。</p>
<p>2，因为多个线程共享相同的虚拟内存地址，所以一个线程的错误可能会影响到其他线程，而多进程程序中一个进程的错误不会影响到其他进程。</p>
<p>3，为新进程拷贝内存将增加开销，但是只有在新进程写其内存的时候才会进行拷贝 (写拷贝)。</p>
<p>4，多线程适用于多个相似的执行任务，而多进程可以执行不同类型的任务。</p>
<p>5，多个线程中共享数据要容一些，但是也会产生相关问题 (条件竞争，死锁)，多个进程共享数据难一些，使用 IPC 机制，虽然实现要难一些，但是不容易出现并发 bug。</p>
<h2><a name="sec14" id="sec14"></a>
Interprocess Communication</h2>
<h3><a name="sec15" id="sec15"></a>
Share Memory</h3>
<p class="first">share Memeory 是最简单的进程间共享数据的方式。
<h4>Allocation</h4>
<p class="first">shmget 函数创建或者访问一个已经存在的 share mem。
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token keyword c">int</span> segment_id <span class="token operator assignment c">=</span> <span class="token function-call c"><span class="token variable function c">shmget</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">shm_key<span class="token punctuation separator c">,</span> <span class="token function-call c"><span class="token variable function c">getpagesize</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation separator c">,</span>
                         IPC_CREAT <span class="token operator arithmetic c">|</span> S_IRUSR <span class="token operator arithmetic c">|</span> S_IWUSER</span></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>

</span></code></pre><h4>Attachment and Detachment</h4>
<p class="first">函数 shmat(SHMID,pointer to address,flag) 使得一个进程 attach 到一个共享内存。进程通过 fork 创建的子进程也将继承这一共享内存。函数 shmdt(address) 将 detach 共享内存。
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token keyword c">int</span> segment_size<span class="token punctuation terminator c">;</span>
<span class="token keyword c">const</span> <span class="token keyword c">int</span> shared_segment_size<span class="token operator assignment c">=</span><span class="token number c">0x6400</span><span class="token punctuation terminator c">;</span>

<span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>allocate a shared mem
</span>
segment_id<span class="token operator assignment c">=</span><span class="token function-call c"><span class="token variable function c">shmget</span><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">IPC_PRIVATE<span class="token punctuation separator c">,</span>shared_segment_size<span class="token punctuation separator c">,</span>
                  IPC_CREAT<span class="token operator arithmetic c">|</span>IPC_EXCL<span class="token operator arithmetic c">|</span>S_IRUSR<span class="token operator arithmetic c">|</span>S_IWUSR</span></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
<span class="token comment double-slash c"><span class="token punctuation definition comment c">//</span>atach the share mem
</span>share_memory <span class="token operator assignment c">=</span> <span class="token group c"><span class="token punctuation section group begin c">(</span><span class="token keyword c">char</span><span class="token operator c">*</span><span class="token punctuation section group end c">)</span></span><span class="token function-call c"><span class="token variable function c">shmat</span><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">segment_id<span class="token punctuation separator c">,</span><span class="token number c">0</span><span class="token punctuation separator c">,</span><span class="token number c">0</span></span></span><span class="token function-call c"><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
<span class="token function-call c"><span class="token variable function c">printf</span><span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c"><span class="token string double c"><span class="token punctuation definition string begin c">&quot;</span>share memory attached at addreass <span class="token constant placeholder c">%p</span><span class="constant character escape c">\n</span><span class="token punctuation definition string end c">&quot;</span></span><span class="token punctuation separator c">,</span>share_memory</span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
</span></code></pre><h4>Control share mem</h4>
<p class="first">函数调用 exit 或者 exec 可以 detach 一个共享内存，但是并没有释放它。
必须调用 shmctl 去释放其空间。ipcs -m 命令可以查看系统中当前的 share mem 的信息，如果没有删除遗留的 shared mem，其 nattch 为 0。可以使用 ipcrm shm segment_id 删除。
<h3><a name="sec16" id="sec16"></a>
Process Semaphores</h3>
<p class="first">semaphore 和 shared memory 的使用方式类似，可以通过 semget,shmctl 创建和删除，提供的参数表明要创建 semaphore。
没详细说，查看其他书。
<h3><a name="sec17" id="sec17"></a>
Mapped memory</h3>
<p class="first">Mapped memory 是不同进程可以通过一个公用的共享文件进行交流。Mapped mem 在进程是进程和文件的一个桥梁，linux 通过把文件映射到虚拟内存，这样进程可以像访问普通内存一样访问该文件。
void* mmap(address,LENGTH,prot_option,option,file_rp,pos) //将一个文件映射到 address，如果不提供系统将映射到合适的地址
munmap(file_memory,FILE_LENGTH);// 释放 memory
设置了 MAP_SHARED，多个进程可以通过同一文件访问该内存区。
<h3><a name="sec18" id="sec18"></a>
管道</h3>
<h4>pipe</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token keyword c">int</span> pipe_fds<span class="token brackets c"><span class="token punctuation section brackets begin c">[</span><span class="token number c">2</span><span class="token punctuation section brackets end c">]</span></span><span class="token punctuation terminator c">;</span>
<span class="token keyword c">int</span> read_fd<span class="token punctuation terminator c">;</span>

<span class="token keyword c">int</span> write_fd<span class="token punctuation terminator c">;</span>
<span class="token function-call c"><span class="token variable function c">pipe</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">pipe_fds</span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
read_fd <span class="token operator assignment c">=</span> pipe_fds<span class="token brackets c"><span class="token punctuation section brackets begin c">[</span><span class="token number c">0</span><span class="token punctuation section brackets end c">]</span></span><span class="token punctuation terminator c">;</span>
write_fd <span class="token operator assignment c">=</span> pipe_fds<span class="token brackets c"><span class="token punctuation section brackets begin c">[</span><span class="token number c">1</span><span class="token punctuation section brackets end c">]</span></span><span class="token punctuation terminator c">;</span>
</span></code></pre>
<p>pipe_fds[0] 为 reading file desc,pipe_fds<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>为 writing file desc。Pipe 只能用于同一个进程的子进程之间。
dup2 重定向标准输入输出符。</p>
<p>popen,pclose 很方便，FILE* stream=popen("progam","w") 向 program 发送。pclose(stream) 关闭。</p>
<h4>FIFO</h4>
<p class="first">为有名字的 pipe，任何不相关的两个进程可以通过 fifo 来进行数据传递。mkfifo 函数创建 FIFO。
<h3><a name="sec19" id="sec19"></a>
Socket</h3>
<p class="first">系统调用：
<pre class="example">
socket-- Creates a socket
close -- Destroys a socket
connect -- Creates a connection between two sockets
bind -- Labels a server socket with an address
listen -- Configures a socket to accept conditions
accept -- Accepts a connection and creates a new socket for the connection
</pre>
<p>Unix-domain sockets 能用于同一机器上的进程通信。Internet-domain sockets 用于不同机子上的通信。
struct sockaddr_in  addr 类型变量为其地址结构。
addr.sin_family=AF_INET
addr.sin_addr 存储一个 32bit 的 IP 地址。</p>
<p>只是给了两个程序例子，详细内容看网络编程相关书籍。</p>
<h2><a name="sec20" id="sec20"></a>
Mastering Linux</h2>
<h3><a name="sec21" id="sec21"></a>
Device</h3>
<p class="first">分为字符设备和块设备，块设备可一随机访问，字符设备提供流。一般应用程序不会直接访问块设备，而是通过系统调用来使用块设备。
设备号，主设备号是根据设备类型分的，从设备号根据具体设备分。
cat /proc/devices 查看设备类型和主设备号。
<h3><a name="sec22" id="sec22"></a>
Device Entry</h3>
<p class="first">只有 root 的进程可以通过 mknod 创建新的 Device Entry。
mknod name b/c 主设备号 从设备号
<p>linux 目录/dev 下面是系统所支持的 Device Entry。
字符设备可以像一般文件一样访问，甚至可以用重定向去访问。</p>
<pre class="example">
cat somefile &gt; /dev/audio
可以发出声音了

</pre>
<p>特殊设备：/dev/null /dev/zero /dev/full /dev/random /dev/urandom
Loopback Devices:环回设备，在文件系统上新建一个普通文件，可用于模拟特定设备，比如软盘。
也可把实际设备中的内容拷贝到其中，比如把光盘中的内容拷贝到新建的一个 cdrom-image 中。</p>
<h3><a name="sec23" id="sec23"></a>
/proc</h3>
<p class="first">mount 命令可以看到一行输出：proc on /proc type proc (rw,noexec,nosuid,nodev)
/proc 包含系统的一些配置信息，不和任何设备相关联。
<pre class="example">
$cat /proc/version 查看内核版本
$cat /proc/cpuinfo 查看 cpu 信息
</pre>
<p>/proc 目录下同时包含系统中当前的进程信息，由于权限设置，有的只能由进程本身访问。可以通过访问文件获取系统中进程的相关信息，
比如参数，运行环境，内存使用信息等等。</p>
<h2><a name="sec24" id="sec24"></a>
Linux system call</h2>
<p>system call 和一般的 C 库函数的区别：系统调用一般通过门陷入实现，是系统内核和用户程序的接口，运行过程中会进入系统内核。C 库函数一般和普通的函数没有区别。</p>
<p>strace:该命令可以追踪一个程序执行过程中的调用的 system call。<br>
access:测试进程对于一个文件的权限。 int access(path,bit_flag),注意返回值和 errno。<br>
fcntl:锁住文件和控制文件操作。<br>
fsync,fdatasync:flush disk buffer。<br>
getrlimit,setrlimit:资源限制设置。<br>
getusage:获取进程的统计信息。<br>
gettimeofday:获取 wall_clock time。<br>
mlock:锁住一段物理内存，使得该内存不能因为 swap 换出，一些速度要求很高的和安全性要求很高的代码会使用这个功能。 mlock(address,mem_length)<br>
mprotect:设置内存的权限。<br>
nanosleep:高分辨率睡眠函数。<br></p>
<p>readlink:read symbolic links。<br>
sendfile:Fast file Transfer。<br>
setitimer:定时器。<br>
sysinfo:获取系统统计信息。<br>
uname:获取系统版本信息和硬件信息。<br></p>
<h2><a name="sec25" id="sec25"></a>
Inline Assembly Code</h2>
<p class="first">/usr/include/asm/io.h 定义了汇编代码中能够直接访问的端口。
/usr/src/linux/include/asm and /usr/src/linux/include/asm-i386 linux 内核中汇编代码头文件
/usr/src/linux/arch/i386/ and /usr/src/linux/drivers/  汇编代码
当使用特定平台的汇编代码时使用宏和函数来简化兼容问题。
<h2><a name="sec26" id="sec26"></a>
Security</h2>
<h3><a name="sec27" id="sec27"></a>
用户组 文件 进程权限</h3>
<p>用户和组的概念<br>
超级用户 无穷权力<br></p>
<p>proccess user id 和 proccess group id。进程开始的时候其 id 和启动该程序的用户信息相同。<br>
文件权限 chmod stat(filename,&amp;(struct stat))<br>
program without Execution Permissions: a security hole。 其他用户能够拷贝该文件，然后修改其权限。<br>
Sticky bit:用于文件夹，当一个文件夹的 sticky bit 设置了后，要删除该文件夹下的一个文件必须拥有对该文件的拥有权，即使已经拥有该文件夹访问权。Linux 下的/tmp 设置了 sticky bit。<br>
Real and Effective ID::EID 代表进程所具有的系统权限，如果是非 root 用户，EID=RID；只有 root 用户可以改变它的 EID 为任何有效的用户 ID。<br>
su 命令：是一个 setuid 程序，当程序执行的时候其 EID 是文件的拥有者，而不是启动程序的用户号。chmod a+s 使得文件有这个属性。<br></p>
<h3><a name="sec28" id="sec28"></a>
<p>缓冲区漏洞</h3></p>
<p>如果栈中有固定长度的输入区，则会含有缓冲区漏洞。最通常的形式：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token c"><span class="token keyword c">char</span> username<span class="token brackets c"><span class="token punctuation section brackets begin c">[</span><span class="token number c">32</span><span class="token punctuation section brackets end c">]</span></span><span class="token punctuation terminator c">;</span>
<span class="token operator arithmetic c">/</span> Prompt the user <span class="token keyword c">for</span> the username<span class="token punctuation accessor c">.</span> <span class="token operator arithmetic c">/</span>
<span class="token function-call c"><span class="token variable function c">printf</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">“Enter your username<span class="token operator ternary c">:</span> “</span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>

<span class="token operator arithmetic c">/</span> Read a line of input<span class="token punctuation accessor c">.</span> <span class="token operator arithmetic c">/</span>
<span class="token function-call c"><span class="token variable function c">gets</span> <span class="token group c"><span class="token punctuation section group begin c">(</span></span></span><span class="token function-call c"><span class="token group c">username</span><span class="token group c"><span class="token punctuation section group end c">)</span></span></span><span class="token punctuation terminator c">;</span>
<span class="token operator arithmetic c">/</span> Do other things here… <span class="token operator arithmetic c">/</span>
</span></code></pre>
<p>攻击者可以故意使得缓冲区读满，然后在超出的区域植入想执行的代码段，获得控制权。</p>
<h3><a name="sec29" id="sec29"></a>
Race Conditions in /tmp</h3>
<p class="first">攻击者先创建一个链接，如果应用程序在/tmp 下创建打开一个相同名称的文件，所有写入的数据将传送到链接所指向的文件里。
解决方法：在文件名称内使用 Random，open 函数使用 O_EXCL 参数，如果文件存在则失败，打开一个文件后用 lstat 查看是否是链接文件，检查文件的所有者是否和进程所有者一样。
/tmp 文件不能挂载在 NFS 下，因为 O_EXCL 不能在 NFS 文件系统下使用。
<h3><a name="sec30" id="sec30"></a>
system ,popen 函数的危险</h3>
<p class="first">替代使用 exec 族函数。
<!-- Page published by Emacs Muse ends here -->
</section>

    <p></p>

  
    <!-- 二维码 START -->
    
        <div class="qrcode">
            <img src="/images/wechat-qr-code.jpg" height="160" width="160">
            <figcaption>公号同步更新，欢迎关注👻</figcaption>
      </div>
    

    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#" >
    <span class="tag-code"></span>
  </a>

  <a href="/tags#" >
    <span class="tag-code"></span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/p/wumpus-and-2/">
        <span class="nav-arrow">← </span>
        
          Wumpus and “Land of Lisp”
        
      </a>
    
    
      <a class="nav-right" href="/p/554/">
        
          从豆瓣 FM 下载喜欢的音乐
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->

    <!-- 二维码 END -->
    
      <!-- No Comment -->
    

    <script src="https://utteranc.es/client.js"
      repo="chenyukang/chenyukang.github.io"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>


  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title"></strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Writing-and-using-Libraries"><span class="toc-nav-text">Writing and using Libraries</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Archives"><span class="toc-nav-text">
Archives</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Shared-Library"><span class="toc-nav-text">
Shared Library</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Pros-and-Cons"><span class="toc-nav-text">
Pros and Cons</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#动态加载和卸载库"><span class="toc-nav-text">
动态加载和卸载库</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#进程"><span class="toc-nav-text">
进程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#创建进程"><span class="toc-nav-text">
创建进程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#using-system"><span class="toc-nav-text">using system</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#using-fork-and-exec"><span class="toc-nav-text">using fork and exec</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#process-scheduling"><span class="toc-nav-text">process scheduling</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#signal"><span class="toc-nav-text">
signal</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#process-exit"><span class="toc-nav-text">
process exit</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Threads"><span class="toc-nav-text">
Threads</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#create-thread"><span class="toc-nav-text">create thread</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#互斥锁"><span class="toc-nav-text">
互斥锁</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Threads-VS-Process"><span class="toc-nav-text">
Threads VS Process</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Interprocess-Communication"><span class="toc-nav-text">
Interprocess Communication</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Share-Memory"><span class="toc-nav-text">
Share Memory</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Allocation"><span class="toc-nav-text">Allocation</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Attachment-and-Detachment"><span class="toc-nav-text">Attachment and Detachment</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Control-share-mem"><span class="toc-nav-text">Control share mem</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Process-Semaphores"><span class="toc-nav-text">
Process Semaphores</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Mapped-memory"><span class="toc-nav-text">
Mapped memory</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#管道"><span class="toc-nav-text">
管道</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#pipe"><span class="toc-nav-text">pipe</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#FIFO"><span class="toc-nav-text">FIFO</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Socket"><span class="toc-nav-text">
Socket</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Mastering-Linux"><span class="toc-nav-text">
Mastering Linux</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Device"><span class="toc-nav-text">
Device</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Device-Entry"><span class="toc-nav-text">
Device Entry</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#proc"><span class="toc-nav-text">
/proc</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Linux-system-call"><span class="toc-nav-text">
Linux system call</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Inline-Assembly-Code"><span class="toc-nav-text">
Inline Assembly Code</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Security"><span class="toc-nav-text">
Security</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#用户组-文件-进程权限"><span class="toc-nav-text">
用户组 文件 进程权限</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#缓冲区漏洞"><span class="toc-nav-text">
缓冲区漏洞</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Race-Conditions-in-tmp"><span class="toc-nav-text">
Race Conditions in /tmp</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#system-popen-函数的危险"><span class="toc-nav-text">
system ,popen 函数的危险</span></a></li></ol></li></ol>
    
  </div>
</aside>

  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://catcoding.me//p/advanced-linux-porg-notes/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW * 3 / 4}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer" id="footer">
    <p class="copyright">
        &copy;
        2026 | Proudly powered by <a href="https://github.com/chenyukang/hexo-rs" target="_blank">hexo-rs</a> with <a href="https://github.com/yanm1ng/hexo-theme-vexo">Vexo</a>
    </p>
</footer>

<script>
    function async(u, c) {
        var d = document,
            t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) {
            o.addEventListener('load', function(e) {
                c(null, e);
            }, false);
        }
        s.parentNode.insertBefore(o, s);
    }
</script>
<script>
    async("//catcoding.me/js/fastclick.min.js", function() {
        FastClick.attach(document.body);
    })
</script>

<script src="/js/script.js"></script>
  </body>
</html>