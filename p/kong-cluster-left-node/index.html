<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="All about coding and software">
  <meta name="keyword" content="Programming, Programming Languages, Algorithms, Tools">
  
    <link rel="shortcut icon" href="/css/images/favicon.ico">
  
  <title>
      
          Kong 集群 Left Cluster Node 问题 | 程序员的喵
      
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/fonts.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/code.css">


  <!-- <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  -->

  
<script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
<script src="/js/highlight.min.js"></script>
<script src="/js/jquery.min.js"></script>
<script src="/js/geopattern.min.js"></script>
<script src="/js/nprogress.min.js"></script>


  <div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
      <img src="/css/images/logo.png" width='400px' height='400px'/>
  </div>

  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  



  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-77282254-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-77282254-1');
</script>

<meta name="generator" content="Hexo 5.4.1"></head>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>程序员的喵</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      

       <li class="list-item" style="margin: 0;">
        <a class="icon-small" href="/atom.xml">
         <span class="fa-stack fa-lg">
           <i class="fa fa-rss fa-inverse" style="color:orange"></i>
         </span>
        </a>
       </li>
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Kong 集群 Left Cluster Node 问题</h2>
  <p class="post-date">2018-03-04</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Kong 在实践中会有一些疑惑的地方，这里记录一下。注意这里记录的 Kong 集群部署的问题是 0.10.3 版本的，最新 Kong 版本已经不是通过 serf 来管理不同节点之间的配置同步问题。</p>
<p>在 Kong 多节点部署的时候，有时候某个节点停掉后，我们在后台可以看到 left 的信息，而且这个 left 信息会保留一段不短的时间。类似于如下： </p>
<p><img src="/images/kong-left-0133521.png" alt="kong-left"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>管理后台 Konga 是通过 api 获取的节点信息，在<code>kong/kong/api/routes/cluster.lua</code>文件里可以看到如下路由处理逻辑： </p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">GET = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, dao_factory, helpers)</span></span><br>  <span class="hljs-keyword">local</span> members, err = singletons.serf:members()<br>  <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> responses.send_HTTP_INTERNAL_SERVER_ERROR(err)<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> result = &#123;data = &#123;&#125;&#125;<br>  <span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(members) <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">self</span>.params.<span class="hljs-built_in">status</span> <span class="hljs-keyword">or</span> (<span class="hljs-built_in">self</span>.params.<span class="hljs-built_in">status</span> <span class="hljs-keyword">and</span> v.<span class="hljs-built_in">status</span> == <span class="hljs-built_in">self</span>.params.<span class="hljs-built_in">status</span>) <span class="hljs-keyword">then</span><br>      table_insert(result.data, &#123;<br>        name = v.name,<br>        address = v.addr,<br>        <span class="hljs-built_in">status</span> = v.<span class="hljs-built_in">status</span><br>      &#125;)<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><br>  result.total = #result.data<br>  <span class="hljs-keyword">return</span> responses.send_HTTP_OK(result)<br><span class="hljs-keyword">end</span>,<br></code></pre></td></tr></table></figure>
<p>具体<code>serf:members()</code>的实现在 serf.lua 里面可以看到，就是执行了<code>serf cluster members</code>命令获取结果然后返回 JSON。所以我们在服务器上执行这个命令其实也可以看到类似的结果： </p>
<p><img src="/images/kong-left-cmd.png" alt="kong-left-cmd"></p>
<p>那么问题的根源当然是在 Serf 本身里面，通过看文档发现原来确实是有一定延迟的。</p>
<blockquote>
<p>Serf keeps the state of dead nodes around for a set amount of time, so that when full syncs are requested, the requester also receives information about dead nodes. Because SWIM doesn’t do full syncs, SWIM deletes dead node state immediately upon learning that the node is dead. This change again helps the cluster converge more quickly.</p>
<p><a target="_blank" rel="noopener" href="https://www.serf.io/docs/internals/gossip.html#lifeguard-enhancements">参考 serf 文档»</a></p>
</blockquote>
<h4 id="serf-的具体实现"><a href="#serf-的具体实现" class="headerlink" title="serf 的具体实现"></a>serf 的具体实现</h4><p>接着稍微看了一下 Serf 的代码，果然 Go 的项目代码直观好读。在 Serf 这个结构体里面保存了一个 leftMembers 的状态列表，每次收到 left 事件的时候处理逻辑是： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// handleNodeLeaveIntent is called when an intent to leave is received.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Serf)</span></span> handleNodeLeaveIntent(leaveMsg *messageLeave) <span class="hljs-type">bool</span> &#123;<br>  ..................<br>    <br>  <span class="hljs-comment">// State transition depends on current state</span><br>  <span class="hljs-keyword">switch</span> member.Status &#123;<br>  <span class="hljs-keyword">case</span> StatusAlive:<br>    member.Status = StatusLeaving<br>    member.statusLTime = leaveMsg.LTime<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">case</span> StatusFailed:<br>    member.Status = StatusLeft<br>    member.statusLTime = leaveMsg.LTime<br><br>    <span class="hljs-comment">// Remove from the failed list and add to the left list. We add</span><br>    <span class="hljs-comment">// to the left list so that when we do a sync, other nodes will</span><br>    <span class="hljs-comment">// remove it from their failed list.</span><br>    s.failedMembers = removeOldMember(s.failedMembers, member.Name)<br>    s.leftMembers = <span class="hljs-built_in">append</span>(s.leftMembers, member)<br>        <br>        ................<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过索引变量发现这个列表会定时通过<code>handleReap</code>函数更新，逻辑如下： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// handleReap periodically reaps the list of failed and left members, as well</span><br><span class="hljs-comment">// as old buffered intents.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Serf)</span></span> handleReap() &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(s.config.ReapInterval):<br>      s.memberLock.Lock()<br>      now := time.Now()<br>      s.failedMembers = s.reap(s.failedMembers, now, s.config.ReconnectTimeout)<br>      s.leftMembers = s.reap(s.leftMembers, now, s.config.TombstoneTimeout)<br>      reapIntents(s.recentIntents, now, s.config.RecentIntentTimeout)<br>      s.memberLock.Unlock()<br>    <span class="hljs-keyword">case</span> &lt;-s.shutdownCh:<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以看起来这里相关的 Timeout 是<code>s.config.TombstoneTimeout</code>, 接着需要看看<code>reap</code>到底做了什么，这里果然是把到了一定时间间隔的节点删掉了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// reap is called with a list of old members and a timeout, and removes</span><br><span class="hljs-comment">// members that have exceeded the timeout. The members are removed from</span><br><span class="hljs-comment">// both the old list and the members itself. Locking is left to the caller.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Serf)</span></span> reap(old []*memberState, now time.Time, timeout time.Duration) []*memberState &#123;<br>  n := <span class="hljs-built_in">len</span>(old)<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>    m := old[i]<br><br>    <span class="hljs-comment">// Skip if the timeout is not yet reached</span><br>    <span class="hljs-keyword">if</span> now.Sub(m.leaveTime) &lt;= timeout &#123;<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br><br>    <span class="hljs-comment">// Delete from the list</span><br>    old[i], old[n<span class="hljs-number">-1</span>] = old[n<span class="hljs-number">-1</span>], <span class="hljs-literal">nil</span><br>    old = old[:n<span class="hljs-number">-1</span>]<br>    n--<br>    i--<br><br>    ..........<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> old<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么这个时间间隔是多久呢，在<code>serf/config.go</code>有一个默认配置： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">TombstoneTimeout:             <span class="hljs-number">24</span> * time.Hour,  <br></code></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>serf 这个软件值得好好分析一下，节点的状态同步和事件处理都是分布式软件的基础，后续继续看看这个<code>gossip protocol based on SWIM</code>的具体实现。另外<a target="_blank" rel="noopener" href="https://www.hashicorp.com/">hashicorp</a>这个公司的开源代码和文档都非常好，值得学习一番。</p>
</section>

    <p></p>
    <!-- 二维码 START -->
    
        <div class="qrcode">
            <img src="/images/wechat-qr-code.png" height="125" width="125">
            <figcaption>公号同步更新，欢迎关注👻</figcaption>
      </div>
    

    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Tools" >
    <span class="tag-code">Tools</span>
  </a>

  <a href="/tags#Kong" >
    <span class="tag-code">Kong</span>
  </a>

  <a href="/tags#Golang" >
    <span class="tag-code">Golang</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/p/sql-injection-attack/">
        <span class="nav-arrow">← </span>
        
          SQL Injection attack
        
      </a>
    
    
      <a class="nav-right" href="/p/docker-postgres-password/">
        
          Docker compose 初始化失败问题
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->

    <!-- 二维码 END -->
    
      <!-- No Comment -->
    

    <script src="https://utteranc.es/client.js"
      repo="chenyukang/chenyukang.github.io"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>

  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title"></strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-nav-text">问题</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%88%86%E6%9E%90"><span class="toc-nav-text">分析</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#serf-%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">serf 的具体实现</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-nav-text">其他</span></a></li></ol>
    
  </div>
</aside>

  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://catcoding.me/p/kong-cluster-left-node/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer" id="footer">
    <p class="copyright">
        &copy;
        2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a> with <a target="_blank" rel="noopener" href="https://github.com/yanm1ng/hexo-theme-vexo">Vexo</a>
    </p>
</footer>

<script>
    function async(u, c) {
        var d = document,
            t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) {
            o.addEventListener('load', function(e) {
                c(null, e);
            }, false);
        }
        s.parentNode.insertBefore(o, s);
    }
</script>
<script>
    async("//catcoding.me/js/fastclick.min.js", function() {
        FastClick.attach(document.body);
    })
</script>

<script>
    var hasLine = 'false';
    async("//catcoding.me/js/highlight.min.js", function() {
        $('figure pre').each(function(i, block) {
            var figure = $(this).parents('figure');
            if (hasLine === 'false') {
                figure.find('.gutter').hide();
            }
            var lang = figure.attr('class').split(' ')[1] || 'code';
            var codeHtml = $(this).html();
            var codeTag = document.createElement('code');
            codeTag.className = lang;
            codeTag.innerHTML = codeHtml;
            $(this).attr('class', '').empty().html(codeTag);
            figure.attr('data-lang', lang.toUpperCase());
            hljs.highlightBlock(block);
        });
    })
</script>
<!-- Baidu Tongji -->

        
<script src="/js/script.js"></script>

  </body>
</html>