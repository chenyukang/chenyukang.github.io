<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="All about coding and writing">
  <meta name="keyword" content="Programming, Programming Languages, Algorithms, Tools">
  <meta property="og:site_name" content="CatCoding">
  <meta property="og:title" content="零知识证明入门 | CatCoding" />
  <meta property="og:type" content="website" />
  <meta property="og:locale" content="" />
  <meta property="og:description" content="" />
  <meta property="og:image" content=" http://catcoding.me/css/images/logo.png " />
  <link rel="alternate" type="application/rss+xml" title="CatCoding; Feed" href="https://catcoding.me/atom.xml" />

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/fonts.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/code.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/prism.css">

  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">

  
<script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
<script src="/js/jquery.min.js"></script>
<script src="/js/geopattern.min.js"></script>
<script src="/js/nprogress.min.js"></script>


  
  <link rel="shortcut icon" href="/css/images/favicon.ico">
  
  <title>
    
    零知识证明入门 |
    CatCoding
    
  </title>

  <div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
    <img src="/css/images/logo.png" width='400px' height='400px' />
  </div>

  
  
      <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  



<script defer src="https://cloud.umami.is/script.js" data-website-id="9767b9c8-6554-4673-af8c-2d22e00617aa"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>CatCoding</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/ideas/" class="item-link">Ideas</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/links/" class="item-link">Links</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      

        <li class="list-item" style="margin: 0">
       <a class="icon-small" href="/search">
        <span class="fa-stack fa-lg">
          <i class="fa fa-search fa-stack-1x fa-inverse" style="color:#8ccb8c"></i>
        </span>
       </a>
      </li>

       <li class="list-item" style="margin-left: 3px">
        <a class="icon-small" href="/atom.xml">
         <span class="fa-stack fa-lg">
           <i class="fa fa-rss fa-inverse" style="color:orange"></i>
         </span>
        </a>
       </li>
    </ul>
    
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/ideas/" class="menu-link">Ideas</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/links/" class="menu-link">Links</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>零知识证明入门</h2>
  <p class="post-date">2025-09-26</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>


<main class="app-body flex-box">


  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>无论是在聊 L2、隐私还是下一代 Web 技术，零知识证明都是经常会碰到的技术术语，听起来就像是科幻小说里的东西：<strong>向你证明我知道一个秘密，但绝不透露这个秘密本身</strong>，这简直是程序员的终极浪漫。</p>
<p>大多数人粗看都会觉得这东西是密码学博士们的专属玩具，我花了一段时间学习后，发现这条通往魔法世界的路似乎有迹可循，希望这篇入门介绍能帮助到更多这方向的学习者。</p>
<h2 id="魔法洞穴"><a href="#魔法洞穴" class="headerlink" title="魔法洞穴"></a>魔法洞穴</h2><p>忘掉所有数学，我们先从一个故事开始——“阿里巴巴洞穴”，这是理解 ZKP 最经典的例子，最早由 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Jean-Jacques_Quisquater" title="Jean-Jacques Quisquater">Jean-Jacques Quisquater</a> 等人于 1990 年在他们的论文《如何向你的孩子解释零知识协议》中发表。</p>
<p>想象一个环形洞穴，A、B 两个入口在前方，深处有一扇只有知道咒语才能打开的魔法门。Alice 知道咒语，现在，Alice 想向 Bob 证明她知道咒语，但又不想让 Bob 听到咒语是什么。</p>
<p><img src="/images/ob_pasted-image-20250915175921.png" alt=""></p>
<p>他们可以这样玩一个游戏：</p>
<ol>
<li><p><strong>承诺 (Commitment)</strong>：Alice，作为证明者 (Prover)，独自进入洞穴。然后可以随机从 A 口进，也可以从 B 口进。Bob 在洞外等着，但不知道 Alice 走了哪条路。</p>
</li>
<li><p><strong>挑战 (Challenge)</strong>：Bob 作为验证者 (Verifier)，走到洞口然后随机喊出一个要求，比如：“从 B 通道出来！”</p>
</li>
<li><p><strong>响应 (Response)</strong>：Alice 听到要求后：</p>
<ul>
<li>如果她当初就是从 B 进去的，那简单，就直接从 B 走出来。</li>
<li>如果她当初是从 A 进去的，就必须念动咒语打开那扇魔法门穿过去，然后从 B 通道出来。</li>
</ul>
</li>
<li><p><strong>验证 (Verification)</strong>：Bob 看到 Alice 确实从 B 通道出来了，他对 Alice 的信任度增加了一点。</p>
</li>
</ol>
<p>为什么说“一点”呢？因为如果 Alice 不知道咒语，她仍然有 50% 的概率蒙对（比如 Alice 从 B 进去，Bob 恰好也喊了 B）。</p>
<p>但如果这个游戏<strong>重复 20 次</strong>，Alice 每次都能从 Bob 指定的出口出来，那 Alice 每次都蒙对的概率就只有$$\left(\frac{1}{2}\right)^{20}$$，也就是大约是百万分之一。这时候 Bob 就有十足的把握相信，Alice 确实知道那个咒语。</p>
<p>这个小游戏完美地展示了 ZKP 的三大特性：</p>
<ul>
<li><strong>完整性 (Completeness)</strong>：如果 Alice 真的知道咒语，她总能完成挑战。</li>
<li><strong>可靠性 (Soundness)</strong>：如果 Alice 不知道咒语，她几乎不可能骗过 Bob。</li>
<li><strong>零知识性 (Zero-Knowledge)</strong>：在整个过程中，Bob 除了“Alice 知道咒语”这个事实外，没有学到任何关于咒语本身的信息。</li>
</ul>
<p>另外我们可以看到一个重要的属性是，零知识证明并非数学意义上的证明，因为可能存在一个很小很小的概率，即<em>可靠性误差</em> – 作弊的证明者能够骗过验证者，但实际实践中我们几乎可以忽略这个极小的概率。</p>
<h2 id="Where’s-Wally"><a href="#Where’s-Wally" class="headerlink" title="Where’s Wally"></a>Where’s Wally</h2><p>还有另外一个比较简单的例子来说明零知识证明：<br><img src="/images/ob_pasted-image-20250916104843.png" alt=""></p>
<p>Alice 和 Bob 玩游戏看谁先找到 Wally，Alice 说她找到了，她想要证明自己已经得到了结果，但又不想透露更多信息给 Bob，所以她可以用一个<strong>几倍面积</strong>黑色的纸片遮住整个图画，然后把 Wally 位置那里在黑色纸片上打个小孔，这样 Bob 就可以看到 Wally，而不知道 Wally 在哪儿。注意这里为什么强调几倍面积的黑色纸片，如果是和原图相同大小的纸片，就可能暴露了 Wally 的大致方向和范围。</p>
<p>这个例子展示的 ZKP 另外一个特性是 Prover 通常是更耗费资源的 (从图片中找到 Wally 需要花费一定的时间)，而 Verifier 通常能很快验证。这个特性才能让一些区块链项目利用 ZKP 把链上计算挪到链下计算，而链上只是做验证。</p>
<h2 id="最简单的-ZKP-代码"><a href="#最简单的-ZKP-代码" class="headerlink" title="最简单的 ZKP 代码"></a>最简单的 ZKP 代码</h2><p>两个例子很棒，但代码怎么写？</p>
<p>我接触到的第一个协议叫 Schnorr 身份验证，它要证明的是：“我知道与公钥 <code>h</code> 对应的私钥 <code>x</code>，其中 <code>h = g^x mod p</code>”。这里的“咒语”就是 <code>x</code>，而那扇“魔法门”就是离散对数问题——从 <code>g, h, p</code> 反推出 <code>x</code> 极其困难。</p>
<p>这个协议的“交互式”版本，完美地复刻了洞穴里的“一来一回”：</p>
<ol>
<li><strong>Prover (我)</strong>: 随机选个数 <code>k</code>，计算 <code>t = g^k mod p</code> 发给 Verifier。这叫“承诺”。</li>
<li><strong>Verifier (你)</strong>: 随机给 Prover 一个数 <code>c</code>，这叫“挑战”。</li>
<li><strong>Prover</strong>: 根据收到的 <code>c</code>，计算 <code>r = k - c*x mod (p-1)</code> 并发回。这叫“响应”。</li>
<li><strong>Verifier</strong>: 验证 <code>g^r * h^c mod p</code> 是不是等于 Prover 一开始给的 <code>t</code>。</li>
</ol>
<p>完整代码在<a target="_blank" rel="noopener" href="https://github.com/chenyukang/ss/blob/06a90f7ec0cf7a3527eae2478c7dfea44b8a6240/schnorr-demo/src/main.rs#L8-L41">iteractive_schnorr</a></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">iteractive_schnorr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 公开参数：素数 p=204859, g=5, x=6 (秘密), h = 5^6 mod 204859 = 15625</span>
    <span class="token keyword">let</span> p<span class="token punctuation">:</span> <span class="token class-name">BigInt</span> <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">204859u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> g<span class="token punctuation">:</span> <span class="token class-name">BigInt</span> <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">5u32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token class-name">BigInt</span> <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">6u32</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 证明者的秘密</span>
    <span class="token keyword">let</span> h <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// h = g^x mod p</span>

    <span class="token comment">// 进行多轮证明 p</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token number">20</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 证明者：生成承诺 t = g^k mod p</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> rng <span class="token operator">=</span> <span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> k <span class="token operator">=</span> rng<span class="token punctuation">.</span><span class="token function">gen_bigint_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p <span class="token operator">-</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> t <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"证明者发送 t: &#123;&#125;"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 验证者：生成挑战 c (简化到 0..10)</span>
        <span class="token keyword">let</span> c<span class="token punctuation">:</span> <span class="token class-name">BigInt</span> <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>rng<span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"验证者挑战 c: &#123;&#125;"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 证明者：响应 r = k - c * x mod (p-1)</span>
        <span class="token keyword">let</span> order <span class="token operator">=</span> <span class="token operator">&amp;</span>p <span class="token operator">-</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阶</span>
        <span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>k <span class="token operator">-</span> <span class="token operator">&amp;</span>c <span class="token operator">*</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保正数</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"证明者响应 r: &#123;&#125;"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 验证者：检查 g^r * h^c == t mod p</span>
        <span class="token keyword">let</span> left <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token operator">*</span> h<span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>
        <span class="token keyword">if</span> left <span class="token operator">==</span> t <span class="token punctuation">&#123;</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"验证通过！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"验证失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但一来一回也太麻烦了，互联网应用需要的是一次性的“证明”。经过一番研究，密码学家们想出的一个绝妙技巧，叫做 <strong>Fiat-Shamir 启发式证明</strong>。</p>
<p>它的核心思想是：<strong>用哈希函数来模拟一个不可预测的“挑战者”</strong>。</p>
<p>Prover 不再等待 Verifier 给出挑战 <code>c</code>，而是自己计算 <code>c = hash(公开信息, 自己的承诺 t)</code>。因为哈希函数的雪崩效应，Prover 无法预测 <code>c</code> 的值来作弊，这就巧妙地把交互过程压缩了。</p>
<p>我们可以用 Rust 写出这样一个完整的<a target="_blank" rel="noopener" href="https://github.com/chenyukang/ss/blob/06a90f7ec0cf7a3527eae2478c7dfea44b8a6240/schnorr-demo/src/main.rs#L43-L109">非交互式证明程序 fiat_shamir</a>：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">fiat_shamir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// --- 公开参数 ---</span>
    <span class="token comment">// 在真实世界，p 应该是至少 2048 位的安全素数</span>
    <span class="token keyword">let</span> p<span class="token punctuation">:</span> <span class="token class-name">BigInt</span> <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">204859u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> g<span class="token punctuation">:</span> <span class="token class-name">BigInt</span> <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">2u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Prover 的秘密 (只有 Prover 知道)</span>
    <span class="token keyword">let</span> secret_x<span class="token punctuation">:</span> <span class="token class-name">BigInt</span> <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">123456u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Prover 的公钥 (所有人都知道)</span>
    <span class="token keyword">let</span> public_h <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>secret_x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"--- 公开参数 ---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p = &#123;&#125;"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"g = &#123;&#125;"</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"h = g^x mod p = &#123;&#125;"</span><span class="token punctuation">,</span> public_h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"-------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// --- PROVER: 生成证明 ---</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Prover 正在生成证明..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> rng <span class="token operator">=</span> <span class="token function">thread_rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> order <span class="token operator">=</span> <span class="token operator">&amp;</span>p <span class="token operator">-</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 1. 承诺：随机选一个 k, 计算 t = g^k mod p</span>
    <span class="token keyword">let</span> k <span class="token operator">=</span> rng<span class="token punctuation">.</span><span class="token function">gen_bigint_range</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> t <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>k<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2. 挑战 (Fiat-Shamir 的魔法在这里!):</span>
    <span class="token comment">// 把公开信息和承诺 t 一起哈希，模拟一个无法预测的挑战 c</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> hasher <span class="token operator">=</span> <span class="token class-name">Sha256</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hasher<span class="token punctuation">.</span><span class="token function">write_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>g<span class="token punctuation">.</span><span class="token function">to_bytes_be</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hasher<span class="token punctuation">.</span><span class="token function">write_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>public_h<span class="token punctuation">.</span><span class="token function">to_bytes_be</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hasher<span class="token punctuation">.</span><span class="token function">write_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span><span class="token function">to_bytes_be</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> hash_bytes <span class="token operator">=</span> hasher<span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from_bytes_be</span><span class="token punctuation">(</span><span class="token namespace">num_bigint<span class="token punctuation">::</span></span><span class="token class-name">Sign</span><span class="token punctuation">::</span><span class="token class-name">Plus</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hash_bytes<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token operator">&amp;</span>order<span class="token punctuation">;</span>

    <span class="token comment">// 3. 响应：计算 r = k - c*x (mod order)</span>
    <span class="token keyword">let</span> cx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>c <span class="token operator">*</span> <span class="token operator">&amp;</span>secret_x<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token operator">&amp;</span>order<span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>k <span class="token operator">-</span> cx<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token operator">&amp;</span>order<span class="token punctuation">;</span>
    <span class="token keyword">if</span> r <span class="token operator">&lt;</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">zero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        r <span class="token operator">+=</span> <span class="token operator">&amp;</span>order<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"证明已生成：(r = &#123;&#125;, c = &#123;&#125;)"</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"-------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// --- VERIFIER: 验证证明 ---</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Verifier 正在验证证明..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Verifier 为了验证，需要自己重新计算 t' = g^r * h^c mod p</span>
    <span class="token keyword">let</span> gr <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> hc <span class="token operator">=</span> public_h<span class="token punctuation">.</span><span class="token function">modpow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> t_prime <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>gr <span class="token operator">*</span> <span class="token operator">&amp;</span>hc<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>

    <span class="token comment">// Verifier 再用算出来的 t' 计算 c' = H(g || h || t')</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> hasher <span class="token operator">=</span> <span class="token class-name">Sha256</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hasher<span class="token punctuation">.</span><span class="token function">write_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>g<span class="token punctuation">.</span><span class="token function">to_bytes_be</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hasher<span class="token punctuation">.</span><span class="token function">write_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>public_h<span class="token punctuation">.</span><span class="token function">to_bytes_be</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hasher<span class="token punctuation">.</span><span class="token function">write_all</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t_prime<span class="token punctuation">.</span><span class="token function">to_bytes_be</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> hash_bytes <span class="token operator">=</span> hasher<span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c_prime <span class="token operator">=</span> <span class="token class-name">BigInt</span><span class="token punctuation">::</span><span class="token function">from_bytes_be</span><span class="token punctuation">(</span><span class="token namespace">num_bigint<span class="token punctuation">::</span></span><span class="token class-name">Sign</span><span class="token punctuation">::</span><span class="token class-name">Plus</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hash_bytes<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token operator">&amp;</span>order<span class="token punctuation">;</span>

    <span class="token keyword">if</span> c <span class="token operator">==</span> c_prime <span class="token punctuation">&#123;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"✅ 验证通过！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"❌ 验证失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上我们通过最简单的代码来演示了 ZKP 的基本思想，从数学原理上都是基于离散对数困难性。</p>
<h2 id="发散到-Passkeys"><a href="#发散到-Passkeys" class="headerlink" title="发散到 Passkeys"></a>发散到 Passkeys</h2><p>当我看到 Hash 的时候，我联想到了后台服务的密码存储，比如我们在做一个用户注册和登录功能的时候，为了安全我们是不会去存储用户的原始密码（秘密），而是会使用密码哈希方案，去存储 <code>hash(password + salt)</code>。</p>
<p>但这个密码哈希方案其实也泄露了“知识”，当你登录时会把 <code>123456</code> 发送给服务器，服务器计算 <code>hash(&quot;123456&quot; + salt)</code> 并与数据库中的值对比。</p>
<ul>
<li><strong>在传输过程中</strong>：密码是明文的（当然可以用 TLS/SSL 加密，但服务器在解密后会看到明文）。</li>
<li><strong>对服务器而言</strong>：服务器在验证那一瞬间是<strong>知道</strong>你的密码的。</li>
<li><strong>如果数据库被盗</strong>：攻击者拿到了 <code>hash(password + salt)</code> 的列表。这个哈希值本身就是一条<strong>重要的知识</strong>！它虽然不是密码原文，但它是密码的一个<strong>确定性指纹</strong>。攻击者可以进行：<ul>
<li><strong>字典攻击</strong>：尝试常用密码，计算哈希值来一一比对。</li>
<li><strong>彩虹表攻击</strong>：用一个预先计算好的哈希值数据库来反查。</li>
<li><strong>暴力破解</strong>：对所有可能的组合进行哈希计算。</li>
</ul>
</li>
</ul>
<p>这就是为什么我们需要“加盐（salt）”和使用慢哈希函数（如 Argon2, bcrypt），目的就是为了增加攻击者进行上述离线攻击的成本，但无论如何，<strong>哈希值本身就是泄露的“知识”</strong>。</p>
<p>所以如果我们要更安全，一点“知识”都不泄露，似乎 ZKP 适合做认证服务？注册时不存密码哈希，只存公钥 <code>h</code>。登录时，我发送一个 ZKP 证明，服务器验证一下就行了，数据库被拖库了都没事。</p>
<p>甚至更简单点其实就用公私钥对不是更方便和安全么，Nostr 就是这么做的 (钱包也是这个原理)，private key 是密码，每次发内容就用私钥签名内容，然后把 pubkey 带上，这样任何收到这条消息的节点都可以验证签名是否一致，这样就本质上通过各个 relay 节点形成一个去中心化的社交网络。</p>
<p>我按照这个思路去找 Web 相关的解决方案，业界给出的答案是 <strong>Passkeys (基于 WebAuthn 标准)</strong>，使用非对称加密来替代密码（私钥不出设备），Passkeys 是这样工作的：</p>
<ol>
<li><strong>注册：</strong> 你的设备（如 iPhone 或 Android 手机）在本地生成一对密钥（私钥和公钥）。私钥安全地存储在设备的硬件安全芯片中，<strong>永远不会离开设备</strong>。你把<strong>公钥</strong>发送给网站服务器。</li>
<li><strong>登录：</strong><ul>
<li>网站向你的设备发送一个“挑战”（一个随机数）。</li>
<li>你的设备用<strong>私钥</strong>对这个“挑战”进行签名，然后把签名发回给网站。</li>
<li>网站用它存储的你的<strong>公钥</strong>来验证这个签名是否有效。</li>
</ul>
</li>
<li><strong>用户体验：</strong> 整个过程对于用户来说，可能只是做一次指纹识别或面部识别来授权设备使用私钥。</li>
</ol>
<p><img src="/images/ob_pasted-image-20250916102634.png" alt=""></p>
<p>2019 年 3 月 4 日 WebAuthn Level 1 已经被 W3C 正式发布为“推荐标准 (Recommendation)”，标志着它成为了一个成熟、稳定、官方推荐的 Web 标准。</p>
<h2 id="通过“电路”证明程序的运行"><a href="#通过“电路”证明程序的运行" class="headerlink" title="通过“电路”证明程序的运行"></a>通过“电路”证明程序的运行</h2><p>从上面的例子我们看到，ZKP 很适合用来证明 Prover 知道某个秘密，比如一个数 <code>x</code> ，但 ZKP 的用途远不止于此，还可以证明<strong>任何计算过程</strong>的正确性。</p>
<p>为什么证明一个程序正确运行很重要，因为像以太坊这样的公链，如果所有的节点都运行同样的合约 (本质上就是一段程序代码) 多次，这无疑是很大的浪费，我们想通过 ZKP 把计算挪到链下，这样公链上的节点只需要验证程序被正确执行就可。</p>
<p>“我正确运行了一个复杂的程序，得到了这个输出。”—— 这要怎么证明？</p>
<p>答案是四个字：<strong>万物皆可电路 (Arithmetization)</strong>。</p>
<p>ZKP 系统（比如我们后面会聊的 zk-SNARKs）的“世界观”非常单纯，甚至有点笨拙，它看不懂我们人类写的高级代码，比如 <code>if/else</code> 语句、<code>for</code> 循环。</p>
<p>如果我们想让 ZKP 为我们工作，就必须先把我们要证明的东西，<strong>翻译</strong>成它唯一能听懂的语言。这个翻译过程，就是“<strong>算术化 (Arithmetization)</strong>”。而“电路”或“约束系统”，就是我们翻译出来的最终稿。这个重写的过程，就是“<strong>拍扁 (Flattening)</strong>”。你把一个有层次、有复杂逻辑的程序，变成了一个长长的、线性的、只包含最基本算术运算的指令列表。</p>
<p>任何程序，无论多复杂，都可以被“拍扁”成一系列最基础的加法和乘法约束。比如 <code>out = x*x*x + x + 5</code> 这段代码，可以被分解为：</p>
<ul>
<li><code>v1 = x * x</code></li>
<li><code>v2 = v1 * x</code></li>
<li><code>v3 = v2 + x</code></li>
<li><code>out = v3 + 5</code></li>
</ul>
<p>于是，证明“我正确运行了程序”，就转化为了证明“<strong>我知道一组数 (x, v1, v2, v3, out) 能同时满足上面这一堆等式</strong>”。这个过程，就是把代码逻辑“算术化”，变成了 ZKP 系统可以处理的语言。</p>
<p>那我们来看 Verifier 如何验证上面的计算过程，最原始的当然是根据输入，来一条一条的执行上面被拍平后的指令集，但这样的工作量和自己去执行整个程序就差不多了。</p>
<p>为了避免这种蛮力验证，密码学家们引入了一个极其强大的数学工具：<strong>多项式 (Polynomials)</strong>。<br>整个魔法流程如下：</p>
<ol>
<li><p><strong>Prover 的艰巨任务：将所有约束“编织”进一个多项式</strong> Prover 会执行一个惊人的转换：他会找到一种方法 (Groth16、PLONK、STARKs 等)，将我们前面提到的那一整个约束系统 (<code>x * x - v1 = 0</code>, <code>v1 * x - v2 = 0</code>, …) 全部编码成<strong>一个单一的、巨大的多项式方程</strong>。</p>
<p> 我们可以把这个巨大的“主多项式”记为 <code>P(z)</code>。这个 <code>P(z)</code> 有一个神奇的特性：</p>
<blockquote>
<p><strong>当且仅当 Prover 提供的所有见证值 (x, v1, v2…) 都完全正确、满足所有原始约束时，这个主多项式 <code>P(z)</code> 在某些特定的点上才会等于 0。</strong></p>
</blockquote>
<p> 如果 Prover 在任何地方作弊，哪怕只修改了一个微不足道的值，最终生成的那个 <code>P(z)</code> 就会是一个<strong>完全不同</strong>的多项式。</p>
</li>
<li><p><strong>验证者的捷径 – 随机点检查 (Random Spot-Check)</strong> ：现在验证者的问题从“检查成千上万个小等式”变成了“如何验证 Prover 的那个巨大多项式 <code>P(z)</code> 是正确的？”</p>
<p> 难道要把整个巨大的多项式传输过来再计算一遍吗？当然不是！这里用到了密码学中一个非常深刻的原理，通常与 <strong>Schwartz-Zippel 引理</strong> 有关。</p>
<p> <strong>它的直观思想是</strong>：</p>
<blockquote>
<p>如果我有两个不同的、阶数很高的多项式 <code>P(z)</code> 和 <code>F(z)</code>（F 代表伪造的），然后我从一个极大的数域里随机挑选一个点 <code>s</code>，那么 <code>P(s)</code> 和 <code>F(s)</code> 的计算结果相等的概率<strong>几乎为零</strong>。</p>
</blockquote>
<p> 这就给了验证者一个巨大的捷径：</p>
<ul>
<li>Verifier 不需要关心那个巨大的多项式长什么样。</li>
<li>它只需要在一个<strong>秘密的、随机选择的点 <code>s</code></strong> 上，对 Prover 的多项式进行一次“抽查”。</li>
<li>它通过密码学协议向 Prover 发起一个挑战：“嘿，你声称你有一个正确的多项式，那你告诉我，在 <code>s</code> 这个点上，你的多项式计算出来的值是多少？”</li>
</ul>
</li>
</ol>
<p>所以这里的 ZKP 证明里到底包含什么？</p>
<p>在一个典型的 zk-SNARK（比如 Groth16）中，那个小小的证明通常是由<strong>几个椭圆曲线上的点 (points on an elliptic curve)</strong> 组成的。可以把这些“点”想象成一种<strong>具备神奇数学特性的高级指纹</strong>。这些点就是 Prover 对他构造的那些巨大多项式（比如 <code>A(x)</code>, <code>B(x)</code>, <code>C(x)</code>，它们共同构成了我们之前说的那个主多项式 <code>P(x)</code>) 的“承诺”。</p>
<p>这里的魔法在于 Verifier 不需要通过这些“点”来反推出原始的多项式。相反，他可以直接在这些“点”上进行一种特殊运算，这种运算的结果<strong>等价于</strong>在原始多项式上进行“随机点检查”。这个特殊的运算，就是 zk-SNARKs 的核心引擎之一：<strong>配对 (Pairings)</strong>。<em>并非所有 ZK 架构都用配对；Groth16/部分 KZG-based 系统用配对，STARKs 则用哈希/FRI 等替代方案。</em></p>
<p>让我们把整个流程串起来 (zk-SNARK)，看看 Prover 的多项式是如何被“隔空”验证的：</p>
<ol>
<li><p><strong>准备阶段 (Setup)</strong>：</p>
<ul>
<li>协议约定好了一套公共参数（包含一个“验证密钥”）。这个验证密钥里编码了“游戏规则”，包括对程序正确性的期望。</li>
</ul>
</li>
<li><p><strong>Prover 的工作</strong>：</p>
<ul>
<li>他有他的秘密“见证 (Witness)”。</li>
<li>他按照约定，将程序的约束系统转化成几个巨大的多项式 <code>A(x), B(x), C(x)</code>。（这些多项式满足 <code>A(x) * B(x) - C(x) = H(x) * Z(x)</code> 的关系，这是 R1CS 算术化的结果）。</li>
<li><strong>关键一步</strong>：他并没有把这些多项式发出去。而是用他的“证明密钥”，计算出这几个多项式在某个秘密点 <code>s</code> 上的<strong>椭圆曲线点表示</strong>。这些点就是对多项式的“承诺”。</li>
<li>最终生成的<strong>证明 (Proof)</strong>，就是由这几个计算出来的椭圆曲线点组成的，它非常小。</li>
</ul>
</li>
<li><p><strong>Verifier 的工作</strong>：</p>
<ul>
<li>Verifier 收到这个由几个点组成的、小小的证明。</li>
<li>Verifier <strong>完全看不到</strong> Prover 的任何多项式 (<code>A(x)</code>, <code>B(x)</code>, <code>C(x)</code>)。</li>
<li><p>Verifier 拿出“验证密钥”，并将 Prover 提交的这几个“承诺点”代入一个预设的<strong>配对验证方程 (Pairing Verification Equation)</strong>。</p>
<p>这个方程被设计得极其巧妙，它的等号左边和右边分别对应着 Prover 原始多项式关系 <code>A*B-C=H*Z</code> 的加密形式。</p>
<blockquote>
<p><strong>当且仅当 Prover 原始的、未知的那些多项式确实满足正确的数学关系时，这个配对验证方程的等号才能成立。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><strong>所以：</strong></p>
<ul>
<li><strong>证明里是什么？</strong> 是对 Prover 秘密多项式的<strong>密码学承诺</strong>（通常是几个椭圆曲线点）。</li>
<li><strong>Verifier 如何知道多项式？</strong> 他<strong>不需要知道</strong>。他只需要知道<strong>验证规则</strong>（即那个配对验证方程）。</li>
<li><strong>如何验证？</strong> 他把 Prover 的“承诺”（证明）代入“规则”（验证方程）。如果方程成立，他就知道那些他看不见的、被承诺了的多项式一定是正确的，进而推断出 Prover 的原始计算是正确的。</li>
</ul>
<p>Prover 把“我知道所有题的答案”这个事实，通过复杂的计算，浓缩成了一个包含几个关键“密码学指纹”的信封（证明）。Verifier 不用拆开信封看所有答案，他只需要用一种特殊的“X 光机”（配对验证）照一下这个信封，就能瞬间知道里面的答案是不是都对。</p>
<h2 id="ZKP-相关的应用"><a href="#ZKP-相关的应用" class="headerlink" title="ZKP 相关的应用"></a>ZKP 相关的应用</h2><p>区块链因为其去中心化和对隐私性的严苛要求，ZKP 非常适合用在这个领域。</p>
<h4 id="扩容-ZK-Rollups-让以太坊快如闪电"><a href="#扩容-ZK-Rollups-让以太坊快如闪电" class="headerlink" title="扩容 (ZK-Rollups): 让以太坊快如闪电"></a>扩容 (ZK-Rollups): 让以太坊快如闪电</h4><p>以太坊慢又贵，因为每个节点都要重复执行每笔交易。ZK-Rollup 的思路就像是找了个超级课代表：</p>
<ol>
<li>在链下 (L2) 执行成千上万笔交易。</li>
<li>为“我已正确处理了这一切”这个声明，生成一个微小的 ZK 证明。</li>
<li>把这个证明提交到链上 (L1)。</li>
</ol>
<p>L1 的所有节点不再需要重复计算那几千笔交易，它们只需要做一件极其廉价的事：<strong>验证那个 ZK 证明</strong>。就像老师检查作业，不再需要自己从头算一遍，只需要看一眼课代表盖的“全对”印章。</p>
<p>总而言之，Rollup 的核心创新在于将<strong>计算执行</strong>与<strong>数据结算</strong>分离。它利用 ZKP 等密码学技术，将繁重的“执行”环节放在链下，然后只把一个轻量的“证明”和必要数据放在链上进行“结算”，从而实现了对以太坊主网的大规模扩容。</p>
<h4 id="隐私-Tornado-Cash-你的钱，只有你知道"><a href="#隐私-Tornado-Cash-你的钱，只有你知道" class="headerlink" title="隐私 (Tornado Cash): 你的钱，只有你知道"></a>隐私 (Tornado Cash): 你的钱，只有你知道</h4><p>Tornado Cash 是个混币器，你存入 100 ETH，然后从一个全新的地址取出来，没人能把这两者联系起来。它的机制是：</p>
<ul>
<li><p><strong>存款</strong>：你在本地生成一个秘密凭证（包含<code>Secret</code>和<code>Nullifier</code>），然后计算出它的哈希值——“承诺 (Commitment)”，把承诺和钱一起存入合约。</p>
</li>
<li><p><strong>取款</strong>：你用一个全新的地址，提交一个 ZK 证明，这个证明：“我知道某个树叶的 Secret 且未被花费”，同时提交 <strong>nullifier</strong>（通常是对秘密做散列得到的唯一标识）以标记已花费。这样合约无需关联存款者身份即可阻止双花。</p>
</li>
</ul>
<p>整个过程，合约就像个盲人会计，它不知道是“谁”存的，也不知道取款对应的是“哪一一笔”存款，它只负责验证 ZKP 规则是否被遵守。</p>
<h3 id="ZKP-在-AI-的应用"><a href="#ZKP-在-AI-的应用" class="headerlink" title="ZKP 在 AI 的应用"></a>ZKP 在 AI 的应用</h3><p>ZKP 应用在大模型也是最前沿、激动人心的领域。例如 AI 模型（尤其是大型语言模型）的权重是极其宝贵的商业机密。用户的数据又极其隐私。如何让一个 AI 模型在不暴露其内部权重的情况下，处理用户的隐私数据，并向用户证明它确实是用了那个宣称的高级模型，而不是一个廉价的“冒牌货”？</p>
<p>ZKP 解决方案 (ZKML - Zero-Knowledge Machine Learning)：<br> 模型推理证明：模型提供方可以对一次推理过程生成 ZK 证明，证实“我使用我宣称的那个模型（其哈希值是公开的），处理了你的输入数据，得出了这个输出结果”。这向用户保证了模型的真实性，同时保护了模型的知识产权。</p>
<p>数据隐私证明：用户可以对自己的数据生成 ZK 证明，证实“我的数据（例如医疗记录）符合某个特定标准（例如，有某种疾病特征）”，然后将这个证明提交给 AI 模型进行统计或研究，而无需上传原始的隐私数据。</p>
<p>这里有更多相关的资料：<a target="_blank" rel="noopener" href="https://world.org/blog/engineering/intro-to-zkml">An introduction to zero-knowledge machine learning (ZKML)</a></p>
<h2 id="零知识证明和硬件"><a href="#零知识证明和硬件" class="headerlink" title="零知识证明和硬件"></a>零知识证明和硬件</h2><p>前面我们谈到，在 ZKP 中<strong>Prover</strong>（证明者）端计算量最大，主要集中在以下几个方面：</p>
<ul>
<li><strong>多项式承诺方案</strong>：这是现代零知识证明（如 zk-SNARKs、zk-STARKs）的核心。证明者需要将计算任务转化为多项式，并对这些多项式进行一系列复杂的加密运算，例如<strong>多项式插值、求导、卷积、快速傅里叶变换（FFT）</strong> 等。这些运算的复杂度很高，尤其是当要证明的计算规模很大时。</li>
<li><strong>同态加密运算或椭圆曲线点运算</strong>：在一些零知识证明协议中，为了生成和验证证明，需要进行大量的<strong>椭圆曲线点乘</strong>运算。这种运算在数学上非常耗时，尤其是当需要处理大量的点时。</li>
<li><strong>哈希函数计算</strong>：为了将复杂的数据结构或计算结果进行压缩和承诺，证明者会使用到大量的<strong>加密哈希函数</strong>，例如 SHA-256、Poseidon 等。</li>
</ul>
<p>而在<strong>Verifier</strong>（验证者）端计算量相对较小，这也是零知识证明的重要优势之一，但它仍然需要进行一些关键的计算，比如：</p>
<ul>
<li><strong>椭圆曲线配对运算（Pairing）</strong>：在 zk-SNARKs 等协议中，验证者需要进行<strong>椭圆曲线配对</strong>运算来验证证明。这是一种特殊的加密操作，虽然比证明者的计算量小得多，但仍然需要一定的计算资源。</li>
<li><strong>哈希函数和多项式求值</strong>：验证者也需要进行一些哈希计算和多项式求值来检查证明的有效性。</li>
</ul>
<p>总的来说，零知识证明的计算量主要耗费在<strong>Prover</strong>端，因为它需要对整个计算过程进行完整的加密转换和证明生成，而这些步骤依赖于高复杂度的多项式和椭圆曲线运算。所以我们看到一些专门为此服务的硬件 FPGA、ASIC、GPU。</p>
<p>而 RISC-V 因为其<strong>可扩展性</strong>和<strong>模块化设计</strong>、开源的标准等优势，是实现零知识证明硬件加速的重要“基石”之一，<a target="_blank" rel="noopener" href="https://dev.risczero.com/api/getting-started">risc0 是个值得关注的项目</a></p>
<h2 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=fOGdb1CTu5c">Computer Scientist Explains One Concept in 5 Levels of Difficulty</a> 向不同知识背景的人介绍零知识证明。</p>
</li>
<li><p>要深入理解 ZKP 需要更多数学知识，<a target="_blank" rel="noopener" href="https://vitalik.eth.limo/general/2017/11/09/starks_part_1.html">STARKs, Part I: Proofs with Polynomials</a> 以太坊创始人的博客，他用相对简单的语言解释极其复杂的密码学概念，是 ZKP 入门最经典的读物。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rareskills.io/zk-book">The zk-book</a>  一个非常棒的在线开源书籍，逐步讲解构建一个零知识证明系统所需的数学知识，从有限域、椭圆曲线到多项式承诺，内容非常扎实。</p>
</li>
</ul>
</section>

    <p></p>

  
    <!-- 二维码 START -->
    
        <div class="qrcode">
            <img src="/images/wechat-qr-code.jpg" height="160" width="160">
            <figcaption>公号同步更新，欢迎关注👻</figcaption>
      </div>
    

    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Rust" >
    <span class="tag-code">Rust</span>
  </a>

  <a href="/tags#Cryptography" >
    <span class="tag-code">Cryptography</span>
  </a>

  <a href="/tags#Blockchain" >
    <span class="tag-code">Blockchain</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/p/rust-in-cloudflare-incident/">
        <span class="nav-arrow">← </span>
        
          Rust 背锅了：Cloudflare 故障分析
        
      </a>
    
    
      <a class="nav-right" href="/p/riscv-vm/">
        
          RISC-V from Scratch: B ...
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->

    <!-- 二维码 END -->
    
      <!-- No Comment -->
    

    <script src="https://utteranc.es/client.js"
      repo="chenyukang/chenyukang.github.io"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>


  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title"></strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E9%AD%94%E6%B3%95%E6%B4%9E%E7%A9%B4"><span class="toc-nav-text">魔法洞穴</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Where%E2%80%99s-Wally"><span class="toc-nav-text">Where’s Wally</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-ZKP-%E4%BB%A3%E7%A0%81"><span class="toc-nav-text">最简单的 ZKP 代码</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%8F%91%E6%95%A3%E5%88%B0-Passkeys"><span class="toc-nav-text">发散到 Passkeys</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E9%80%9A%E8%BF%87%E2%80%9C%E7%94%B5%E8%B7%AF%E2%80%9D%E8%AF%81%E6%98%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-nav-text">通过“电路”证明程序的运行</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ZKP-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-nav-text">ZKP 相关的应用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%89%A9%E5%AE%B9-ZK-Rollups-%E8%AE%A9%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BF%AB%E5%A6%82%E9%97%AA%E7%94%B5"><span class="toc-nav-text">扩容 (ZK-Rollups): 让以太坊快如闪电</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%9A%90%E7%A7%81-Tornado-Cash-%E4%BD%A0%E7%9A%84%E9%92%B1%EF%BC%8C%E5%8F%AA%E6%9C%89%E4%BD%A0%E7%9F%A5%E9%81%93"><span class="toc-nav-text">隐私 (Tornado Cash): 你的钱，只有你知道</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ZKP-%E5%9C%A8-AI-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-nav-text">ZKP 在 AI 的应用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E5%92%8C%E7%A1%AC%E4%BB%B6"><span class="toc-nav-text">零知识证明和硬件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%9B%B4%E5%A4%9A%E5%8F%82%E8%80%83"><span class="toc-nav-text">更多参考</span></a></li></ol>
    
  </div>
</aside>

  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://catcoding.me/p/zero-knowledge-proof/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW * 3 / 4}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer" id="footer">
    <p class="copyright">
        &copy;
        2025 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a> with <a target="_blank" rel="noopener" href="https://github.com/yanm1ng/hexo-theme-vexo">Vexo</a>
    </p>
</footer>

<script>
    function async(u, c) {
        var d = document,
            t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) {
            o.addEventListener('load', function(e) {
                c(null, e);
            }, false);
        }
        s.parentNode.insertBefore(o, s);
    }
</script>
<script>
    async("//catcoding.me/js/fastclick.min.js", function() {
        FastClick.attach(document.body);
    })
</script>


<script src="/js/script.js"></script>

  </body>
</html>